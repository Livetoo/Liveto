import {
  require_jsx_runtime
} from "./chunk-IULEFUF5.js";
import {
  require_react_dom
} from "./chunk-RY6NLCXT.js";
import {
  require_react
} from "./chunk-I773Y2XN.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET2.length; z++) {
      const x = ALPHABET2.charAt(z);
      ALPHABET_MAP[x] = z;
    }
    function polymodStep(pre) {
      const b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const c = prefix.charCodeAt(i2);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const v = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value2 = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i2 = 0; i2 < data.length; ++i2) {
        value2 = value2 << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value2 >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value2 << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value2 << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes2) {
      return convert(bytes2, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i2 = 0; i2 < words.length; ++i2) {
          const x = words[i2];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET2.charAt(x);
        }
        for (let i2 = 0; i2 < 6; ++i2) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i2 = 0; i2 < 6; ++i2) {
          const v = chk >> (5 - i2) * 5 & 31;
          result += ALPHABET2.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split2);
        const wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i2 = 0; i2 < wordChars.length; ++i2) {
          const c = wordChars.charAt(i2);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i2 + 6 >= wordChars.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl2) {
      "use strict";
      var gf = function(init) {
        var i2, r = new Float64Array(16);
        if (init) for (i2 = 0; i2 < init.length; i2++) r[i2] = init[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i2, h, l) {
        x[i2] = h >> 24 & 255;
        x[i2 + 1] = h >> 16 & 255;
        x[i2 + 2] = h >> 8 & 255;
        x[i2 + 3] = h & 255;
        x[i2 + 4] = l >> 24 & 255;
        x[i2 + 5] = l >> 16 & 255;
        x[i2 + 6] = l >> 8 & 255;
        x[i2 + 7] = l & 255;
      }
      function vn2(x, xi2, y, yi, n2) {
        var i2, d = 0;
        for (i2 = 0; i2 < n2; i2++) d |= x[xi2 + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi2, y, yi) {
        return vn2(x, xi2, y, yi, 16);
      }
      function crypto_verify_32(x, xi2, y, yi) {
        return vn2(x, xi2, y, yi, 32);
      }
      function core_salsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x2 >>> 0 & 255;
        o2[9] = x2 >>> 8 & 255;
        o2[10] = x2 >>> 16 & 255;
        o2[11] = x2 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n2, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n2[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n2, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n2[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = x[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n2, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n2, k, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn2, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n2, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n2, k, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn2, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t22, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t22 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t22 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t22, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t22 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t22 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t22 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g[i2] = this.h[i2] + c;
          c = g[i2] >>> 13;
          g[i2] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes2) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i2 = 0; i2 < bytes2; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n2, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n2);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n2, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n2, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n2, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n2, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n2, k) {
        var i2;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n2, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n2, k);
        for (i2 = 0; i2 < 32; i2++) m[i2] = 0;
        return 0;
      }
      function set25519(r, a3) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a3[i2] | 0;
      }
      function car25519(o2) {
        var i2, v, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v = o2[i2] + c + 65535;
          c = Math.floor(v / 65536);
          o2[i2] = v - c * 65536;
        }
        o2[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t3, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t3 = c & (p[i2] ^ q[i2]);
          p[i2] ^= t3;
          q[i2] ^= t3;
        }
      }
      function pack25519(o2, n2) {
        var i2, j, b;
        var m = gf(), t3 = gf();
        for (i2 = 0; i2 < 16; i2++) t3[i2] = n2[i2];
        car25519(t3);
        car25519(t3);
        car25519(t3);
        for (j = 0; j < 2; j++) {
          m[0] = t3[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m[i2] = t3[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
            m[i2 - 1] &= 65535;
          }
          m[15] = t3[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t3, m, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t3[i2] & 255;
          o2[2 * i2 + 1] = t3[i2] >> 8;
        }
      }
      function neq25519(a3, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a3);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a3) {
        var d = new Uint8Array(32);
        pack25519(d, a3);
        return d[0] & 1;
      }
      function unpack25519(o2, n2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A(o2, a3, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a3[i2] + b[i2];
      }
      function Z2(o2, a3, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a3[i2] - b[i2];
      }
      function M(o2, a3, b) {
        var v, c, t0 = 0, t1 = 0, t22 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a3[0];
        t0 += v * b0;
        t1 += v * b1;
        t22 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a3[1];
        t1 += v * b0;
        t22 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a3[2];
        t22 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a3[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a3[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a3[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a3[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a3[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t222 += v * b15;
        v = a3[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t222 += v * b14;
        t23 += v * b15;
        v = a3[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t222 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a3[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t222 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a3[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t222 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a3[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t222 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a3[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t222 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a3[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t222 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a3[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t222 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t222;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t22 + c + 65535;
        c = Math.floor(v / 65536);
        t22 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t22 + c + 65535;
        c = Math.floor(v / 65536);
        t22 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t22;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S(o2, a3) {
        M(o2, a3, a3);
      }
      function inv25519(o2, i2) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i2[a3];
        for (a3 = 253; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 2 && a3 !== 4) M(c, c, i2);
        }
        for (a3 = 0; a3 < 16; a3++) o2[a3] = c[a3];
      }
      function pow2523(o2, i2) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i2[a3];
        for (a3 = 250; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 1) M(c, c, i2);
        }
        for (a3 = 0; a3 < 16; a3++) o2[a3] = c[a3];
      }
      function crypto_scalarmult(q, n2, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i2;
        var a3 = gf(), b = gf(), c = gf(), d = gf(), e3 = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z[i2] = n2[i2];
        z[31] = n2[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x[i2];
          d[i2] = a3[i2] = c[i2] = 0;
        }
        a3[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a3, b, r);
          sel25519(c, d, r);
          A(e3, a3, c);
          Z2(a3, a3, c);
          A(c, b, d);
          Z2(b, b, d);
          S(d, e3);
          S(f, a3);
          M(a3, c, a3);
          M(c, b, e3);
          A(e3, a3, c);
          Z2(a3, a3, c);
          S(b, a3);
          Z2(c, d, f);
          M(a3, c, _121665);
          A(a3, a3, d);
          M(c, c, a3);
          M(a3, d, f);
          M(d, b, x);
          S(b, e3);
          sel25519(a3, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x[i2 + 16] = a3[i2];
          x[i2 + 32] = c[i2];
          x[i2 + 48] = b[i2];
          x[i2 + 64] = d[i2];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n2) {
        return crypto_scalarmult(q, n2, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n2, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n2, k);
      }
      function crypto_box_open(m, c, d, n2, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n2, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl2, m, n2) {
        var wh = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl2, i2, j, h, l, a3, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
        var pos = 0;
        while (n2 >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl2[i2] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a3 = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i2 * 2];
            l = K2[i2 * 2 + 1];
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i2 % 16];
            l = wl2[i2 % 16];
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a3 >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl2 = a3 & 65535 | b << 16;
            h = th;
            l = tl2;
            a3 = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a3 >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a3 & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a3 = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl2;
            a3 += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a3 >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a3 & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl2[j];
                a3 = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl2[(j + 9) % 16];
                a3 += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl2 = wl2[(j + 1) % 16];
                h = (th >>> 1 | tl2 << 32 - 1) ^ (th >>> 8 | tl2 << 32 - 8) ^ th >>> 7;
                l = (tl2 >>> 1 | th << 32 - 1) ^ (tl2 >>> 8 | th << 32 - 8) ^ (tl2 >>> 7 | th << 32 - 7);
                a3 += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl2 = wl2[(j + 14) % 16];
                h = (th >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl2 >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th << 32 - 6);
                a3 += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a3 >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl2[j] = a3 & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl2[0];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl2[0] = al0 = a3 & 65535 | b << 16;
          h = ah1;
          l = al1;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl2[1];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl2[1] = al1 = a3 & 65535 | b << 16;
          h = ah2;
          l = al2;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl2[2];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl2[2] = al2 = a3 & 65535 | b << 16;
          h = ah3;
          l = al3;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl2[3];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl2[3] = al3 = a3 & 65535 | b << 16;
          h = ah4;
          l = al4;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl2[4];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl2[4] = al4 = a3 & 65535 | b << 16;
          h = ah5;
          l = al5;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl2[5];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl2[5] = al5 = a3 & 65535 | b << 16;
          h = ah6;
          l = al6;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl2[6];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl2[6] = al6 = a3 & 65535 | b << 16;
          h = ah7;
          l = al7;
          a3 = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl2[7];
          a3 += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a3 >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl2[7] = al7 = a3 & 65535 | b << 16;
          pos += 128;
          n2 -= 128;
        }
        return n2;
      }
      function crypto_hash(out, m, n2) {
        var hh = new Int32Array(8), hl2 = new Int32Array(8), x = new Uint8Array(256), i2, b = n2;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl2[0] = 4089235720;
        hl2[1] = 2227873595;
        hl2[2] = 4271175723;
        hl2[3] = 1595750129;
        hl2[4] = 2917565137;
        hl2[5] = 725511199;
        hl2[6] = 4215389547;
        hl2[7] = 327033209;
        crypto_hashblocks_hl(hh, hl2, m, n2);
        n2 %= 128;
        for (i2 = 0; i2 < n2; i2++) x[i2] = m[b - n2 + i2];
        x[n2] = 128;
        n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
        x[n2 - 9] = 0;
        ts64(x, n2 - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl2, x, n2);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl2[i2]);
        return 0;
      }
      function add2(p, q) {
        var a3 = gf(), b = gf(), c = gf(), d = gf(), e3 = gf(), f = gf(), g = gf(), h = gf(), t3 = gf();
        Z2(a3, p[1], p[0]);
        Z2(t3, q[1], q[0]);
        M(a3, a3, t3);
        A(b, p[0], p[1]);
        A(t3, q[0], q[1]);
        M(b, b, t3);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z2(e3, b, a3);
        Z2(f, d, c);
        A(g, d, c);
        A(h, b, a3);
        M(p[0], e3, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e3, h);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi2 = gf();
        inv25519(zi2, p[2]);
        M(tx, p[0], zi2);
        M(ty, p[1], zi2);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add2(q, p);
          add2(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i2] * L2[j - (i2 - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L2[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L2[j];
        for (i2 = 0; i2 < 32; i2++) {
          x[i2 + 1] += x[i2] >> 8;
          r[i2] = x[i2] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n2, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n2 + 64;
        for (i2 = 0; i2 < n2; i2++) sm[64 + i2] = m[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n2 + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h, sm, n2 + 64);
        reduce(h);
        for (i2 = 0; i2 < 64; i2++) x[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x[i2 + j] += h[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t3 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z2(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t3, den6, num);
        M(t3, t3, den);
        pow2523(t3, t3);
        M(t3, t3, num);
        M(t3, t3, den);
        M(t3, t3, den);
        M(r[0], t3, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z2(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n2, pk) {
        var i2;
        var t3 = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n2 < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i2 = 0; i2 < n2; i2++) m[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m[i2 + 32] = pk[i2];
        crypto_hash(h, m, n2);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add2(p, q);
        pack(t3, p);
        n2 -= 64;
        if (crypto_verify_32(sm, 0, t3, 0)) {
          for (i2 = 0; i2 < n2; i2++) m[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n2; i2++) m[i2] = sm[i2 + 64];
        return n2;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L: L2,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z: Z2,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n2) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n2.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl2.randomBytes = function(n2) {
        var b = new Uint8Array(n2);
        randombytes(b, n2);
        return b;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i2 = 0; i2 < msg.length; i2++) m[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n2, p) {
        checkArrayTypes(n2, p);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n2, p);
        return q;
      };
      nacl2.scalarMult.base = function(n2) {
        checkArrayTypes(n2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n2);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m.length; i2++) m[i2] = tmp[i2];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn2(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn2) {
        randombytes = fn2;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n2) {
            var i2, v = new Uint8Array(n2);
            for (i2 = 0; i2 < n2; i2 += QUOTA) {
              crypto3.getRandomValues(v.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n2; i2++) x[i2] = v[i2];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl2.setPRNG(function(x, n2) {
              var i2, v = crypto3.randomBytes(n2);
              for (i2 = 0; i2 < n2; i2++) x[i2] = v[i2];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/@suiet/wallet-kit/dist/index.js
var Q = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.12.0";
var TARGETED_RPC_VERSION = "1.36.0";

// node_modules/@mysten/sui/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// node_modules/@mysten/sui/dist/esm/client/rpc-websocket-client.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _WebsocketClient_instances;
var setupWebSocket_fn;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd(this, _WebsocketClient_instances);
    __privateAdd(this, _requestId, 0);
    __privateAdd(this, _disconnects, 0);
    __privateAdd(this, _webSocket, null);
    __privateAdd(this, _connectionPromise, null);
    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params) {
    const webSocket = await __privateMethod(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet(this, _requestId, __privateGet(this, _requestId) + 1);
      __privateGet(this, _pendingRequests).set(__privateGet(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet(this, _pendingRequests).delete(__privateGet(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet(this, _requestId), method, params }));
    }).then(({ error: error2, result }) => {
      if (error2) {
        throw new JsonRpcError(error2.message, error2.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet(this, _connectionPromise)) {
    return __privateGet(this, _connectionPromise);
  }
  __privateSet(this, _connectionPromise, new Promise((resolve) => {
    var _a2;
    (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
    __privateSet(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet(this, _webSocket).addEventListener("open", () => {
      __privateSet(this, _disconnects, 0);
      resolve(__privateGet(this, _webSocket));
    });
    __privateGet(this, _webSocket).addEventListener("close", () => {
      __privateWrapper(this, _disconnects)._++;
      if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod(this, _WebsocketClient_instances, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error2) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error2 }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet(this, _connectionPromise);
};
reconnect_fn = async function() {
  var _a2;
  (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
  __privateSet(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null) return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// node_modules/@mysten/sui/dist/esm/client/http-transport.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value2) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet2 = (obj, member, value2, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _requestId2;
var _options;
var _websocketClient;
var _SuiHTTPTransport_instances;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd2(this, _SuiHTTPTransport_instances);
    __privateAdd2(this, _requestId2, 0);
    __privateAdd2(this, _options);
    __privateAdd2(this, _websocketClient);
    __privateSet2(this, _options, options);
  }
  fetch(input, init) {
    const fetchFn = __privateGet2(this, _options).fetch ?? fetch;
    if (!fetchFn) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetchFn(input, init);
  }
  async request(input) {
    var _a2, _b;
    __privateSet2(this, _requestId2, __privateGet2(this, _requestId2) + 1);
    const res = await this.fetch(((_a2 = __privateGet2(this, _options).rpc) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        ...(_b = __privateGet2(this, _options).rpc) == null ? void 0 : _b.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet2(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod2(this, _SuiHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_SuiHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a2;
  if (!__privateGet2(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet2(this, _options).WebSocketConstructor ?? WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet2(this, _websocketClient, new WebsocketClient(
      ((_a2 = __privateGet2(this, _options).websocket) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url,
      {
        WebSocketConstructor,
        ...__privateGet2(this, _options).websocket
      }
    ));
  }
  return __privateGet2(this, _websocketClient);
};

// node_modules/@mysten/bcs/node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i2 = 0; i2 < ALPHABET2.length; i2++) {
    const x = ALPHABET2.charAt(i2);
    const xc2 = x.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i2 = 0;
      for (let it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i2 = 0;
      for (let it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string2) {
    const buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default = base;

// node_modules/@mysten/bcs/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@mysten/bcs/dist/esm/b58.js
var toBase58 = (buffer) => esm_default2.encode(buffer);
var fromBase58 = (str) => esm_default2.decode(str);

// node_modules/@mysten/bcs/dist/esm/b64.js
function fromBase64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes2) {
  if (bytes2.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes2));
  }
  let output2 = "";
  for (var i2 = 0; i2 < bytes2.length; i2 += CHUNK_SIZE) {
    const chunk2 = bytes2.slice(i2, i2 + CHUNK_SIZE);
    output2 += String.fromCharCode(...chunk2);
  }
  return btoa(output2);
}
var toB64 = toBase64;

// node_modules/@mysten/bcs/dist/esm/hex.js
function fromHex(hexStr) {
  var _a2;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
  const intArr = ((_a2 = padded.match(/.{2}/g)) == null ? void 0 : _a2.map((byte) => parseInt(byte, 16))) ?? [];
  return Uint8Array.from(intArr);
}
function toHex(bytes2) {
  return bytes2.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}

// node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value2 = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value2;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value2 = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value2;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value2 = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value2;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value2 = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value2;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value: value2, length } = ulebDecode(buffer);
    this.shift(length);
    return value2;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i2 = 0; i2 < length; i2++) {
      result.push(cb(this, i2, length));
    }
    return result;
  }
};

// node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str[i2];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes2) {
    const requiredSize = this.bytePosition + bytes2;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value2) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value2));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value2) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value2), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value2) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value2), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value2) {
    toLittleEndian(BigInt(value2), 8).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value2) {
    toLittleEndian(BigInt(value2), 16).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value2) {
    toLittleEndian(BigInt(value2), 32).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value2) {
    ulebEncode(value2).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el2, i2) => cb(this, el2, i2, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i2 = 0; i2 < this.bytePosition; i2++) {
      yield this.dataView.getUint8(i2);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  let result = new Uint8Array(size);
  let i2 = 0;
  while (bigint2 > 0) {
    result[i2] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i2 += 1;
  }
  return result;
}

// node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value2) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet3 = (obj, member, value2, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd3(this, _write);
    __privateAdd3(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet3(this, _write, options.write);
    __privateSet3(this, _serialize, options.serialize ?? ((value2, options2) => {
      const writer = new BcsWriter({
        initialSize: this.serializedSize(value2) ?? void 0,
        ...options2
      });
      __privateGet3(this, _write).call(this, value2, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value2, writer) {
    this.validate(value2);
    __privateGet3(this, _write).call(this, value2, writer);
  }
  serialize(value2, options) {
    this.validate(value2);
    return new SerializedBcs(this, __privateGet3(this, _serialize).call(this, value2, options));
  }
  parse(bytes2) {
    const reader = new BcsReader(bytes2);
    return this.read(reader);
  }
  fromHex(hex2) {
    return this.parse(fromHex(hex2));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name: name2,
    input,
    output: output2,
    validate: validate3
  }) {
    return new _BcsType2({
      name: name2 ?? this.name,
      read: (reader) => output2(this.read(reader)),
      write: (value2, writer) => __privateGet3(this, _write).call(this, input(value2), writer),
      serializedSize: (value2) => this.serializedSize(input(value2)),
      serialize: (value2, options) => __privateGet3(this, _serialize).call(this, input(value2), options),
      validate: (value2) => {
        validate3 == null ? void 0 : validate3(value2);
        this.validate(input(value2));
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(type2, schema) {
    __privateAdd3(this, _schema);
    __privateAdd3(this, _bytes);
    __privateSet3(this, _schema, type2);
    __privateSet3(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet3(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet3(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet3(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet3(this, _bytes));
  }
  parse() {
    return __privateGet3(this, _schema).parse(__privateGet3(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](value2),
    validate: (value2) => {
      var _a2;
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](BigInt(value2)),
    validate: (val) => {
      var _a2;
      const value2 = BigInt(val);
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type2 = new BcsType({
    ...options,
    serialize,
    write: (value2, writer) => {
      for (const byte of type2.serialize(value2).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type2;
}
function stringLikeBcsType({
  toBytes: toBytes2,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes2 = reader.readBytes(length);
      return fromBytes(bytes2);
    },
    write: (hex2, writer) => {
      const bytes2 = toBytes2(hex2);
      writer.writeULEB(bytes2.length);
      for (let i2 = 0; i2 < bytes2.length; i2++) {
        writer.write8(bytes2[i2]);
      }
    },
    serialize: (value2) => {
      const bytes2 = toBytes2(value2);
      const size = ulebEncode(bytes2.length);
      const result = new Uint8Array(size.length + bytes2.length);
      result.set(size, 0);
      result.set(bytes2, size.length);
      return result;
    },
    validate: (value2) => {
      var _a2;
      if (typeof value2 !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value2}. Expected string`);
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value2) => getType().serializedSize(value2),
    write: (value2, writer) => getType().write(value2, writer),
    serialize: (value2, options) => getType().serialize(value2, options).toBytes()
  });
}

// node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value2, writer) => writer.write8(value2 ? 1 : 0),
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value2) => {
        return Uint8Array.from(ulebEncode(value2));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value2, writer) => {
        for (let i2 = 0; i2 < size; i2++) {
          writer.write8(value2[i2] ?? 0);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      name: "string",
      toBytes: (value2) => new TextEncoder().encode(value2),
      fromBytes: (bytes2) => new TextDecoder().decode(bytes2),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type2, options) {
    return new BcsType({
      name: `${type2.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i2 = 0; i2 < size; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type2) {
    return bcs.enum(`Option<${type2.name}>`, {
      None: null,
      Some: type2
    }).transform({
      input: (value2) => {
        if (value2 == null) {
          return { None: true };
        }
        return { Some: value2 };
      },
      output: (value2) => {
        if (value2.$kind === "Some") {
          return value2.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type2, options) {
    return new BcsType({
      name: `vector<${type2.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i2 = 0; i2 < length; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        writer.writeULEB(value2.length);
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType({
      name: `(${types.map((t3) => t3.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i2 = 0; i2 < types.length; i2++) {
          const size = types[i2].serializedSize(values[i2]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type2 of types) {
          result.push(type2.read(reader));
        }
        return result;
      },
      write: (value2, writer) => {
        for (let i2 = 0; i2 < types.length; i2++) {
          types[i2].write(value2[i2], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!Array.isArray(value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name2, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType({
      name: name2,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type2] of canonicalOrder) {
          const size = type2.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type2] of canonicalOrder) {
          result[field] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const [field, type2] of canonicalOrder) {
          type2.write(value2[field], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name2, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType({
      name: name2,
      read: (reader) => {
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${name2}`);
        }
        const [kind, type2] = enumEntry;
        return {
          [kind]: (type2 == null ? void 0 : type2.read(reader)) ?? true,
          $kind: kind
        };
      },
      write: (value2, writer) => {
        const [name22, val] = Object.entries(value2).filter(
          ([name3]) => Object.hasOwn(values, name3)
        )[0];
        for (let i2 = 0; i2 < canonicalOrder.length; i2++) {
          const [optionName, optionType] = canonicalOrder[i2];
          if (optionName === name22) {
            writer.writeULEB(i2);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
        const keys = Object.keys(value2).filter(
          (k) => value2[k] !== void 0 && Object.hasOwn(values, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${name2}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(values, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value2) => {
        return [...value2.entries()];
      },
      output: (value2) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value2) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value2) {
  try {
    const buffer = fromBase58(value2);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e3) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value2) {
  return isHex(value2) && getHexByteLength(value2) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value2) {
  return isValidSuiAddress(value2);
}
function parseTypeTag(type2) {
  if (!type2.includes("::")) return type2;
  return parseStructTag(type2);
}
function parseStructTag(type2) {
  const [address, module] = type2.split("::");
  const rest = type2.slice(address.length + module.length + 4);
  const name2 = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: normalizeSuiAddress(address),
    module,
    name: name2,
    typeParams
  };
}
function normalizeStructTag(type2) {
  const { address, module, name: name2, typeParams } = typeof type2 === "string" ? parseStructTag(type2) : type2;
  const formattedTypeParams = (typeParams == null ? void 0 : typeParams.length) > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module}::${name2}${formattedTypeParams}`;
}
function normalizeSuiAddress(value2, forceAdd0x = false) {
  let address = value2.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value2, forceAdd0x = false) {
  return normalizeSuiAddress(value2, forceAdd0x);
}
function isHex(value2) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value2) && value2.length % 2 === 0;
}
function getHexByteLength(value2) {
  return /^(0x|0X)/.test(value2) ? (value2.length - 2) / 2 : value2.length / 2;
}

// node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type2) {
  return bcs.enum("Option", {
    None: null,
    Some: type2
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value2) => fromBase58(value2),
  output: (value2) => toBase58(new Uint8Array(value2)),
  validate: (value2) => {
    if (fromBase58(value2).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.vector(bcs.u8()).transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T2) {
  return bcs.struct(`IntentMessage<${T2.name}>`, {
    intent: Intent,
    value: T2
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.vector(bcs.u8()).transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});

// node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.vector(bcs.u8()) }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Command,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  TransactionEffects
};

// node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
function normalizeSuiNSName(name2, format = "at") {
  const lowerCase = name2.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// node_modules/@noble/hashes/esm/_assert.js
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`positive integer expected, not ${n2}`);
}
function isBytes(a3) {
  return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h.outputLen);
  number(h.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
var byteSwapIfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
}
var hexes = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  bytes(bytes2);
  let hex2 = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex2 += hexes[bytes2[i2]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi2));
    const n2 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n2;
  }
  return array2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    bytes(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    res.set(a3, pad);
    pad += a3.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_blake.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    number(blockLen);
    number(outputLen);
    number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`salt must be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`personalization must be ${persLen} byte long or undefined`);
    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    exists(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        if (!isLE)
          byteSwap32(buffer32);
        this.compress(buffer32, 0, false);
        if (!isLE)
          byteSwap32(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        if (!isLE)
          byteSwap32(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        if (!isLE)
          byteSwap32(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    if (!isLE)
      byteSwap32(buffer32);
    this.compress(buffer32, 0, true);
    if (!isLE)
      byteSwap32(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i2) => out32[i2] = byteSwapIfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to2 || (to2 = new this.constructor({ dkLen: outputLen }));
    to2.set(...this.get());
    to2.length = length;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.outputLen = outputLen;
    to2.buffer.set(buffer);
    to2.pos = pos;
    return to2;
  }
};

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h, l } = fromBig(lst[i2], le2);
    [Ah[i2], Al2[i2]] = [h, l];
  }
  return [Ah, Al2];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al2, Bh, Bl) {
  const l = (Al2 >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al2, Bl, Cl) => (Al2 >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al2, Bl, Cl, Dl2) => (Al2 >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl2 >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al2, Bl, Cl, Dl2, El2) => (Al2 >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/blake2b.js
var B2B_IV = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a3, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al2 = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl2 = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll2 = u64_default.add3L(Al2, Bl, Xl);
  Ah = u64_default.add3H(ll2, Ah, Bh, Xh);
  Al2 = ll2 | 0;
  ({ Dh, Dl: Dl2 } = { Dh: Dh ^ Ah, Dl: Dl2 ^ Al2 });
  ({ Dh, Dl: Dl2 } = { Dh: u64_default.rotr32H(Dh, Dl2), Dl: u64_default.rotr32L(Dh, Dl2) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl2));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BBUF[2 * a3] = Al2, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl2, BBUF[2 * d + 1] = Dh;
}
function G2b(a3, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al2 = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl2 = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll2 = u64_default.add3L(Al2, Bl, Xl);
  Ah = u64_default.add3H(ll2, Ah, Bh, Xh);
  Al2 = ll2 | 0;
  ({ Dh, Dl: Dl2 } = { Dh: Dh ^ Ah, Dl: Dl2 ^ Al2 });
  ({ Dh, Dl: Dl2 } = { Dh: u64_default.rotrSH(Dh, Dl2, 16), Dl: u64_default.rotrSL(Dh, Dl2, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl2));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BBUF[2 * a3] = Al2, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl2, BBUF[2 * d + 1] = Dh;
}
var BLAKE2b = class extends BLAKE {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u32(toBytes(opts.salt));
      this.v4l ^= byteSwapIfBE(salt[0]);
      this.v4h ^= byteSwapIfBE(salt[1]);
      this.v5l ^= byteSwapIfBE(salt[2]);
      this.v5h ^= byteSwapIfBE(salt[3]);
    }
    if (opts.personalization) {
      const pers = u32(toBytes(opts.personalization));
      this.v6l ^= byteSwapIfBE(pers[0]);
      this.v6h ^= byteSwapIfBE(pers[1]);
      this.v7l ^= byteSwapIfBE(pers[2]);
      this.v7h ^= byteSwapIfBE(pers[3]);
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i2) => BBUF[i2] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = u64_default.fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = SIGMA;
    for (let i2 = 0; i2 < 12; i2++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    BBUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.vector(suiBcs.U8).transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type2 = getPureBcsSchema(typeSignature.vector);
    return type2 ? suiBcs.vector(type2) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type2 = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type2 ? suiBcs.vector(type2) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type2) {
  if (typeof type2 === "object" && "Reference" in type2) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type2.Reference)
    };
  }
  if (typeof type2 === "object" && "MutableReference" in type2) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type2.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type2)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type2) {
  if (typeof type2 === "string") {
    switch (type2) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type2}`);
    }
  }
  if ("Vector" in type2) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type2.Vector) };
  }
  if ("Struct" in type2) {
    return {
      datatype: {
        package: type2.Struct.address,
        module: type2.Struct.module,
        type: type2.Struct.name,
        typeParameters: type2.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type2) {
    return { typeParameter: type2.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type2)}`);
}

// node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version: version2 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version: version2 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: (config2 == null ? void 0 : config2.lang) ?? (store == null ? void 0 : store.lang),
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (config2 == null ? void 0 : config2.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config2 == null ? void 0 : config2.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly)
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a2;
  return (_a2 = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a2.get(lang);
}
function _stringify(input) {
  var _a2, _b;
  const type2 = typeof input;
  if (type2 === "string") {
    return `"${input}"`;
  }
  if (type2 === "number" || type2 === "bigint" || type2 === "boolean") {
    return `${input}`;
  }
  if (type2 === "object" || type2 === "function") {
    return (input && ((_b = (_a2 = Object.getPrototypeOf(input)) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name)) ?? "null";
  }
  return type2;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (other == null ? void 0 : other.expected) ?? context.expects ?? null;
  const received = (other == null ? void 0 : other.received) ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema2 = context.kind === "schema";
  const message = (other == null ? void 0 : other.message) ?? // @ts-expect-error
  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema2 ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema2) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
}
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    _run(dataset, config2) {
      var _a2;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a2 = dataset.issues) == null ? void 0 : _a2.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    _run(dataset, config2) {
      return this.getter(dataset.value)._run(dataset, config2);
    }
  };
}
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message,
    _run(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullable(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `${wrapped.expects} | null`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function nullish(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${wrapped.expects} | null | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function number2(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number2,
    expects: "number",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      var _a2;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a2 = dataset.issues) == null ? void 0 : _a2.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key,
    value: value2,
    message,
    _run(dataset, config2) {
      var _a2, _b;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key._run(
              { typed: false, value: entryKey },
              config2
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                (_a2 = dataset.issues) == null ? void 0 : _a2.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: false, value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_b = dataset.issues) == null ? void 0 : _b.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message,
    _run(dataset, config2) {
      var _a2;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < this.items.length; key++) {
          const value2 = input[key];
          const itemDataset = this.items[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a2 = dataset.issues) == null ? void 0 : _a2.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
    async: false,
    options,
    message,
    _run(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema._run(
          { typed: false, value: dataset.value },
          config2
        );
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if ((untypedDatasets == null ? void 0 : untypedDatasets.length) === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index = 0; index < pipe2.length; index++) {
        if (dataset.issues && (pipe2[index].kind === "schema" || pipe2[index].kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
          dataset = pipe2[index]._run(dataset, config2);
        }
      }
      return dataset;
    }
  };
}

// node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key, value2]) => object({ [key]: value2 }));
  return pipe(
    union(unionOptions),
    transform((value2) => ({
      ...value2,
      $kind: Object.keys(value2)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value2) => normalizeSuiAddress(value2)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number2(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRef = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var Argument2 = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number2(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number2(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number2(), integer()) }),
    object({ NestedResult: tuple([pipe(number2(), integer()), pipe(number2(), integer())]) })
  ]),
  transform((value2) => ({
    ...value2,
    $kind: Object.keys(value2)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBody = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))
    })
  }),
  object({ typeParameter: pipe(number2(), integer()) })
]);
var OpenMoveTypeSignature = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBody
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = safeEnum({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent
});
var ObjectArg2 = safeEnum({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionData2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2)
});

// node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var Commands = {
  MoveCall(input) {
    const [pkg, mod2 = "", fn2 = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod2,
        function: fn2,
        typeArguments: input.typeArguments ?? [],
        arguments: input.arguments ?? []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o2) => parse(Argument2, o2)),
        address: parse(Argument2, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse(Argument2, coin),
        amounts: amounts.map((o2) => parse(Argument2, o2))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse(Argument2, destination),
        sources: sources.map((o2) => parse(Argument2, o2))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse(Argument2, ticket)
      }
    };
  },
  MakeMoveVec({
    type: type2,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type2 ?? null,
        elements: elements.map((o2) => parse(Argument2, o2))
      }
    };
  },
  Intent({
    name: name2,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name: name2,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key, value2]) => [
            key,
            Array.isArray(value2) ? value2.map((o2) => parse(Argument2, o2)) : parse(Argument2, value2)
          ])
        ),
        data
      }
    };
  }
};

// node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef2 = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number2(), integer()), string(), bigint()])
});
var ObjectArg3 = safeEnum({
  ImmOrOwned: ObjectRef2,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef2
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg3,
  Pure: array(pipe(number2(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number2(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number2(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number2(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number2(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val)) return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag3) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag3 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef2)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number2(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number2(), integer()),
    resultIndex: pipe(number2(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number2(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number2(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  var _a2;
  const inputs = transactionData.inputs.map(
    (input, index) => {
      if (input.Object) {
        return {
          kind: "Input",
          index,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: transactionData.sender ?? void 0,
    expiration: ((_a2 = transactionData.expiration) == null ? void 0 : _a2.$kind) === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: transactionData.gasData.owner ?? void 0,
      budget: transactionData.gasData.budget ?? void 0,
      price: transactionData.gasData.price ?? void 0,
      payment: transactionData.gasData.payment ?? void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  var _a2, _b, _c2;
  return parse(TransactionData2, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: ((_a2 = data.gasConfig.budget) == null ? void 0 : _a2.toString()) ?? null,
      price: ((_b = data.gasConfig.price) == null ? void 0 : _b.toString()) ?? null,
      payment: ((_c2 = data.gasConfig.payment) == null ? void 0 : _c2.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      }))) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value2 = parse(NormalizedCallArg2, input.value);
          if (value2.Object) {
            if (value2.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value2.Object.ImmOrOwned.objectId,
                    version: String(value2.Object.ImmOrOwned.version),
                    digest: value2.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value2.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value2.Object.Shared.mutable ?? null,
                    initialSharedVersion: value2.Object.Shared.initialSharedVersion,
                    objectId: value2.Object.Shared.objectId
                  }
                }
              };
            }
            if (value2.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value2.Object.Receiving.digest,
                    version: String(value2.Object.Receiving.version),
                    objectId: value2.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value2.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod2, fn2] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod2,
              function: fn2,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key, value2]) => object({ [key]: value2 }))
  );
}
var Argument3 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number2(), integer()),
  Result: pipe(number2(), integer()),
  NestedResult: tuple([pipe(number2(), integer()), pipe(number2(), integer())])
});
var GasData3 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var ProgrammableMoveCall3 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument3)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument3, array(Argument3)])),
  data: record(string(), unknown())
});
var Command3 = enumUnion({
  MoveCall: ProgrammableMoveCall3,
  TransferObjects: object({
    objects: array(Argument3),
    address: Argument3
  }),
  SplitCoins: object({
    coin: Argument3,
    amounts: array(Argument3)
  }),
  MergeCoins: object({
    destination: Argument3,
    sources: array(Argument3)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument3)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument3
  }),
  $Intent: $Intent2
});
var ObjectArg4 = enumUnion({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg3 = enumUnion({
  Object: ObjectArg4,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData3,
  inputs: array(CallArg3),
  commands: array(Command3)
});

// node_modules/@mysten/sui/dist/esm/transactions/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
async function resolveTransactionData(transactionData, options, next) {
  await normalizeInputs(transactionData, options);
  await resolveObjectReferences(transactionData, options);
  if (!options.onlyTransactionKind) {
    await setGasPrice(transactionData, options);
    await setGasBudget(transactionData, options);
    await setGasPayment(transactionData, options);
  }
  await validate(transactionData);
  return await next();
}
async function setGasPrice(transactionData, options) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, options) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await getClient(options).dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, options) {
  if (!transactionData.gasConfig.payment) {
    const coins = await getClient(options).getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        var _a2;
        if ((_a2 = input.Object) == null ? void 0 : _a2.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));
  }
}
async function resolveObjectReferences(transactionData, options) {
  const objectsToResolve = transactionData.inputs.filter((input) => {
    var _a2;
    return input.UnresolvedObject && !(input.UnresolvedObject.version || ((_a2 = input.UnresolvedObject) == null ? void 0 : _a2.initialSharedVersion));
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => getClient(options).multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id, index) => {
      return [id, resolved[index]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id, index) => {
      return [id, objects[index]];
    })
  );
  for (const [index, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id);
    if (input.UnresolvedObject.initialSharedVersion ?? (object2 == null ? void 0 : object2.initialSharedVersion)) {
      updated = Inputs.SharedObjectRef({
        objectId: id,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || (object2 == null ? void 0 : object2.initialSharedVersion),
        mutable: isUsedAsMutable(transactionData, index)
      });
    } else if (isUsedAsReceiving(transactionData, index)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id,
          digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
          version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
      objectId: id,
      digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
      version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
    });
  }
}
async function normalizeInputs(transactionData, options) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => (input == null ? void 0 : input.UnresolvedPure) || (input == null ? void 0 : input.UnresolvedObject)
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    const client = getClient(options);
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i2) => {
      var _a2, _b;
      const arg = moveCall.arguments[i2];
      if (arg.$kind !== "Input") return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = ((_a2 = input.UnresolvedPure) == null ? void 0 : _a2.value) ?? ((_b = input.UnresolvedObject) == null ? void 0 : _b.objectId);
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}
function isUsedAsMutable(transactionData, index) {
  let usedAsMutable = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type2) {
  if (typeof type2.body !== "object" || !("datatype" in type2.body)) {
    return false;
  }
  return type2.body.datatype.package === "0x2" && type2.body.datatype.module === "transfer" && type2.body.datatype.type === "Receiving";
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
function chunk(arr, size) {
  return Array.from(
    { length: Math.ceil(arr.length / size) },
    (_, i2) => arr.slice(i2 * size, i2 * size + size)
  );
}

// node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value2) {
    return makeObject(value2);
  }
  object2.system = () => object2("0x5");
  object2.clock = () => object2("0x6");
  object2.random = () => object2("0x8");
  object2.denyList = () => object2("0x403");
  return object2;
}

// node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value2) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(schemaFromName(typeOrSerializedValue).serialize(value2));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value2) => makePure(suiBcs.U8.serialize(value2));
  pure.u16 = (value2) => makePure(suiBcs.U16.serialize(value2));
  pure.u32 = (value2) => makePure(suiBcs.U32.serialize(value2));
  pure.u64 = (value2) => makePure(suiBcs.U64.serialize(value2));
  pure.u128 = (value2) => makePure(suiBcs.U128.serialize(value2));
  pure.u256 = (value2) => makePure(suiBcs.U256.serialize(value2));
  pure.bool = (value2) => makePure(suiBcs.Bool.serialize(value2));
  pure.string = (value2) => makePure(suiBcs.String.serialize(value2));
  pure.address = (value2) => makePure(suiBcs.Address.serialize(value2));
  pure.id = pure.address;
  pure.vector = (type2, value2) => {
    return makePure(suiBcs.vector(schemaFromName(type2)).serialize(value2));
  };
  pure.option = (type2, value2) => {
    return makePure(suiBcs.option(schemaFromName(type2)).serialize(value2));
  };
  return pure;
}
function schemaFromName(name2) {
  switch (name2) {
    case "u8":
      return suiBcs.u8();
    case "u16":
      return suiBcs.u16();
    case "u32":
      return suiBcs.u32();
    case "u64":
      return suiBcs.u64();
    case "u128":
      return suiBcs.u128();
    case "u256":
      return suiBcs.u256();
    case "bool":
      return suiBcs.bool();
    case "string":
      return suiBcs.string();
    case "id":
    case "address":
      return suiBcs.Address;
  }
  const generic = name2.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return suiBcs.vector(schemaFromName(inner));
    } else {
      return suiBcs.option(schemaFromName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name2}`);
}

// node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e3) => e3.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class _TransactionDataBuilder {
  constructor(clone) {
    this.version = 2;
    this.sender = (clone == null ? void 0 : clone.sender) ?? null;
    this.expiration = (clone == null ? void 0 : clone.expiration) ?? null;
    this.inputs = (clone == null ? void 0 : clone.inputs) ?? [];
    this.commands = (clone == null ? void 0 : clone.commands) ?? [];
    this.gasData = (clone == null ? void 0 : clone.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes2) {
    const kind = suiBcs.TransactionKind.parse(bytes2);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes2) {
    const rawData = suiBcs.TransactionData.parse(bytes2);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new _TransactionDataBuilder(parse(TransactionData2, data));
    } else {
      return new _TransactionDataBuilder(parse(TransactionData2, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes2) {
    const hash2 = hashTypedData("TransactionData", bytes2);
    return toBase58(hash2);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value2) {
    this.gasData = value2;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasData = { ...this.gasData, ...overrides == null ? void 0 : overrides.gasConfig, ...overrides == null ? void 0 : overrides.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type2, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type: type2, $kind: "Input" };
  }
  getInputUses(index, fn2) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn2(arg, command);
      }
      return arg;
    });
  }
  mapArguments(fn2) {
    for (const command of this.commands) {
      switch (command.$kind) {
        case "MoveCall":
          command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn2(arg, command));
          break;
        case "TransferObjects":
          command.TransferObjects.objects = command.TransferObjects.objects.map(
            (arg) => fn2(arg, command)
          );
          command.TransferObjects.address = fn2(command.TransferObjects.address, command);
          break;
        case "SplitCoins":
          command.SplitCoins.coin = fn2(command.SplitCoins.coin, command);
          command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn2(arg, command));
          break;
        case "MergeCoins":
          command.MergeCoins.destination = fn2(command.MergeCoins.destination, command);
          command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn2(arg, command));
          break;
        case "MakeMoveVec":
          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
            (arg) => fn2(arg, command)
          );
          break;
        case "Upgrade":
          command.Upgrade.ticket = fn2(command.Upgrade.ticket, command);
          break;
        case "$Intent":
          const inputs = command.$Intent.inputs;
          command.$Intent.inputs = {};
          for (const [key, value2] of Object.entries(inputs)) {
            command.$Intent.inputs[key] = Array.isArray(value2) ? value2.map((arg) => fn2(arg, command)) : fn2(value2, command);
          }
          break;
        case "Publish":
          break;
        default:
          throw new Error(`Unexpected transaction kind: ${command.$kind}`);
      }
    }
  }
  replaceCommand(index, replacement) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg) => {
        switch (arg.$kind) {
          case "Result":
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes2 = this.build({ onlyTransactionKind: false });
    return _TransactionDataBuilder.getDigestFromBytes(bytes2);
  }
  snapshot() {
    return parse(TransactionData2, this);
  }
};

// node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value2) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet4 = (obj, member, value2, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _data;
var _Transaction_instances;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
function createTransactionResult(index) {
  const baseResult = { $kind: "Result", Result: index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    $kind: "NestedResult",
    NestedResult: [index, resultIndex]
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i2 = 0;
          while (true) {
            yield nestedResultFor(i2);
            i2++;
          }
        };
      }
      if (typeof property === "symbol") return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0) return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch (e3) {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd4(this, _Transaction_instances);
    __privateAdd4(this, _serializationPlugins);
    __privateAdd4(this, _buildPlugins);
    __privateAdd4(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd4(this, _data);
    this.object = createObjectMethods(
      (value2) => {
        var _a2, _b;
        if (typeof value2 === "function") {
          return this.object(value2(this));
        }
        if (typeof value2 === "object" && is(Argument2, value2)) {
          return value2;
        }
        const id = getIdFromCallArg(value2);
        const inserted = __privateGet4(this, _data).inputs.find((i2) => id === getIdFromCallArg(i2));
        if (((_a2 = inserted == null ? void 0 : inserted.Object) == null ? void 0 : _a2.SharedObject) && typeof value2 === "object" && ((_b = value2.Object) == null ? void 0 : _b.SharedObject)) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value2.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet4(this, _data).inputs.indexOf(inserted), type: "object" } : __privateGet4(this, _data).addInput(
          "object",
          typeof value2 === "string" ? {
            $kind: "UnresolvedObject",
            UnresolvedObject: { objectId: normalizeSuiAddress(value2) }
          } : value2
        );
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet4(this, _data, new TransactionDataBuilder());
    __privateSet4(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet4(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _Transaction2();
    __privateSet4(tx, _data, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet4(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet4(newTransaction, _data, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet4(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name2) {
    getGlobalPluginRegistry().serializationPlugins.delete(name2);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name2) {
    getGlobalPluginRegistry().buildPlugins.delete(name2);
  }
  addSerializationPlugin(step) {
    __privateGet4(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet4(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet4(this, _intentResolvers).has(intent) && __privateGet4(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet4(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet4(this, _data).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet4(this, _data).sender) {
      __privateGet4(this, _data).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet4(this, _data).expiration = expiration ? parse(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet4(this, _data).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet4(this, _data).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet4(this, _data).gasData.budget == null) {
      __privateGet4(this, _data).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet4(this, _data).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet4(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet4(this, _data).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet4(this, _data).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value2) => {
        if (isSerializedBcs(value2)) {
          return __privateGet4(this, _data).addInput("pure", {
            $kind: "Pure",
            Pure: {
              bytes: value2.toBase64()
            }
          });
        }
        return __privateGet4(this, _data).addInput(
          "pure",
          is(NormalizedCallArg, value2) ? parse(NormalizedCallArg, value2) : value2 instanceof Uint8Array ? Inputs.Pure(value2) : { $kind: "UnresolvedPure", UnresolvedPure: { value: value2 } }
        );
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction */
  add(command) {
    if (typeof command === "function") {
      return command(this);
    }
    const index = __privateGet4(this, _data).commands.push(command);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    return this.add(
      Commands.SplitCoins(
        typeof coin === "string" ? this.object(coin) : __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
        amounts.map(
          (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
        )
      )
    );
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall({
    arguments: args,
    ...input
  }) {
    return this.add(
      Commands.MoveCall({
        ...input,
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type: type2,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type: type2,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet4(this, _data).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    return JSON.stringify(
      parse(SerializedTransactionDataV2, __privateGet4(this, _data).snapshot()),
      (_key, value2) => typeof value2 === "bigint" ? value2.toString() : value2,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes2 = await this.build(buildOptions);
    return signer.signTransaction(bytes2);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet4(this, _data).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet4(this, _data).getDigest();
  }
  async prepareForSerialization(options) {
    var _a2;
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet4(this, _data).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet4(this, _serializationPlugins)];
    for (const intent of intents) {
      if ((_a2 = options.supportedIntents) == null ? void 0 : _a2.includes(intent)) {
        continue;
      }
      if (!__privateGet4(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet4(this, _intentResolvers).get(intent));
    }
    await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    return parse(Argument2, arg(this));
  }
  return parse(Argument2, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet4(this, _data).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet4(this, _buildPlugins), resolveTransactionData], options);
};
runPlugins_fn = async function(plugins, options) {
  const createNext = (i2) => {
    if (i2 >= plugins.length) {
      return () => {
      };
    }
    const plugin = plugins[i2];
    return async () => {
      const next = createNext(i2 + 1);
      let calledNext = false;
      let nextResolved = false;
      await plugin(__privateGet4(this, _data), options, async () => {
        if (calledNext) {
          throw new Error(`next() was call multiple times in TransactionPlugin ${i2}`);
        }
        calledNext = true;
        await next();
        nextResolved = true;
      });
      if (!calledNext) {
        throw new Error(`next() was not called in TransactionPlugin ${i2}`);
      }
      if (!nextResolved) {
        throw new Error(`next() was not awaited in TransactionPlugin ${i2}`);
      }
    };
  };
  await createNext(0)();
};
var Transaction = _Transaction;

// node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var _caches;
var _cache;
_caches = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var _client;
var _lastDigest;
_client = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var _queue;
var _queue2;
_queue = /* @__PURE__ */ new WeakMap();
_queue2 = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var _queue3;
var _signer;
var _cache2;
var _defaultGasBudget;
var _cacheGasCoin;
var _buildTransaction;
_queue3 = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_cache2 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
  if (!effects.V2) {
    throw new Error("Unexpected effects version");
  }
  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
  if (!gasObjectChange) {
    throw new Error("Gas object not found in effects");
  }
  const [objectId, { outputState }] = gasObjectChange;
  if (!outputState.ObjectWrite) {
    throw new Error("Unexpected gas object state");
  }
  const [digest, owner] = outputState.ObjectWrite;
  return {
    ref: {
      objectId,
      digest,
      version: effects.V2.lamportVersion
    },
    owner: owner.AddressOwner || owner.ObjectOwner
  };
}

// node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet5 = (obj, member, value2, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod4 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var __privateWrapper2 = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet5(obj, member, value2, setter);
  },
  get _() {
    return __privateGet5(obj, member, getter);
  }
});
var _signer2;
var _client2;
var _coinBatchSize;
var _initialCoinBalance;
var _minimumCoinBalance;
var _epochBoundaryWindow;
var _defaultGasBudget2;
var _maxPoolSize;
var _sourceCoins;
var _coinPool;
var _cache3;
var _objectIdQueues;
var _buildQueue;
var _executeQueue;
var _lastDigest2;
var _cacheLock;
var _pendingTransactions;
var _gasPrice;
var _ParallelTransactionExecutor_instances;
var getUsedObjects_fn;
var execute_fn;
var updateCache_fn;
var waitForLastDigest_fn;
var getGasCoin_fn;
var getGasPrice_fn;
var refillCoinPool_fn;
_signer2 = /* @__PURE__ */ new WeakMap();
_client2 = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget2 = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest2 = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options2, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      var _a2, _b, _c2, _d, _e;
      if ((_b = (_a2 = input.Object) == null ? void 0 : _a2.ImmOrOwnedObject) == null ? void 0 : _b.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if ((_d = (_c2 = input.Object) == null ? void 0 : _c2.Receiving) == null ? void 0 : _d.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (((_e = input.UnresolvedObject) == null ? void 0 : _e.objectId) && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet5(this, _client2) });
  return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options) {
  var _a2;
  let gasCoin;
  try {
    transaction.setSenderIfNotSet(__privateGet5(this, _signer2).toSuiAddress());
    await __privateGet5(this, _buildQueue).runTask(async () => {
      const data = transaction.getData();
      if (!data.gasData.price) {
        transaction.setGasPrice(await __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
      }
      transaction.setGasBudgetIfNotSet(__privateGet5(this, _defaultGasBudget2));
      await __privateMethod4(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
      gasCoin = await __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
      __privateWrapper2(this, _pendingTransactions)._++;
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      await __privateGet5(this, _cache3).buildTransaction({ transaction, onlyTransactionKind: true });
    });
    const bytes2 = await transaction.build({ client: __privateGet5(this, _client2) });
    const { signature } = await __privateGet5(this, _signer2).signTransaction(bytes2);
    const results = await __privateGet5(this, _cache3).executeTransaction({
      transaction: bytes2,
      signature,
      options: {
        ...options,
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = suiBcs.TransactionEffects.parse(effectsBytes);
    const gasResult = getGasCoinFromEffects(effects);
    const gasUsed = (_a2 = effects.V2) == null ? void 0 : _a2.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet5(this, _signer2).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      let usesGasCoin = false;
      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
        if (arg.$kind === "GasCoin") {
          usesGasCoin = true;
        }
        return arg;
      });
      if (!usesGasCoin && gasCoin.balance >= __privateGet5(this, _minimumCoinBalance)) {
        __privateGet5(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: gasCoin.balance - totalUsed
        });
      } else {
        if (!__privateGet5(this, _sourceCoins)) {
          __privateSet5(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet5(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    __privateSet5(this, _lastDigest2, results.digest);
    return {
      digest: results.digest,
      effects: toBase64(effectsBytes),
      data: results
    };
  } catch (error2) {
    if (gasCoin) {
      if (!__privateGet5(this, _sourceCoins)) {
        __privateSet5(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet5(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateMethod4(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
      await Promise.all([
        __privateGet5(this, _cache3).cache.deleteObjects([...usedObjects]),
        __privateMethod4(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)
      ]);
    });
    throw error2;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet5(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet5(this, _objectIdQueues).delete(objectId);
      }
    });
    __privateWrapper2(this, _pendingTransactions)._--;
  }
};
updateCache_fn = async function(fn2) {
  if (__privateGet5(this, _cacheLock)) {
    await __privateGet5(this, _cacheLock);
  }
  __privateSet5(this, _cacheLock, (fn2 == null ? void 0 : fn2().then(
    () => {
      __privateSet5(this, _cacheLock, null);
    },
    () => {
    }
  )) ?? null);
};
waitForLastDigest_fn = async function() {
  const digest = __privateGet5(this, _lastDigest2);
  if (digest) {
    __privateSet5(this, _lastDigest2, null);
    await __privateGet5(this, _client2).waitForTransaction({ digest });
  }
};
getGasCoin_fn = async function() {
  if (__privateGet5(this, _coinPool).length === 0 && __privateGet5(this, _pendingTransactions) <= __privateGet5(this, _maxPoolSize)) {
    await __privateMethod4(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
  }
  if (__privateGet5(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet5(this, _coinPool).shift();
  return coin;
};
getGasPrice_fn = async function() {
  const remaining = __privateGet5(this, _gasPrice) ? __privateGet5(this, _gasPrice).expiration - __privateGet5(this, _epochBoundaryWindow) - Date.now() : 0;
  if (remaining > 0) {
    return __privateGet5(this, _gasPrice).price;
  }
  if (__privateGet5(this, _gasPrice)) {
    const timeToNextEpoch = Math.max(
      __privateGet5(this, _gasPrice).expiration + __privateGet5(this, _epochBoundaryWindow) - Date.now(),
      1e3
    );
    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
  }
  const state = await __privateGet5(this, _client2).getLatestSuiSystemState();
  __privateSet5(this, _gasPrice, {
    price: BigInt(state.referenceGasPrice),
    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
  });
  return __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
  var _a2;
  const batchSize = Math.min(
    __privateGet5(this, _coinBatchSize),
    __privateGet5(this, _maxPoolSize) - (__privateGet5(this, _coinPool).length + __privateGet5(this, _pendingTransactions)) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new Transaction();
  const address = __privateGet5(this, _signer2).toSuiAddress();
  txb.setSender(address);
  if (__privateGet5(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id, ref] of __privateGet5(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet5(this, _client2).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet5(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet5(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i2 = 0; i2 < amounts.length; i2++) {
    coinResults.push(results[i2]);
  }
  txb.transferObjects(coinResults, address);
  await this.waitForLastTransaction();
  const result = await __privateGet5(this, _client2).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet5(this, _signer2),
    options: {
      showRawEffects: true
    }
  });
  const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  (_a2 = effects.V2) == null ? void 0 : _a2.changedObjects.forEach(([id, { outputState }], i2) => {
    var _a3;
    if (i2 === ((_a3 = effects.V2) == null ? void 0 : _a3.gasObjectIndex) || !outputState.ObjectWrite) {
      return;
    }
    __privateGet5(this, _coinPool).push({
      id,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet5(this, _initialCoinBalance))
    });
  });
  if (!__privateGet5(this, _sourceCoins)) {
    __privateSet5(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = getGasCoinFromEffects(effects).ref;
  __privateGet5(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet5(this, _client2).waitForTransaction({ digest: result.digest });
};

// node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});

// node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
  pure: createPure((value2) => (tx) => tx.pure(value2)),
  object: createObjectMethods(
    (value2) => (tx) => tx.object(value2)
  ),
  sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),
  objectRef: (...args) => (tx) => tx.objectRef(...args),
  receivingRef: (...args) => (tx) => tx.receivingRef(...args)
};

// node_modules/@mysten/sui/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class {
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit]
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getAllBalances", params: [input.owner] });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType]
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType]
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params) {
    return await this.transport.request({ method, params });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package]
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module]
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct]
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ]
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options]
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options]
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options]
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options]
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d) => {
      if (!isValidTransactionDigest(d)) {
        throw new Error(`Invalid Transaction digest ${d}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options]
    });
  }
  async executeTransactionBlock({
    transactionBlock,
    signature,
    options,
    requestType
  }) {
    const result = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
        Array.isArray(signature) ? signature : [signature],
        options
      ]
    });
    if (requestType === "WaitForLocalExecution") {
      try {
        await this.waitForTransaction({
          digest: result.digest
        });
      } catch (_) {
      }
    }
    return result;
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transaction instanceof Uint8Array) {
      transactionBytes = transaction;
    } else {
      transaction.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transaction.build({ client: this });
    }
    const { signature, bytes: bytes2 } = await signer.signTransaction(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes2,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getStakes", params: [input.owner] });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds]
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: "suix_getLatestSuiSystemState", params: [] });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a2;
    let devInspectTxBytes;
    if (isTransaction(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toBase64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toBase64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_a2 = input.gasPrice) == null ? void 0 : _a2.toString(), input.epoch]
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit]
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name]
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: []
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({ method: "sui_getCheckpoint", params: [input.id] });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch]
    });
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: "suix_getNetworkMetrics", params: [] });
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: "suix_getLatestAddressMetrics", params: [] });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics() {
    return await this.transport.request({ method: "suix_getMoveCallMetrics", params: [] });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.transport.request({ method: "suix_getCurrentEpoch", params: [] });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy() {
    return await this.transport.request({ method: "suix_getValidatorsApy", params: [] });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier() {
    const checkpoint = await this.getCheckpoint({ id: "0" });
    const bytes2 = fromBase58(checkpoint.digest);
    return toHex(bytes2.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name]
    });
  }
  async resolveNameServiceNames({
    format = "dot",
    ...input
  }) {
    const { nextCursor, hasNextPage, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit]
    });
    return {
      hasNextPage,
      nextCursor,
      data: data.map((name2) => normalizeSuiNSName(name2, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version]
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e3) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
};

// node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.fixedArray(message.length, suiBcs.u8())).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a3, b) {
  if (a3 === b) return true;
  if (a3.length !== b.length) {
    return false;
  }
  for (let i2 = 0; i2 < a3.length; i2++) {
    if (a3[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes2 = this.toSuiBytes();
    return toBase64(bytes2);
  }
  verifyWithIntent(bytes2, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes2);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};

// node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin"
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 10,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output2 = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output2 += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output2 += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output2;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array2) {
  return array2 === void 0 || array2.length === 0 ? void 0 : array2;
}

// node_modules/graphql/language/ast.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array2[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn2(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a3.length < b.length) {
      const tmp = a3;
      a3 = b;
      b = tmp;
    }
    const aLength = a3.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i2 = 1; i2 <= aLength; i2++) {
      const upRow = rows[(i2 - 1) % 3];
      const currentRow = rows[i2 % 3];
      let smallestCell = currentRow[0] = i2;
      for (let j = 1; j <= bLength; j++) {
        const cost = a3[i2 - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i2 > 1 && j > 1 && a3[i2 - 1] === b[j - 2] && a3[i2 - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i2 - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array2 = new Array(strLength);
  for (let i2 = 0; i2 < strLength; ++i2) {
    array2[i2] = str.charCodeAt(i2);
  }
  return array2;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map[key] = value2;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions: variableDefinitions2, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions2, ", "), ")")} on ${typeCondition} ${wrap("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join(["scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types }) => wrap("", description, "\n") + join(
      ["union", name2, join(directives2, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values }) => wrap("", description, "\n") + join(["enum", name2, join(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join([name2, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join(["extend scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types }) => join(
      [
        "extend union",
        name2,
        join(directives2, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values }) => join(["extend enum", name2, join(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join(["extend input", name2, join(directives2, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap("{\n", indent(join(array2, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i2 = 1; i2 < name2.length; ++i2) {
    if (!isNameContinue(name2.charCodeAt(i2))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}

// node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name2) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value2) => value2.name);
    }
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item of value2) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type2) => {
        if (isInputObjectType(type2)) {
          return type2.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name2 = node.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i2 = 0; i2 < fragmentNames.length; i2++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i2]
      );
      for (let j = i2 + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i2],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i2 = 0; i2 < fields.length; i2++) {
        for (let j = i2 + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i2],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name: name2, value: value2 }) => [name2.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var OrderedPairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a3)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a3, b, weaklyPresent) {
    const map = this._data.get(a3);
    if (map === void 0) {
      this._data.set(a3, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
    } else {
      map.set(b, weaklyPresent);
    }
  }
};
var PairSet = class {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a3, b, weaklyPresent) {
    return a3 < b ? this._orderedPairSet.has(a3, b, weaklyPresent) : this._orderedPairSet.has(b, a3, weaklyPresent);
  }
  add(a3, b, weaklyPresent) {
    if (a3 < b) {
      this._orderedPairSet.add(a3, b, weaklyPresent);
    } else {
      this._orderedPairSet.add(b, a3, weaklyPresent);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type2 = context.getType();
      const selectionSet2 = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        } else if (selectionSet2.selections.length === 0) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type2.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions2 = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions2,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions2 = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions2 = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions2[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type2.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type2,
          fieldNodeMap,
          variableDefinitions2
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error2) {
    const typeStr = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error2.message,
          {
            nodes: node,
            originalError: error2
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type2, fieldNodeMap, variableDefinitions2) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type2.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value2 = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value2 || value2.kind === Kind.NULL;
  const isVariable = (value2 === null || value2 === void 0 ? void 0 : value2.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value2.name.value;
    const definition = variableDefinitions2[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type2, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a22);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value2) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet6 = (obj, member, value2, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _url;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {}
  }) {
    __privateAdd5(this, _url);
    __privateAdd5(this, _queries);
    __privateAdd5(this, _headers);
    __privateAdd5(this, _fetch);
    __privateSet6(this, _url, url);
    __privateSet6(this, _queries, queries);
    __privateSet6(this, _headers, headers);
    __privateSet6(this, _fetch, (...args) => fetchFn(...args));
  }
  async query(options) {
    const res = await __privateGet6(this, _fetch).call(this, __privateGet6(this, _url), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet6(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      })
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet6(this, _queries)[query]
    });
  }
};
_url = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e3, r, i2, n2, t3, a3, o2) {
    if (super(e3), this.name = "GraphQLError", this.message = e3, t3) {
      this.path = t3;
    }
    if (r) {
      this.nodes = Array.isArray(r) ? r : [r];
    }
    if (i2) {
      this.source = i2;
    }
    if (n2) {
      this.positions = n2;
    }
    if (a3) {
      this.originalError = a3;
    }
    var l = o2;
    if (!l && a3) {
      var d = a3.extensions;
      if (d && "object" == typeof d) {
        l = d;
      }
    }
    this.extensions = l || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i;
var n;
function error(e3) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n} in ${e3}`);
}
function advance(e3) {
  if (e3.lastIndex = n, e3.test(i)) {
    return i.slice(n, n = e3.lastIndex);
  }
}
var t = / +(?=[^\s])/y;
function blockString(e3) {
  var r = e3.split("\n");
  var i2 = "";
  var n2 = 0;
  var a3 = 0;
  var o2 = r.length - 1;
  for (var l = 0; l < r.length; l++) {
    if (t.lastIndex = 0, t.test(r[l])) {
      if (l && (!n2 || t.lastIndex < n2)) {
        n2 = t.lastIndex;
      }
      a3 = a3 || l, o2 = l;
    }
  }
  for (var d = a3; d <= o2; d++) {
    if (d !== a3) {
      i2 += "\n";
    }
    i2 += r[d].slice(n2).replace(/\\"""/g, '"""');
  }
  return i2;
}
function ignored() {
  for (var e3 = 0 | i.charCodeAt(n++); 9 === e3 || 10 === e3 || 13 === e3 || 32 === e3 || 35 === e3 || 44 === e3 || 65279 === e3; e3 = 0 | i.charCodeAt(n++)) {
    if (35 === e3) {
      for (; 10 !== (e3 = i.charCodeAt(n++)) && 13 !== e3; ) {
      }
    }
  }
  n--;
}
function name() {
  var e3 = n;
  for (var r = 0 | i.charCodeAt(n++); r >= 48 && r <= 57 || r >= 65 && r <= 90 || 95 === r || r >= 97 && r <= 122; r = 0 | i.charCodeAt(n++)) {
  }
  if (e3 === n - 1) {
    throw error("Name");
  }
  var t3 = i.slice(e3, --n);
  return ignored(), t3;
}
function nameNode() {
  return {
    kind: "Name",
    value: name()
  };
}
var a = /(?:"""|(?:[\s\S]*?[^\\])""")/y;
var o = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
function value(e3) {
  var r;
  switch (i.charCodeAt(n)) {
    case 91:
      n++, ignored();
      var t3 = [];
      for (; 93 !== i.charCodeAt(n); ) {
        t3.push(value(e3));
      }
      return n++, ignored(), {
        kind: "ListValue",
        values: t3
      };
    case 123:
      n++, ignored();
      var l = [];
      for (; 125 !== i.charCodeAt(n); ) {
        var d = nameNode();
        if (58 !== i.charCodeAt(n++)) {
          throw error("ObjectField");
        }
        ignored(), l.push({
          kind: "ObjectField",
          name: d,
          value: value(e3)
        });
      }
      return n++, ignored(), {
        kind: "ObjectValue",
        fields: l
      };
    case 36:
      if (e3) {
        throw error("Variable");
      }
      return n++, {
        kind: "Variable",
        name: nameNode()
      };
    case 34:
      if (34 === i.charCodeAt(n + 1) && 34 === i.charCodeAt(n + 2)) {
        if (n += 3, null == (r = advance(a))) {
          throw error("StringValue");
        }
        return ignored(), {
          kind: "StringValue",
          value: blockString(r.slice(0, -3)),
          block: true
        };
      } else {
        var u = n;
        var s;
        n++;
        var c = false;
        for (s = 0 | i.charCodeAt(n++); 92 === s && (n++, c = true) || 10 !== s && 13 !== s && 34 !== s && s; s = 0 | i.charCodeAt(n++)) {
        }
        if (34 !== s) {
          throw error("StringValue");
        }
        return r = i.slice(u, n), ignored(), {
          kind: "StringValue",
          value: c ? JSON.parse(r) : r.slice(1, -1),
          block: false
        };
      }
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      var v = n++;
      var f;
      for (; (f = 0 | i.charCodeAt(n++)) >= 48 && f <= 57; ) {
      }
      var m = i.slice(v, --n);
      if (46 === (f = i.charCodeAt(n)) || 69 === f || 101 === f) {
        if (null == (r = advance(o))) {
          throw error("FloatValue");
        }
        return ignored(), {
          kind: "FloatValue",
          value: m + r
        };
      } else {
        return ignored(), {
          kind: "IntValue",
          value: m
        };
      }
    case 110:
      if (117 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 108 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "NullValue"
        };
      } else {
        break;
      }
    case 116:
      if (114 === i.charCodeAt(n + 1) && 117 === i.charCodeAt(n + 2) && 101 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "BooleanValue",
          value: true
        };
      } else {
        break;
      }
    case 102:
      if (97 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 115 === i.charCodeAt(n + 3) && 101 === i.charCodeAt(n + 4)) {
        return n += 5, ignored(), {
          kind: "BooleanValue",
          value: false
        };
      } else {
        break;
      }
  }
  return {
    kind: "EnumValue",
    value: name()
  };
}
function arguments_(e3) {
  if (40 === i.charCodeAt(n)) {
    var r = [];
    n++, ignored();
    do {
      var t3 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("Argument");
      }
      ignored(), r.push({
        kind: "Argument",
        name: t3,
        value: value(e3)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), r;
  }
}
function directives(e3) {
  if (64 === i.charCodeAt(n)) {
    var r = [];
    do {
      n++, r.push({
        kind: "Directive",
        name: nameNode(),
        arguments: arguments_(e3)
      });
    } while (64 === i.charCodeAt(n));
    return r;
  }
}
function type() {
  var e3 = 0;
  for (; 91 === i.charCodeAt(n); ) {
    e3++, n++, ignored();
  }
  var r = {
    kind: "NamedType",
    name: nameNode()
  };
  do {
    if (33 === i.charCodeAt(n)) {
      n++, ignored(), r = {
        kind: "NonNullType",
        type: r
      };
    }
    if (e3) {
      if (93 !== i.charCodeAt(n++)) {
        throw error("NamedType");
      }
      ignored(), r = {
        kind: "ListType",
        type: r
      };
    }
  } while (e3--);
  return r;
}
function selectionSetStart() {
  if (123 !== i.charCodeAt(n++)) {
    throw error("SelectionSet");
  }
  return ignored(), selectionSet();
}
function selectionSet() {
  var e3 = [];
  do {
    if (46 === i.charCodeAt(n)) {
      if (46 !== i.charCodeAt(++n) || 46 !== i.charCodeAt(++n)) {
        throw error("SelectionSet");
      }
      switch (n++, ignored(), i.charCodeAt(n)) {
        case 64:
          e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        case 111:
          if (110 === i.charCodeAt(n + 1)) {
            n += 2, ignored(), e3.push({
              kind: "InlineFragment",
              typeCondition: {
                kind: "NamedType",
                name: nameNode()
              },
              directives: directives(false),
              selectionSet: selectionSetStart()
            });
          } else {
            e3.push({
              kind: "FragmentSpread",
              name: nameNode(),
              directives: directives(false)
            });
          }
          break;
        case 123:
          n++, ignored(), e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: void 0,
            selectionSet: selectionSet()
          });
          break;
        default:
          e3.push({
            kind: "FragmentSpread",
            name: nameNode(),
            directives: directives(false)
          });
      }
    } else {
      var r = nameNode();
      var t3 = void 0;
      if (58 === i.charCodeAt(n)) {
        n++, ignored(), t3 = r, r = nameNode();
      }
      var a3 = arguments_(false);
      var o2 = directives(false);
      var l = void 0;
      if (123 === i.charCodeAt(n)) {
        n++, ignored(), l = selectionSet();
      }
      e3.push({
        kind: "Field",
        alias: t3,
        name: r,
        arguments: a3,
        directives: o2,
        selectionSet: l
      });
    }
  } while (125 !== i.charCodeAt(n));
  return n++, ignored(), {
    kind: "SelectionSet",
    selections: e3
  };
}
function variableDefinitions() {
  if (ignored(), 40 === i.charCodeAt(n)) {
    var e3 = [];
    n++, ignored();
    do {
      if (36 !== i.charCodeAt(n++)) {
        throw error("Variable");
      }
      var r = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("VariableDefinition");
      }
      ignored();
      var t3 = type();
      var a3 = void 0;
      if (61 === i.charCodeAt(n)) {
        n++, ignored(), a3 = value(true);
      }
      ignored(), e3.push({
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: r
        },
        type: t3,
        defaultValue: a3,
        directives: directives(true)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), e3;
  }
}
function fragmentDefinition() {
  var e3 = nameNode();
  if (111 !== i.charCodeAt(n++) || 110 !== i.charCodeAt(n++)) {
    throw error("FragmentDefinition");
  }
  return ignored(), {
    kind: "FragmentDefinition",
    name: e3,
    typeCondition: {
      kind: "NamedType",
      name: nameNode()
    },
    directives: directives(false),
    selectionSet: selectionSetStart()
  };
}
function definitions() {
  var e3 = [];
  do {
    if (123 === i.charCodeAt(n)) {
      n++, ignored(), e3.push({
        kind: "OperationDefinition",
        operation: "query",
        name: void 0,
        variableDefinitions: void 0,
        directives: void 0,
        selectionSet: selectionSet()
      });
    } else {
      var r = name();
      switch (r) {
        case "fragment":
          e3.push(fragmentDefinition());
          break;
        case "query":
        case "mutation":
        case "subscription":
          var t3;
          var a3 = void 0;
          if (40 !== (t3 = i.charCodeAt(n)) && 64 !== t3 && 123 !== t3) {
            a3 = nameNode();
          }
          e3.push({
            kind: "OperationDefinition",
            operation: r,
            name: a3,
            variableDefinitions: variableDefinitions(),
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        default:
          throw error("Document");
      }
    }
  } while (n < i.length);
  return e3;
}
function parse3(e3, r) {
  if (i = e3.body ? e3.body : e3, n = 0, ignored(), r && r.noLocation) {
    return {
      kind: "Document",
      definitions: definitions()
    };
  } else {
    return {
      kind: "Document",
      definitions: definitions(),
      loc: {
        start: 0,
        end: i.length,
        startToken: void 0,
        endToken: void 0,
        source: {
          body: i,
          name: "graphql.web",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      }
    };
  }
}

// node_modules/gql.tada/dist/gql-tada.mjs
var a2 = 0;
var e2 = /* @__PURE__ */ new Set();
function initGraphQLTada() {
  function graphql3(t3, i2) {
    var o2 = parse3(t3).definitions;
    var s = /* @__PURE__ */ new Set();
    for (var f of i2 || []) {
      for (var u of f.definitions) {
        if (u.kind === e.FRAGMENT_DEFINITION && !s.has(u)) {
          o2.push(u);
          s.add(u);
        }
      }
    }
    var d;
    if ((d = o2[0].kind === e.FRAGMENT_DEFINITION) && o2[0].directives) {
      o2[0].directives = o2[0].directives.filter((r) => "_unmask" !== r.name.value);
    }
    var c;
    return {
      kind: e.DOCUMENT,
      definitions: o2,
      get loc() {
        if (!c && d) {
          var r = t3 + function concatLocSources(r2) {
            try {
              a2++;
              var n2 = "";
              for (var t4 of r2) {
                if (!e2.has(t4)) {
                  e2.add(t4);
                  var { loc: i3 } = t4;
                  if (i3) {
                    n2 += i3.source.body;
                  }
                }
              }
              return n2;
            } finally {
              if (0 == --a2) {
                e2.clear();
              }
            }
          }(i2 || []);
          return {
            start: 0,
            end: r.length,
            source: {
              body: r,
              name: "GraphQLTada",
              locationOffset: {
                line: 1,
                column: 1
              }
            }
          };
        }
        return c;
      },
      set loc(r) {
        c = r;
      }
    };
  }
  graphql3.scalar = function scalar(r, n2) {
    return n2;
  };
  graphql3.persisted = function persisted(n2, a3) {
    return {
      kind: e.DOCUMENT,
      definitions: a3 ? a3.definitions : [],
      documentId: n2
    };
  };
  return graphql3;
}
var t2 = initGraphQLTada();

// node_modules/@mysten/sui/dist/esm/graphql/schemas/2024.4/index.js
var graphql2 = initGraphQLTada();

// node_modules/@mysten/sui/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i2 = 0; i2 < base64UrlString.length; i2++) {
    const base64UrlChar = base64UrlString.charAt(i2);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i2) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i2 % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i2}))`);
  }
  const lastCharOffset = (i2 + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i2}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes2 = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i22 = 0; i22 < bits.length; i22 += 8) {
    const bitChunk = bits.slice(i22, i22 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes2[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes2);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name2, value2] = verifyExtendedClaim(extendedClaim);
  if (name2 !== claimName) {
    throw new Error(`Invalid field name: found ${name2} expected ${claimName}`);
  }
  return value2;
}

// node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.vector(bcs.u8())
});

// node_modules/@mysten/sui/dist/esm/zklogin/signature.js
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromBase64(signature) : signature);
}

// node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function toPaddedBigEndianBytes(num, width) {
  const hex2 = num.toString(16);
  return hexToBytes(hex2.padStart(width * 2, "0").slice(-width * 2));
}

// node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value2) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet7 = (obj, member, value2, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _data2;
var _client3;
var _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier2 extends PublicKey2 {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value2, { client } = {}) {
    super();
    __privateAdd6(this, _data2);
    __privateAdd6(this, _client3);
    __privateSet7(this, _client3, client);
    if (typeof value2 === "string") {
      __privateSet7(this, _data2, fromBase64(value2));
    } else if (value2 instanceof Uint8Array) {
      __privateSet7(this, _data2, value2);
    } else {
      __privateSet7(this, _data2, Uint8Array.from(value2));
    }
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet7(this, _data2);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PERSONAL_MESSAGE",
      client: __privateGet7(this, _client3)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(transaction),
      signature: parsedSignature.serializedSignature,
      intentScope: "TRANSACTION_DATA",
      client: __privateGet7(this, _client3)
    });
  }
};
_data2 = /* @__PURE__ */ new WeakMap();
_client3 = /* @__PURE__ */ new WeakMap();
var ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(iss);
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
var VerifyZkLoginSignatureQuery = graphql2(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
async function graphqlVerifyZkLoginSignature({
  address,
  bytes: bytes2,
  signature,
  intentScope,
  client = new SuiGraphQLClient({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  var _a2, _b;
  const resp = await client.query({
    query: VerifyZkLoginSignatureQuery,
    variables: {
      bytes: bytes2,
      signature,
      intentScope,
      author: address
    }
  });
  return ((_a2 = resp.data) == null ? void 0 : _a2.verifyZkloginSignature.success) === true && ((_b = resp.data) == null ? void 0 : _b.verifyZkloginSignature.errors.length) === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes2 = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes2[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes2.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  return {
    serializedSignature: toBase64(bytes2),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes2,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes2 = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes2[0]];
  switch (signatureScheme) {
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes2.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes: bytes2
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes2.slice(1, bytes2.length - size);
      const publicKey = bytes2.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes: bytes2
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value2 >> _32n2 & _u32_max);
  const wl2 = Number(value2 & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl2, isLE2);
}
var Chi = (a3, b, c) => a3 & b ^ ~a3 & c;
var Maj = (a3, b, c) => a3 & b ^ a3 & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to2.length = length;
    to2.pos = pos;
    to2.finished = finished;
    to2.destroyed = destroyed;
    if (length % blockLen)
      to2.buffer.set(buffer);
    return to2;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B: B2, C, D, E: E2, F: F2, G, H: H2 } = this;
    return [A, B2, C, D, E2, F2, G, H2];
  }
  // prettier-ignore
  set(A, B2, C, D, E2, F2, G, H2) {
    this.A = A | 0;
    this.B = B2 | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B: B2, C, D, E: E2, F: F2, G, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B2, C) | 0;
      H2 = G;
      G = F2;
      F2 = E2;
      E2 = D + T1 | 0;
      D = C;
      C = B2;
      B2 = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B2 = B2 + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A, B2, C, D, E2, F2, G, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al: Al2, Bh, Bl, Ch, Cl, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al2, Bh, Bl, Ch, Cl, Dh, Dl2, Eh, El2, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al2, Bh, Bl, Ch, Cl, Dh, Dl2, Eh, El2, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh | 0;
    this.El = El2 | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al: Al2, Bh, Bl, Ch, Cl, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default.rotrSH(Eh, El2, 14) ^ u64_default.rotrSH(Eh, El2, 18) ^ u64_default.rotrBH(Eh, El2, 41);
      const sigma1l = u64_default.rotrSL(Eh, El2, 14) ^ u64_default.rotrSL(Eh, El2, 18) ^ u64_default.rotrBL(Eh, El2, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El2 & Fl ^ ~El2 & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al2, 28) ^ u64_default.rotrBH(Ah, Al2, 34) ^ u64_default.rotrBH(Ah, Al2, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al2, 28) ^ u64_default.rotrBL(Ah, Al2, 34) ^ u64_default.rotrBL(Ah, Al2, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al2 & Bl ^ Al2 & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El2 | 0;
      ({ h: Eh, l: El2 } = u64_default.add(Dh | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl2 = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al2 | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah, l: Al2 } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al2 | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl2 } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl2 | 0));
    ({ h: Eh, l: El2 } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El2 | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al2, Bh, Bl, Ch, Cl, Dh, Dl2, Eh, El2, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`Wrong integer: ${n2}`);
}
function isBytes2(a3) {
  return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id = (a3) => a3;
  const wrap2 = (a3, b) => (c) => a3(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap2, id);
  const decode = args.map((x) => x.decode).reduce(wrap2, id);
  return { encode, decode };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i2) => {
        assertNumber(i2);
        if (i2 < 0 || i2 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet2.length})`);
        return alphabet2[i2];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join2(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i2 of from)
        if (typeof i2 !== "string")
          throw new Error(`join.encode: non-string input=${i2}`);
      return from.join(separator);
    },
    decode: (to2) => {
      if (typeof to2 !== "string")
        throw new Error("join.decode input should be string");
      return to2.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of data)
        if (typeof i2 !== "string")
          throw new Error(`padding.encode: non-string input=${i2}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of input)
        if (typeof i2 !== "string")
          throw new Error(`padding.decode: non-string input=${i2}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  if (typeof fn2 !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to2) => fn2(to2) };
}
function convertRadix(data, from, to2) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to2 < 2)
    throw new Error(`convertRadix: wrong to=${to2}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < digits.length; i2++) {
      const digit = digits[i2];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to2;
      const rounded = Math.floor(digitBase / to2);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to2 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a3, b) => !b ? a3 : gcd(b, a3 % b);
var radix2carry = (from, to2) => from + (to2 - gcd(from, to2));
function convertRadix2(data, from, to2, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to2 <= 0 || to2 > 32)
    throw new Error(`convertRadix2: wrong to=${to2}`);
  if (radix2carry(from, to2) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to2} carryBits=${radix2carry(from, to2)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to2 - 1;
  const res = [];
  for (const n2 of data) {
    assertNumber(n2);
    if (n2 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to2; pos -= to2)
      res.push((carry >> pos - to2 & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to2 - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  if (typeof fn2 !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e3) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join2(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join2(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join2(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join2(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join2(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join2(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0)
      throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join2(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var import_bech32 = __toESM(require_dist(), 1);
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes2, intent) {
    const intentMessage = messageWithIntent(intent, bytes2);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes2)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes2) {
    return this.signWithIntent(bytes2, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes2) {
    const { signature } = await this.signWithIntent(
      bcs.vector(bcs.u8()).serialize(bytes2).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes2),
      signature
    };
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes2;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes2 = parsed.signature;
    } else {
      bytes2 = signature;
    }
    return import_tweetnacl.default.sign.detached.verify(message, bytes2, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes3,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes3(a3) {
  return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
var hexes2 = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  abytes(bytes2);
  let hex2 = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex2 += hexes2[bytes2[i2]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase162(char) {
  if (char >= asciis2._0 && char <= asciis2._9)
    return char - asciis2._0;
  if (char >= asciis2._A && char <= asciis2._F)
    return char - (asciis2._A - 10);
  if (char >= asciis2._a && char <= asciis2._f)
    return char - (asciis2._a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi2));
    const n2 = asciiToBase162(hex2.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n2;
  }
  return array2;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes2(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes2(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e3) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e3}`);
    }
  } else if (isBytes3(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    abytes(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    res.set(a3, pad);
    pad += a3.length;
  }
  return res;
}
function equalBytes(a3, b) {
  if (a3.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a3.length; i2++)
    diff |= a3[i2] ^ b[i2];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n;
}
function bitSet(n2, pos, value2) {
  return n2 | (value2 ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n2) => (_2n << BigInt(n2 - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl2 = v.slice();
      out.push(sl2);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type2}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object2;
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a3, b) {
  const result = a3 % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a3 = mod(number3, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a3 !== _0n2) {
    const q = b / a3;
    const r = b % a3;
    const m = x - u * q;
    const n2 = y - v * q;
    b = a3, a3 = r, x = u, y = v, u = m, v = n2;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q2, S, Z2;
  for (Q2 = P - _1n2, S = 0; Q2 % _2n2 === _0n2; Q2 /= _2n2, S++)
    ;
  for (Z2 = _2n2; Z2 < P && pow(Z2, legendreC, P) !== P - _1n2; Z2++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n2) / _2n2;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.pow(n2, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z2), Q2);
    let x = Fp3.pow(n2, Q1div2);
    let b = Fp3.pow(n2, Q2);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t22 = Fp3.sqr(b); m < r; m++) {
        if (Fp3.eql(t22, Fp3.ONE))
          break;
        t22 = Fp3.sqr(t22);
      }
      const ge3 = Fp3.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp3.sqr(ge3);
      x = Fp3.mul(x, ge3);
      b = Fp3.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp3, n2) {
      const n22 = Fp3.mul(n2, _2n2);
      const v = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n2, v);
      const i2 = Fp3.mul(Fp3.mul(nv, _2n2), v);
      const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = f.mul(acc, tmp[i2]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f, n2)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a3, b, c) => c ? b : a3,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n3) {
        if (n2 & _1n3)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n2, transform2) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform2(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a3 } = opts;
  if (endo) {
    if (!Fp3.eql(a3, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E2 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl2 = h(shl);
    const rl2 = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl2}${r}02${sl2}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a3 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a3.x), Fp3.toBytes(a3.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a: a3, b } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a3)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error2) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp3.eql(i2, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b } = CURVE;
      const b3 = Fp3.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t22 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a3, Z3);
      Y3 = Fp3.mul(b3, t22);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t22 = Fp3.mul(a3, t22);
      t3 = Fp3.sub(t0, t22);
      t3 = Fp3.mul(a3, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t22);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t22 = Fp3.mul(Y1, Z1);
      t22 = Fp3.add(t22, t22);
      t0 = Fp3.mul(t22, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t22, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a3 = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n2);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t22 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t22);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t22);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a3, t4);
      X3 = Fp3.mul(b3, t22);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t22 = Fp3.mul(a3, t22);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t22);
      t22 = Fp3.sub(t0, t22);
      t22 = Fp3.mul(a3, t22);
      t4 = Fp3.add(t4, t22);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point2.ZERO;
      if (n2 === _0n4)
        return I;
      assertGE(n2);
      if (n2 === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n2);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a3, b) {
      const G = Point2.BASE;
      const mul = (P, a4) => a4 === _0n4 || a4 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a4) : P.multiply(a4);
      const sum = mul(this, a3).add(mul(Q2, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp3.ORDER;
  }
  function modN2(a3) {
    return mod(a3, CURVE_ORDER);
  }
  function invN(a3) {
    return invert(a3, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a3 = point.toAffine();
      const x = Fp3.toBytes(a3.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a3.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n4;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to2) => bytesToNumberBE(b.slice(from, to2));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l * 2);
      return new Signature(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir2 = invN(radj);
      const u1 = modN2(-h * ir2);
      const u2 = modN2(s * ir2);
      const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e3 = ent === true ? randomBytes2(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes3(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error2) {
      if (error2.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is3 = invN(s);
    const u1 = modN2(h * is3);
    const u2 = modN2(r * is3);
    const R2 = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v = modN2(R2.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp3, Z2) {
  const q = Fp3.ORDER;
  let l = _0n4;
  for (let o2 = q - _1n4; o2 % _2n3 === _0n4; o2 /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z2, c2);
  const c7 = Fp3.pow(Z2, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n4; i2--) {
      let tv52 = i2 - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n2) {
    const c12 = (Fp3.ORDER - _3n2) / _4n2;
    const c22 = Fp3.sqrt(Fp3.neg(Z2));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value2);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value2, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    x = Fp3.div(x, tv4);
    return { x, y };
  };
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value2, length) {
  if (value2 < 0 || value2 >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value2} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i2 = length - 1; i2 >= 0; i2--) {
    res[i2] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a3, b) {
  const arr = new Uint8Array(a3.length);
  for (let i2 = 0; i2 < a3.length; i2++) {
    arr[i2] = a3[i2] ^ b[i2];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H2) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H2(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H2;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H2(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H2(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b[i2] = H2(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H2) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H2.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H2.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L2 = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e3 = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L2 * (j + i2 * m);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e3[j] = mod(os2ip(tv), p);
    }
    u[i2] = e3;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${i2} in array`);
      const P = Point2.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a3, b) => (a3 + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t22 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t22, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a22, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n2) => numberToBytesBE(n2, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q2, a3, b) => Point.BASE.multiplyAndAddUnsafe(Q2, a3, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a3 = ensureBytes("auxRand", auxRand, 32);
  const t3 = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a3)));
  const rand = taggedHash("BIP0340/nonce", t3, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e3 = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e3 * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e3 = challenge(numTo32b(r), pointToBytes(P), m);
    const R2 = GmulAdd(P, s, modN(-e3));
    if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r)
      return false;
    return true;
  } catch (error2) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@mysten/sui/dist/esm/keypairs/secp256k1/publickey.js
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256k1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes2;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256k1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes2 = parsed.signature;
    } else {
      bytes2 = signature;
    }
    return secp256k1.verify(
      secp256k1.Signature.fromCompact(bytes2),
      sha256(message),
      this.toRawBytes()
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// node_modules/@noble/curves/esm/p256.js
var Fp2 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp2.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  // Equation params: a, b
  b: CURVE_B,
  Fp: Fp2,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var mapSWU2 = (() => mapToCurveSimpleSWU(Fp2, {
  A: CURVE_A,
  B: CURVE_B,
  Z: Fp2.create(BigInt("-10"))
}))();
var htf2 = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU2(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();

// node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes2;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes2 = parsed.signature;
    } else {
      bytes2 = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes2),
      sha256(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/sui/dist/esm/multisig/signer.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value2) => member.has(obj) ? __typeError8("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet8 = (obj, member, value2, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _pubkey;
var _signers;
var MultiSigSigner = class extends Signer {
  constructor(pubkey, signers = []) {
    var _a2;
    super();
    __privateAdd7(this, _pubkey);
    __privateAdd7(this, _signers);
    __privateSet8(this, _pubkey, pubkey);
    __privateSet8(this, _signers, signers);
    let uniqueKeys = /* @__PURE__ */ new Set();
    let combinedWeight = 0;
    const weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({
      weight,
      address: publicKey.toSuiAddress()
    }));
    for (let signer of signers) {
      const address = signer.toSuiAddress();
      if (uniqueKeys.has(address)) {
        throw new Error(`Can't create MultiSigSigner with duplicate signers`);
      }
      uniqueKeys.add(address);
      const weight = (_a2 = weights.find((w) => w.address === address)) == null ? void 0 : _a2.weight;
      if (!weight) {
        throw new Error(`Signer ${address} is not part of the MultiSig public key`);
      }
      combinedWeight += weight;
    }
    if (combinedWeight < pubkey.getThreshold()) {
      throw new Error(`Combined weight of signers is less than threshold`);
    }
  }
  getKeyScheme() {
    return "MultiSig";
  }
  getPublicKey() {
    return __privateGet8(this, _pubkey);
  }
  sign(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  signData(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  async signTransaction(bytes2) {
    const signature = __privateGet8(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet8(this, _signers).map(async (signer) => (await signer.signTransaction(bytes2)).signature)
      )
    );
    return {
      signature,
      bytes: toBase64(bytes2)
    };
  }
  async signPersonalMessage(bytes2) {
    const signature = __privateGet8(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet8(this, _signers).map(async (signer) => (await signer.signPersonalMessage(bytes2)).signature)
      )
    );
    return {
      signature,
      bytes: toBase64(bytes2)
    };
  }
};
_pubkey = /* @__PURE__ */ new WeakMap();
_signers = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/multisig/publickey.js
var MAX_SIGNER_IN_MULTISIG = 10;
var MIN_SIGNER_IN_MULTISIG = 1;
var MultiSigPublicKey2 = class _MultiSigPublicKey extends PublicKey2 {
  /**
   * Create a new MultiSigPublicKey object
   */
  constructor(value2, options = {}) {
    super();
    if (typeof value2 === "string") {
      this.rawBytes = fromBase64(value2);
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else if (value2 instanceof Uint8Array) {
      this.rawBytes = value2;
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else {
      this.multisigPublicKey = value2;
      this.rawBytes = suiBcs.MultiSigPublicKey.serialize(value2).toBytes();
    }
    if (this.multisigPublicKey.threshold < 1) {
      throw new Error("Invalid threshold");
    }
    const seenPublicKeys = /* @__PURE__ */ new Set();
    this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {
      const [scheme, bytes2] = Object.entries(pubKey).filter(([name2]) => name2 !== "$kind")[0];
      const publicKeyStr = Uint8Array.from(bytes2).toString();
      if (seenPublicKeys.has(publicKeyStr)) {
        throw new Error(`Multisig does not support duplicate public keys`);
      }
      seenPublicKeys.add(publicKeyStr);
      if (weight < 1) {
        throw new Error(`Invalid weight`);
      }
      return {
        publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes2), options),
        weight
      };
    });
    const totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);
    if (this.multisigPublicKey.threshold > totalWeight) {
      throw new Error(`Unreachable threshold`);
    }
    if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {
      throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);
    }
  }
  /**
   * 	A static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.
   */
  static fromPublicKeys({
    threshold,
    publicKeys
  }) {
    return new _MultiSigPublicKey({
      pk_map: publicKeys.map(({ publicKey, weight }) => {
        const scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()];
        return {
          pubKey: { [scheme]: Array.from(publicKey.toRawBytes()) },
          weight
        };
      }),
      threshold
    });
  }
  /**
   * Checks if two MultiSig public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the MultiSig public key
   */
  toRawBytes() {
    return this.rawBytes;
  }
  getPublicKeys() {
    return this.publicKeys;
  }
  getThreshold() {
    return this.multisigPublicKey.threshold;
  }
  getSigner(...signers) {
    return new MultiSigSigner(this, signers);
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  toSuiAddress() {
    const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;
    const tmp = new Uint8Array(maxLength);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(suiBcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);
    let i2 = 3;
    for (const { publicKey, weight } of this.publicKeys) {
      const bytes2 = publicKey.toSuiBytes();
      tmp.set(bytes2, i2);
      i2 += bytes2.length;
      tmp.set([weight], i2++);
    }
    return normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i2), { dkLen: 32 })));
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["MultiSig"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, multisigSignature) {
    const parsed = parseSerializedSignature(multisigSignature);
    if (parsed.signatureScheme !== "MultiSig") {
      throw new Error("Invalid signature scheme");
    }
    const { multisig } = parsed;
    let signatureWeight = 0;
    if (!bytesEqual(
      suiBcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),
      suiBcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes()
    )) {
      return false;
    }
    for (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {
      if (!await publicKey.verify(message, signature)) {
        return false;
      }
      signatureWeight += weight;
    }
    return signatureWeight >= this.multisigPublicKey.threshold;
  }
  /**
   * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once
   * and that all the public keys involved are known and valid, and then serializes multisig into the standard format
   */
  combinePartialSignatures(signatures) {
    var _a2, _b;
    if (signatures.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    let bitmap = 0;
    const compressedSignatures = new Array(signatures.length);
    for (let i2 = 0; i2 < signatures.length; i2++) {
      let parsed = parseSerializedSignature(signatures[i2]);
      if (parsed.signatureScheme === "MultiSig") {
        throw new Error("MultiSig is not supported inside MultiSig");
      }
      let publicKey;
      if (parsed.signatureScheme === "ZkLogin") {
        publicKey = toZkLoginPublicIdentifier(
          (_a2 = parsed.zkLogin) == null ? void 0 : _a2.addressSeed,
          (_b = parsed.zkLogin) == null ? void 0 : _b.iss
        ).toRawBytes();
      } else {
        publicKey = parsed.publicKey;
      }
      compressedSignatures[i2] = {
        [parsed.signatureScheme]: Array.from(parsed.signature.map((x) => Number(x)))
      };
      let publicKeyIndex;
      for (let j = 0; j < this.publicKeys.length; j++) {
        if (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {
          if (bitmap & 1 << j) {
            throw new Error("Received multiple signatures from the same public key");
          }
          publicKeyIndex = j;
          break;
        }
      }
      if (publicKeyIndex === void 0) {
        throw new Error("Received signature from unknown public key");
      }
      bitmap |= 1 << publicKeyIndex;
    }
    let multisig = {
      sigs: compressedSignatures,
      bitmap,
      multisig_pk: this.multisigPublicKey
    };
    const bytes2 = suiBcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();
    let tmp = new Uint8Array(bytes2.length + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(bytes2, 1);
    return toBase64(tmp);
  }
};
function parsePartialSignatures(multisig, options = {}) {
  let res = new Array(multisig.sigs.length);
  for (let i2 = 0; i2 < multisig.sigs.length; i2++) {
    const [signatureScheme, signature] = Object.entries(multisig.sigs[i2]).filter(
      ([name2]) => name2 !== "$kind"
    )[0];
    const pkIndex = asIndices(multisig.bitmap).at(i2);
    const pair = multisig.multisig_pk.pk_map[pkIndex];
    const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);
    if (signatureScheme === "MultiSig") {
      throw new Error("MultiSig is not supported inside MultiSig");
    }
    const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);
    res[i2] = {
      signatureScheme,
      signature: Uint8Array.from(signature),
      publicKey,
      weight: pair.weight
    };
  }
  return res;
}
function asIndices(bitmap) {
  if (bitmap < 0 || bitmap > 1024) {
    throw new Error("Invalid bitmap");
  }
  let res = [];
  for (let i2 = 0; i2 < 10; i2++) {
    if ((bitmap & 1 << i2) !== 0) {
      res.push(i2);
    }
  }
  return Uint8Array.from(res);
}

// node_modules/@mysten/sui/dist/esm/verify/verify.js
async function verifyPersonalMessageSignature(message, signature, options = {}) {
  const parsedSignature = parseSignature(signature, options);
  if (!await parsedSignature.publicKey.verifyPersonalMessage(
    message,
    parsedSignature.serializedSignature
  )) {
    throw new Error(`Signature is not valid for the provided message`);
  }
  return parsedSignature.publicKey;
}
function parseSignature(signature, options = {}) {
  const parsedSignature = parseSerializedSignature(signature);
  if (parsedSignature.signatureScheme === "MultiSig") {
    return {
      ...parsedSignature,
      publicKey: new MultiSigPublicKey2(parsedSignature.multisig.multisig_pk)
    };
  }
  const publicKey = publicKeyFromRawBytes(
    parsedSignature.signatureScheme,
    parsedSignature.publicKey,
    options
  );
  return {
    ...parsedSignature,
    publicKey
  };
}
function publicKeyFromRawBytes(signatureScheme, bytes2, options = {}) {
  switch (signatureScheme) {
    case "ED25519":
      return new Ed25519PublicKey(bytes2);
    case "Secp256k1":
      return new Secp256k1PublicKey(bytes2);
    case "Secp256r1":
      return new Secp256r1PublicKey(bytes2);
    case "MultiSig":
      return new MultiSigPublicKey2(bytes2);
    case "ZkLogin":
      return new ZkLoginPublicIdentifier(bytes2, options);
    default:
      throw new Error(`Unsupported signature scheme ${signatureScheme}`);
  }
}

// node_modules/@suiet/wallet-kit/dist/index.js
var import_react_dom = __toESM(require_react_dom());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Ls = Object.defineProperty;
var Ss = (e3, t3, n2) => t3 in e3 ? Ls(e3, t3, { enumerable: true, configurable: true, writable: true, value: n2 }) : e3[t3] = n2;
var fe2 = (e3, t3, n2) => (Ss(e3, typeof t3 != "symbol" ? t3 + "" : t3, n2), n2);
var Cs = class extends TypeError {
  constructor(t3, n2) {
    let r;
    const { message: s, explanation: a3, ...l } = t3, { path: u } = t3, f = u.length === 0 ? s : `At path: ${u.join(".")} -- ${s}`;
    super(a3 ?? f), a3 != null && (this.cause = f), Object.assign(this, l), this.name = this.constructor.name, this.failures = () => r ?? (r = [t3, ...n2()]);
  }
};
function Os(e3) {
  return be(e3) && typeof e3[Symbol.iterator] == "function";
}
function be(e3) {
  return typeof e3 == "object" && e3 != null;
}
function Re(e3) {
  return typeof e3 == "symbol" ? e3.toString() : typeof e3 == "string" ? JSON.stringify(e3) : `${e3}`;
}
function xs(e3) {
  const { done: t3, value: n2 } = e3.next();
  return t3 ? void 0 : n2;
}
function zs(e3, t3, n2, r) {
  if (e3 === true)
    return;
  e3 === false ? e3 = {} : typeof e3 == "string" && (e3 = { message: e3 });
  const { path: s, branch: a3 } = t3, { type: l } = n2, { refinement: u, message: f = `Expected a value of type \`${l}\`${u ? ` with refinement \`${u}\`` : ""}, but received: \`${Re(r)}\`` } = e3;
  return {
    value: r,
    type: l,
    refinement: u,
    key: s[s.length - 1],
    path: s,
    branch: a3,
    ...e3,
    message: f
  };
}
function* Wr(e3, t3, n2, r) {
  Os(e3) || (e3 = [e3]);
  for (const s of e3) {
    const a3 = zs(s, t3, n2, r);
    a3 && (yield a3);
  }
}
function* wr(e3, t3, n2 = {}) {
  const { path: r = [], branch: s = [e3], coerce: a3 = false, mask: l = false } = n2, u = { path: r, branch: s };
  if (a3 && (e3 = t3.coercer(e3, u), l && t3.type !== "type" && be(t3.schema) && be(e3) && !Array.isArray(e3)))
    for (const h in e3)
      t3.schema[h] === void 0 && delete e3[h];
  let f = "valid";
  for (const h of t3.validator(e3, u))
    h.explanation = n2.message, f = "not_valid", yield [h, void 0];
  for (let [h, g, p] of t3.entries(e3, u)) {
    const I = wr(g, p, {
      path: h === void 0 ? r : [...r, h],
      branch: h === void 0 ? s : [...s, g],
      coerce: a3,
      mask: l,
      message: n2.message
    });
    for (const N of I)
      N[0] ? (f = N[0].refinement != null ? "not_refined" : "not_valid", yield [N[0], void 0]) : a3 && (g = N[1], h === void 0 ? e3 = g : e3 instanceof Map ? e3.set(h, g) : e3 instanceof Set ? e3.add(g) : be(e3) && (g !== void 0 || h in e3) && (e3[h] = g));
  }
  if (f !== "not_valid")
    for (const h of t3.refiner(e3, u))
      h.explanation = n2.message, f = "not_refined", yield [h, void 0];
  f === "valid" && (yield [void 0, e3]);
}
var We = class {
  constructor(t3) {
    const { type: n2, schema: r, validator: s, refiner: a3, coercer: l = (f) => f, entries: u = function* () {
    } } = t3;
    this.type = n2, this.schema = r, this.entries = u, this.coercer = l, s ? this.validator = (f, h) => {
      const g = s(f, h);
      return Wr(g, h, this, f);
    } : this.validator = () => [], a3 ? this.refiner = (f, h) => {
      const g = a3(f, h);
      return Wr(g, h, this, f);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t3, n2) {
    return Rs(t3, this, n2);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t3, n2) {
    return Us(t3, this, n2);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t3) {
    return Ps(t3, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t3, n2) {
    return ks(t3, this, n2);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t3, n2 = {}) {
    return Yt(t3, this, n2);
  }
};
function Rs(e3, t3, n2) {
  const r = Yt(e3, t3, { message: n2 });
  if (r[0])
    throw r[0];
}
function Us(e3, t3, n2) {
  const r = Yt(e3, t3, { coerce: true, message: n2 });
  if (r[0])
    throw r[0];
  return r[1];
}
function ks(e3, t3, n2) {
  const r = Yt(e3, t3, { coerce: true, mask: true, message: n2 });
  if (r[0])
    throw r[0];
  return r[1];
}
function Ps(e3, t3) {
  return !Yt(e3, t3)[0];
}
function Yt(e3, t3, n2 = {}) {
  const r = wr(e3, t3, n2), s = xs(r);
  return s[0] ? [new Cs(s[0], function* () {
    for (const a3 of r)
      a3[0] && (yield a3[0]);
  }), void 0] : [void 0, s[1]];
}
function Qt(...e3) {
  const t3 = e3[0].type === "type", n2 = e3.map((s) => s.schema), r = Object.assign({}, ...n2);
  return t3 ? Fs(r) : R(r);
}
function Xe(e3, t3) {
  return new We({ type: e3, schema: null, validator: t3 });
}
function Qs() {
  return Xe("any", () => true);
}
function Er(e3) {
  return new We({
    type: "array",
    schema: e3,
    *entries(t3) {
      if (e3 && Array.isArray(t3))
        for (const [n2, r] of t3.entries())
          yield [n2, r, e3];
    },
    coercer(t3) {
      return Array.isArray(t3) ? t3.slice() : t3;
    },
    validator(t3) {
      return Array.isArray(t3) || `Expected an array value, but received: ${Re(t3)}`;
    }
  });
}
function Bs() {
  return Xe("bigint", (e3) => typeof e3 == "bigint");
}
function Oe() {
  return Xe("boolean", (e3) => typeof e3 == "boolean");
}
function ge2(e3) {
  const t3 = Re(e3), n2 = typeof e3;
  return new We({
    type: "literal",
    schema: n2 === "string" || n2 === "number" || n2 === "boolean" ? e3 : null,
    validator(r) {
      return r === e3 || `Expected the literal \`${t3}\`, but received: ${Re(r)}`;
    }
  });
}
function mi() {
  return Xe("never", () => false);
}
function J(e3) {
  return new We({
    ...e3,
    validator: (t3, n2) => t3 === null || e3.validator(t3, n2),
    refiner: (t3, n2) => t3 === null || e3.refiner(t3, n2)
  });
}
function Rt() {
  return Xe("number", (e3) => typeof e3 == "number" && !isNaN(e3) || `Expected a number, but received: ${Re(e3)}`);
}
function R(e3) {
  const t3 = e3 ? Object.keys(e3) : [], n2 = mi();
  return new We({
    type: "object",
    schema: e3 || null,
    *entries(r) {
      if (e3 && be(r)) {
        const s = new Set(Object.keys(r));
        for (const a3 of t3)
          s.delete(a3), yield [a3, r[a3], e3[a3]];
        for (const a3 of s)
          yield [a3, r[a3], n2];
      }
    },
    validator(r) {
      return be(r) || `Expected an object, but received: ${Re(r)}`;
    },
    coercer(r) {
      return be(r) ? { ...r } : r;
    }
  });
}
function F(e3) {
  return new We({
    ...e3,
    validator: (t3, n2) => t3 === void 0 || e3.validator(t3, n2),
    refiner: (t3, n2) => t3 === void 0 || e3.refiner(t3, n2)
  });
}
function st(e3, t3) {
  return new We({
    type: "record",
    schema: null,
    *entries(n2) {
      if (be(n2))
        for (const r in n2) {
          const s = n2[r];
          yield [r, r, e3], yield [r, s, t3];
        }
    },
    validator(n2) {
      return be(n2) || `Expected an object, but received: ${Re(n2)}`;
    }
  });
}
function T() {
  return Xe("string", (e3) => typeof e3 == "string" || `Expected a string, but received: ${Re(e3)}`);
}
function Ws(e3) {
  const t3 = mi();
  return new We({
    type: "tuple",
    schema: null,
    *entries(n2) {
      if (Array.isArray(n2)) {
        const r = Math.max(e3.length, n2.length);
        for (let s = 0; s < r; s++)
          yield [s, n2[s], e3[s] || t3];
      }
    },
    validator(n2) {
      return Array.isArray(n2) || `Expected an array, but received: ${Re(n2)}`;
    }
  });
}
function Fs(e3) {
  const t3 = Object.keys(e3);
  return new We({
    type: "type",
    schema: e3,
    *entries(n2) {
      if (be(n2))
        for (const r of t3)
          yield [r, n2[r], e3[r]];
    },
    validator(n2) {
      return be(n2) || `Expected an object, but received: ${Re(n2)}`;
    },
    coercer(n2) {
      return be(n2) ? { ...n2 } : n2;
    }
  });
}
function Ye(e3) {
  const t3 = e3.map((n2) => n2.type).join(" | ");
  return new We({
    type: "union",
    schema: null,
    coercer(n2) {
      for (const r of e3) {
        const [s, a3] = r.validate(n2, { coerce: true });
        if (!s)
          return a3;
      }
      return n2;
    },
    validator(n2, r) {
      const s = [];
      for (const a3 of e3) {
        const [...l] = wr(n2, a3, r), [u] = l;
        if (u[0])
          for (const [f] of l)
            f && s.push(f);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t3}\`, but received: ${Re(n2)}`,
        ...s
      ];
    }
  });
}
function Ys() {
  return Xe("unknown", () => true);
}
var br = Ye([
  R({
    AddressOwner: T()
  }),
  R({
    ObjectOwner: T()
  }),
  R({
    Shared: R({
      initial_shared_version: J(T())
    })
  }),
  ge2("Immutable")
]);
Xe("SuiJsonValue", () => true);
var _s = Ye([
  R({ u32: T() }),
  R({ u64: T() }),
  R({ f64: T() })
]);
R({
  attributes: st(T(), J(_s)),
  featureFlags: st(T(), Oe()),
  maxSupportedProtocolVersion: T(),
  minSupportedProtocolVersion: T(),
  protocolVersion: T()
});
Ye([T(), ge2("package")]);
var xn = R({
  /** Base64 string representing the object digest */
  digest: T(),
  /** Hex code as string representing the object id */
  objectId: T(),
  /** Object version */
  version: Ye([Rt(), T(), Bs()])
});
R({
  owner: br,
  reference: xn
});
R({
  objectId: T(),
  sequenceNumber: T()
});
R({
  payment: Er(xn),
  /** Gas Object's owner */
  owner: T(),
  price: T(),
  budget: T()
});
var Gs = Qt(
  xn,
  R({
    type: T(),
    owner: br,
    previousTransaction: T()
  })
);
var Zs = st(T(), Qs());
var Vs = st(T(), Ys());
var qs = R({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: T(),
  /** Fields and values stored inside the Move object */
  fields: Zs,
  hasPublicTransfer: Oe()
});
var Xs = R({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: Vs
});
var Hs = Ye([
  Qt(qs, R({ dataType: ge2("moveObject") })),
  Qt(Xs, R({ dataType: ge2("package") }))
]);
var Ks = R({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: T(),
  hasPublicTransfer: Oe(),
  version: T(),
  bcsBytes: T()
});
var Js = R({
  id: T(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: st(T(), T())
});
var $s = Ye([
  Qt(Ks, R({ dataType: ge2("moveObject") })),
  Qt(Js, R({ dataType: ge2("package") }))
]);
BigInt(1e9);
var Ai = R({
  code: T(),
  error: F(T()),
  object_id: F(T()),
  parent_object_id: F(T()),
  version: F(T()),
  digest: F(T())
});
var ea = R({
  data: J(F(st(T(), T()))),
  error: J(F(Ai))
});
var ta = Ye([
  ea,
  F(st(T(), T()))
]);
var vi = R({
  objectId: T(),
  version: T(),
  digest: T(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: J(F(T())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: J(F(Hs)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: J(F($s)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: J(F(br)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: J(F(T())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: J(F(T())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: J(F(ta))
});
R({
  /* Whether to fetch the object type, default to be true */
  showType: J(F(Oe())),
  /* Whether to fetch the object content, default to be false */
  showContent: J(F(Oe())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: J(F(Oe())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: J(F(Oe())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: J(F(Oe())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: J(F(Oe())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: J(F(Oe()))
});
Ye([
  ge2("Exists"),
  ge2("notExists"),
  ge2("Deleted")
]);
Er(Gs);
var na = R({
  data: J(F(vi)),
  error: J(F(Ai))
});
function wi(e3) {
  return e3.data;
}
function ra(e3) {
  if (e3.error && "object_id" in e3.error && "version" in e3.error && "digest" in e3.error) {
    const t3 = e3.error;
    return {
      objectId: t3.object_id,
      version: t3.version,
      digest: t3.digest
    };
  }
}
function ia(e3) {
  if (e3.error && "object_id" in e3.error && !("version" in e3.error) && !("digest" in e3.error))
    return e3.error.object_id;
}
function sa(e3) {
  if ("reference" in e3)
    return e3.reference;
  const t3 = wi(e3);
  return t3 ? {
    objectId: t3.objectId,
    version: t3.version,
    digest: t3.digest
  } : ra(e3);
}
function aa(e3) {
  var _a2;
  return "objectId" in e3 ? e3.objectId : ((_a2 = sa(e3)) == null ? void 0 : _a2.objectId) ?? ia(e3);
}
function oa(e3) {
  return e3.data !== void 0;
}
function ua(e3) {
  var _a2;
  const t3 = oa(e3) ? e3.data : e3;
  return !(t3 == null ? void 0 : t3.type) && "data" in e3 ? ((_a2 = t3 == null ? void 0 : t3.content) == null ? void 0 : _a2.dataType) === "package" ? "package" : ca(e3) : t3 == null ? void 0 : t3.type;
}
function ca(e3) {
  var _a2;
  return (_a2 = Ei(e3)) == null ? void 0 : _a2.type;
}
function la(e3) {
  var _a2;
  return "fields" in e3 ? e3.fields : (_a2 = Ei(e3)) == null ? void 0 : _a2.fields;
}
function fa(e3) {
  return e3.content !== void 0;
}
function Ei(e3) {
  const t3 = "data" in e3 ? wi(e3) : e3;
  if (!(!t3 || !fa(t3) || t3.content.dataType !== "moveObject"))
    return t3.content;
}
R({
  objectId: T(),
  atCheckpoint: F(Rt())
});
R({
  data: Er(na),
  nextCursor: F(J(T())),
  hasNextPage: Oe()
});
Ye([
  R({
    details: vi,
    status: ge2("VersionFound")
  }),
  R({
    details: T(),
    status: ge2("ObjectNotExists")
  }),
  R({
    details: xn,
    status: ge2("ObjectDeleted")
  }),
  R({
    details: Ws([T(), Rt()]),
    status: ge2("VersionNotFound")
  }),
  R({
    details: R({
      asked_version: Rt(),
      latest_version: Rt(),
      object_id: T()
    }),
    status: ge2("VersionTooHigh")
  })
]);
var da = 32;
function ha(e3, t3 = false) {
  let n2 = e3.toLowerCase();
  return !t3 && n2.startsWith("0x") && (n2 = n2.slice(2)), `0x${n2.padStart(da * 2, "0")}`;
}
function ga(e3, t3 = false) {
  return ha(e3, t3);
}
var Fr = /^0x2::coin::Coin<(.+)>$/;
function ya(e3) {
  return !!e3.data || !!e3.type;
}
var Ne = class _Ne {
  static isCoin(t3) {
    var _a2;
    return ((_a2 = _Ne.getType(t3)) == null ? void 0 : _a2.match(Fr)) != null;
  }
  static getCoinType(t3) {
    const [, n2] = t3.match(Fr) ?? [];
    return n2 || null;
  }
  static getCoinTypeArg(t3) {
    const n2 = _Ne.getType(t3);
    return n2 ? _Ne.getCoinType(n2) : null;
  }
  static isSUI(t3) {
    const n2 = _Ne.getCoinTypeArg(t3);
    return n2 ? _Ne.getCoinSymbol(n2) === "SUI" : false;
  }
  static getCoinSymbol(t3) {
    return t3.substring(t3.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(t3) {
    return {
      address: ga(t3.split("::")[0]),
      module: t3.split("::")[1],
      name: t3.split("::")[2],
      typeParams: []
    };
  }
  static getID(t3) {
    return "fields" in t3 ? t3.fields.id.id : aa(t3);
  }
  static totalBalance(t3) {
    return t3.reduce(
      (n2, r) => n2 + _Ne.getBalanceFromCoinStruct(r),
      BigInt(0)
    );
  }
  /**
   * Sort coin by balance in an ascending order
   */
  static sortByBalance(t3) {
    return [...t3].sort(
      (n2, r) => _Ne.getBalanceFromCoinStruct(n2) < _Ne.getBalanceFromCoinStruct(r) ? -1 : _Ne.getBalanceFromCoinStruct(n2) > _Ne.getBalanceFromCoinStruct(r) ? 1 : 0
    );
  }
  static getBalanceFromCoinStruct(t3) {
    return BigInt(t3.balance);
  }
  static getBalance(t3) {
    var _a2;
    if (!_Ne.isCoin(t3))
      return;
    const n2 = (_a2 = la(t3)) == null ? void 0 : _a2.balance;
    return BigInt(n2);
  }
  static getType(t3) {
    return ya(t3) ? ua(t3) : t3.type;
  }
};
var Dr = class _Dr {
  constructor(t3, n2, r) {
    fe2(this, "_objectId"), fe2(this, "_typeArg"), fe2(this, "_balance"), fe2(this, "_symbol"), this._objectId = t3, this._balance = r, this._typeArg = n2, this._symbol = Ne.getCoinSymbol(n2);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(t3) {
    return new _Dr(t3.objectId, t3.typeArg, t3.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
};
var Ce = ((e3) => (e3.DISCONNECTED = "disconnected", e3.CONNECTED = "connected", e3.CONNECTING = "connecting", e3))(Ce || {});
var pa = class {
  constructor(t3) {
    fe2(this, "client"), this.client = t3;
  }
  async getOwnedObjects(t3) {
    var _a2;
    let n2 = true, r = null, s = [];
    for (; n2; ) {
      const a3 = await this.client.getOwnedObjects({
        owner: t3,
        cursor: r,
        options: {
          showType: true,
          showDisplay: true,
          showContent: true,
          showOwner: true
        }
      });
      (_a2 = a3.data) == null ? void 0 : _a2.forEach((l) => {
        const u = l.data;
        u && s.push(u);
      }), n2 = a3.hasNextPage, r = a3.nextCursor;
    }
    return s;
  }
  getSuiClient() {
    return this.client;
  }
  setSuiClient(t3) {
    this.client = t3;
  }
};
var Ma = class extends pa {
  constructor(t3, n2) {
    super(t3), fe2(this, "coinType"), this.coinType = n2;
  }
  /**
   * Get the coin object of one specific token type
   */
  async getOwnedCoins(t3) {
    let n2 = true, r = null, s = [];
    for (; n2; ) {
      const a3 = await this.client.getCoins({
        owner: t3,
        coinType: this.coinType,
        cursor: r
      });
      a3.data.forEach((l) => {
        s.push(
          new Dr(l.coinObjectId, l.coinType, BigInt(l.balance))
        );
      }), n2 = a3.hasNextPage, r = a3.nextCursor;
    }
    return s;
  }
  async getBalance(t3) {
    const n2 = await this.client.getBalance({
      owner: t3,
      coinType: this.coinType
    });
    return BigInt(n2.totalBalance);
  }
};
var Na = class {
  constructor(t3, n2) {
    fe2(this, "address"), fe2(this, "chainRpcUrl"), fe2(this, "suiClient"), this.address = t3, this.chainRpcUrl = n2.chainRpcUrl, this.suiClient = new SuiClient({
      url: n2.chainRpcUrl
    });
  }
  getAddress() {
    return this.address;
  }
  getCoinBalance(t3) {
    return new Ma(this.suiClient, t3).getBalance(this.address);
  }
  getSuiBalance() {
    return this.getCoinBalance(SUI_TYPE_ARG);
  }
  getChainRpcUrl() {
    return this.chainRpcUrl;
  }
  setChainRpcUrl(t3) {
    this.chainRpcUrl = t3, this.suiClient = new SuiClient({
      url: t3
    });
  }
};
var Yr = 1e6;
var Yn = 1e9;
var _n = 1e12;
function Ia(e3, t3) {
  return bi(
    e3,
    Object.assign(
      {
        decimals: 9
      },
      t3
    )
  );
}
function bi(e3, t3) {
  const { decimals: n2 = 0, withAbbr: r = true } = t3 ?? {};
  if (typeof e3 == "bigint" && !Aa(e3))
    return ji(BigInt(e3), {
      decimals: n2,
      withAbbr: r
    });
  if (Number(e3) === 0)
    return "0";
  if (Number(e3) < 0)
    return "-" + bi(-Number(e3), t3);
  const s = Number(e3) / 10 ** n2;
  return s > 0 && s < 1 ? ma(s) : Di(s, r);
}
function Di(e3, t3) {
  if (t3) {
    if (e3 >= Yr && e3 < Yn)
      return Gn(e3, Yr, "M");
    if (e3 >= Yn && e3 < _n)
      return Gn(e3, Yn, "B");
    if (e3 >= _n)
      return Gn(e3, _n, "T");
  }
  return Intl.NumberFormat("en-US").format(e3);
}
function Gn(e3, t3, n2) {
  let r;
  typeof e3 == "bigint" ? r = String(e3 / (BigInt(t3) / 1000n)) : r = String(Math.floor(e3 / (t3 / 1e3)));
  const s = r.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(s)).replace(",", ".") + n2;
}
function ma(e3) {
  if (e3 <= 0)
    return "0";
  const t3 = Math.ceil(-Math.log10(e3));
  return Number(e3) % Math.pow(10, 10 - (t3 + 2)) === 0 && Number(e3) % Math.pow(10, 10 - (t3 + 1)) === 0 ? Zn(e3, t3) : Number(e3) % Math.pow(10, 10 - (t3 + 2)) === 0 && Number(e3) % Math.pow(10, 10 - (t3 + 1)) !== 0 ? Zn(e3, t3 + 1) : Zn(e3, t3 + 2);
}
function Zn(e3, t3) {
  function n2(r) {
    if (isNaN(r))
      return r.toString();
    const s = "" + r;
    return /e/i.test(s) ? r.toFixed(18).replace(/\.?0+$/, "") : r.toString();
  }
  return t3 = t3 || 0, t3 = Math.pow(10, t3), n2(Math.floor(e3 * t3) / t3);
}
function ji(e3, t3) {
  if (e3 === 0n)
    return "0";
  if (e3 < 0n)
    return "-" + ji(-e3, t3);
  const { decimals: n2 = 9, withAbbr: r = true } = t3 ?? {}, s = e3 / 10n ** BigInt(n2);
  return Di(s, r);
}
function Aa(e3) {
  const t3 = Number.MIN_SAFE_INTEGER, n2 = Number.MAX_SAFE_INTEGER;
  return e3 >= BigInt(t3) && e3 <= BigInt(n2);
}
function va(e3) {
  return typeof e3 != "string" ? "" : !e3 || !e3.startsWith("0x") ? e3 : e3.slice(0, 7) + "...." + e3.slice(-4, e3.length);
}
function Ti(e3) {
  return Uint8Array.from(atob(e3), (t3) => t3.charCodeAt(0));
}
var nn = {};
var zn = {};
zn.byteLength = ba;
zn.toByteArray = ja;
zn.fromByteArray = Sa;
var Pe = [];
var we = [];
var wa = typeof Uint8Array < "u" ? Uint8Array : Array;
var Vn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (dt = 0, Ea = Vn.length; dt < Ea; ++dt)
  Pe[dt] = Vn[dt], we[Vn.charCodeAt(dt)] = dt;
var dt;
var Ea;
we[45] = 62;
we[95] = 63;
function Li(e3) {
  var t3 = e3.length;
  if (t3 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n2 = e3.indexOf("=");
  n2 === -1 && (n2 = t3);
  var r = n2 === t3 ? 0 : 4 - n2 % 4;
  return [n2, r];
}
function ba(e3) {
  var t3 = Li(e3), n2 = t3[0], r = t3[1];
  return (n2 + r) * 3 / 4 - r;
}
function Da(e3, t3, n2) {
  return (t3 + n2) * 3 / 4 - n2;
}
function ja(e3) {
  var t3, n2 = Li(e3), r = n2[0], s = n2[1], a3 = new wa(Da(e3, r, s)), l = 0, u = s > 0 ? r - 4 : r, f;
  for (f = 0; f < u; f += 4)
    t3 = we[e3.charCodeAt(f)] << 18 | we[e3.charCodeAt(f + 1)] << 12 | we[e3.charCodeAt(f + 2)] << 6 | we[e3.charCodeAt(f + 3)], a3[l++] = t3 >> 16 & 255, a3[l++] = t3 >> 8 & 255, a3[l++] = t3 & 255;
  return s === 2 && (t3 = we[e3.charCodeAt(f)] << 2 | we[e3.charCodeAt(f + 1)] >> 4, a3[l++] = t3 & 255), s === 1 && (t3 = we[e3.charCodeAt(f)] << 10 | we[e3.charCodeAt(f + 1)] << 4 | we[e3.charCodeAt(f + 2)] >> 2, a3[l++] = t3 >> 8 & 255, a3[l++] = t3 & 255), a3;
}
function Ta(e3) {
  return Pe[e3 >> 18 & 63] + Pe[e3 >> 12 & 63] + Pe[e3 >> 6 & 63] + Pe[e3 & 63];
}
function La(e3, t3, n2) {
  for (var r, s = [], a3 = t3; a3 < n2; a3 += 3)
    r = (e3[a3] << 16 & 16711680) + (e3[a3 + 1] << 8 & 65280) + (e3[a3 + 2] & 255), s.push(Ta(r));
  return s.join("");
}
function Sa(e3) {
  for (var t3, n2 = e3.length, r = n2 % 3, s = [], a3 = 16383, l = 0, u = n2 - r; l < u; l += a3)
    s.push(La(e3, l, l + a3 > u ? u : l + a3));
  return r === 1 ? (t3 = e3[n2 - 1], s.push(
    Pe[t3 >> 2] + Pe[t3 << 4 & 63] + "=="
  )) : r === 2 && (t3 = (e3[n2 - 2] << 8) + e3[n2 - 1], s.push(
    Pe[t3 >> 10] + Pe[t3 >> 4 & 63] + Pe[t3 << 2 & 63] + "="
  )), s.join("");
}
var jr = {};
jr.read = function(e3, t3, n2, r, s) {
  var a3, l, u = s * 8 - r - 1, f = (1 << u) - 1, h = f >> 1, g = -7, p = n2 ? s - 1 : 0, I = n2 ? -1 : 1, N = e3[t3 + p];
  for (p += I, a3 = N & (1 << -g) - 1, N >>= -g, g += u; g > 0; a3 = a3 * 256 + e3[t3 + p], p += I, g -= 8)
    ;
  for (l = a3 & (1 << -g) - 1, a3 >>= -g, g += r; g > 0; l = l * 256 + e3[t3 + p], p += I, g -= 8)
    ;
  if (a3 === 0)
    a3 = 1 - h;
  else {
    if (a3 === f)
      return l ? NaN : (N ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, r), a3 = a3 - h;
  }
  return (N ? -1 : 1) * l * Math.pow(2, a3 - r);
};
jr.write = function(e3, t3, n2, r, s, a3) {
  var l, u, f, h = a3 * 8 - s - 1, g = (1 << h) - 1, p = g >> 1, I = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = r ? 0 : a3 - 1, v = r ? 1 : -1, m = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (u = isNaN(t3) ? 1 : 0, l = g) : (l = Math.floor(Math.log(t3) / Math.LN2), t3 * (f = Math.pow(2, -l)) < 1 && (l--, f *= 2), l + p >= 1 ? t3 += I / f : t3 += I * Math.pow(2, 1 - p), t3 * f >= 2 && (l++, f /= 2), l + p >= g ? (u = 0, l = g) : l + p >= 1 ? (u = (t3 * f - 1) * Math.pow(2, s), l = l + p) : (u = t3 * Math.pow(2, p - 1) * Math.pow(2, s), l = 0)); s >= 8; e3[n2 + N] = u & 255, N += v, u /= 256, s -= 8)
    ;
  for (l = l << s | u, h += s; h > 0; e3[n2 + N] = l & 255, N += v, l /= 256, h -= 8)
    ;
  e3[n2 + N - v] |= m * 128;
};
(function(e3) {
  const t3 = zn, n2 = jr, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e3.Buffer = u, e3.SlowBuffer = C, e3.INSPECT_MAX_BYTES = 50;
  const s = 2147483647;
  e3.kMaxLength = s, u.TYPED_ARRAY_SUPPORT = a3(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a3() {
    try {
      const i2 = new Uint8Array(1), o2 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(o2, Uint8Array.prototype), Object.setPrototypeOf(i2, o2), i2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(i2) {
    if (i2 > s)
      throw new RangeError('The value "' + i2 + '" is invalid for option "size"');
    const o2 = new Uint8Array(i2);
    return Object.setPrototypeOf(o2, u.prototype), o2;
  }
  function u(i2, o2, c) {
    if (typeof i2 == "number") {
      if (typeof o2 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(i2);
    }
    return f(i2, o2, c);
  }
  u.poolSize = 8192;
  function f(i2, o2, c) {
    if (typeof i2 == "string")
      return I(i2, o2);
    if (ArrayBuffer.isView(i2))
      return v(i2);
    if (i2 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i2
      );
    if (Ue(i2, ArrayBuffer) || i2 && Ue(i2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ue(i2, SharedArrayBuffer) || i2 && Ue(i2.buffer, SharedArrayBuffer)))
      return m(i2, o2, c);
    if (typeof i2 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const d = i2.valueOf && i2.valueOf();
    if (d != null && d !== i2)
      return u.from(d, o2, c);
    const y = D(i2);
    if (y)
      return y;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i2[Symbol.toPrimitive] == "function")
      return u.from(i2[Symbol.toPrimitive]("string"), o2, c);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i2
    );
  }
  u.from = function(i2, o2, c) {
    return f(i2, o2, c);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function h(i2) {
    if (typeof i2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i2 < 0)
      throw new RangeError('The value "' + i2 + '" is invalid for option "size"');
  }
  function g(i2, o2, c) {
    return h(i2), i2 <= 0 ? l(i2) : o2 !== void 0 ? typeof c == "string" ? l(i2).fill(o2, c) : l(i2).fill(o2) : l(i2);
  }
  u.alloc = function(i2, o2, c) {
    return g(i2, o2, c);
  };
  function p(i2) {
    return h(i2), l(i2 < 0 ? 0 : b(i2) | 0);
  }
  u.allocUnsafe = function(i2) {
    return p(i2);
  }, u.allocUnsafeSlow = function(i2) {
    return p(i2);
  };
  function I(i2, o2) {
    if ((typeof o2 != "string" || o2 === "") && (o2 = "utf8"), !u.isEncoding(o2))
      throw new TypeError("Unknown encoding: " + o2);
    const c = w(i2, o2) | 0;
    let d = l(c);
    const y = d.write(i2, o2);
    return y !== c && (d = d.slice(0, y)), d;
  }
  function N(i2) {
    const o2 = i2.length < 0 ? 0 : b(i2.length) | 0, c = l(o2);
    for (let d = 0; d < o2; d += 1)
      c[d] = i2[d] & 255;
    return c;
  }
  function v(i2) {
    if (Ue(i2, Uint8Array)) {
      const o2 = new Uint8Array(i2);
      return m(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    return N(i2);
  }
  function m(i2, o2, c) {
    if (o2 < 0 || i2.byteLength < o2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i2.byteLength < o2 + (c || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let d;
    return o2 === void 0 && c === void 0 ? d = new Uint8Array(i2) : c === void 0 ? d = new Uint8Array(i2, o2) : d = new Uint8Array(i2, o2, c), Object.setPrototypeOf(d, u.prototype), d;
  }
  function D(i2) {
    if (u.isBuffer(i2)) {
      const o2 = b(i2.length) | 0, c = l(o2);
      return c.length === 0 || i2.copy(c, 0, 0, o2), c;
    }
    if (i2.length !== void 0)
      return typeof i2.length != "number" || Fn(i2.length) ? l(0) : N(i2);
    if (i2.type === "Buffer" && Array.isArray(i2.data))
      return N(i2.data);
  }
  function b(i2) {
    if (i2 >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return i2 | 0;
  }
  function C(i2) {
    return +i2 != i2 && (i2 = 0), u.alloc(+i2);
  }
  u.isBuffer = function(i2) {
    return i2 != null && i2._isBuffer === true && i2 !== u.prototype;
  }, u.compare = function(i2, o2) {
    if (Ue(i2, Uint8Array) && (i2 = u.from(i2, i2.offset, i2.byteLength)), Ue(o2, Uint8Array) && (o2 = u.from(o2, o2.offset, o2.byteLength)), !u.isBuffer(i2) || !u.isBuffer(o2))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i2 === o2)
      return 0;
    let c = i2.length, d = o2.length;
    for (let y = 0, M = Math.min(c, d); y < M; ++y)
      if (i2[y] !== o2[y]) {
        c = i2[y], d = o2[y];
        break;
      }
    return c < d ? -1 : d < c ? 1 : 0;
  }, u.isEncoding = function(i2) {
    switch (String(i2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, u.concat = function(i2, o2) {
    if (!Array.isArray(i2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i2.length === 0)
      return u.alloc(0);
    let c;
    if (o2 === void 0)
      for (o2 = 0, c = 0; c < i2.length; ++c)
        o2 += i2[c].length;
    const d = u.allocUnsafe(o2);
    let y = 0;
    for (c = 0; c < i2.length; ++c) {
      let M = i2[c];
      if (Ue(M, Uint8Array))
        y + M.length > d.length ? (u.isBuffer(M) || (M = u.from(M)), M.copy(d, y)) : Uint8Array.prototype.set.call(
          d,
          M,
          y
        );
      else if (u.isBuffer(M))
        M.copy(d, y);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      y += M.length;
    }
    return d;
  };
  function w(i2, o2) {
    if (u.isBuffer(i2))
      return i2.length;
    if (ArrayBuffer.isView(i2) || Ue(i2, ArrayBuffer))
      return i2.byteLength;
    if (typeof i2 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i2
      );
    const c = i2.length, d = arguments.length > 2 && arguments[2] === true;
    if (!d && c === 0)
      return 0;
    let y = false;
    for (; ; )
      switch (o2) {
        case "ascii":
        case "latin1":
        case "binary":
          return c;
        case "utf8":
        case "utf-8":
          return Wn(i2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return c * 2;
        case "hex":
          return c >>> 1;
        case "base64":
          return Br(i2).length;
        default:
          if (y)
            return d ? -1 : Wn(i2).length;
          o2 = ("" + o2).toLowerCase(), y = true;
      }
  }
  u.byteLength = w;
  function P(i2, o2, c) {
    let d = false;
    if ((o2 === void 0 || o2 < 0) && (o2 = 0), o2 > this.length || ((c === void 0 || c > this.length) && (c = this.length), c <= 0) || (c >>>= 0, o2 >>>= 0, c <= o2))
      return "";
    for (i2 || (i2 = "utf8"); ; )
      switch (i2) {
        case "hex":
          return Y(this, o2, c);
        case "utf8":
        case "utf-8":
          return Me(this, o2, c);
        case "ascii":
          return O(this, o2, c);
        case "latin1":
        case "binary":
          return S(this, o2, c);
        case "base64":
          return je(this, o2, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return X(this, o2, c);
        default:
          if (d)
            throw new TypeError("Unknown encoding: " + i2);
          i2 = (i2 + "").toLowerCase(), d = true;
      }
  }
  u.prototype._isBuffer = true;
  function x(i2, o2, c) {
    const d = i2[o2];
    i2[o2] = i2[c], i2[c] = d;
  }
  u.prototype.swap16 = function() {
    const i2 = this.length;
    if (i2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let o2 = 0; o2 < i2; o2 += 2)
      x(this, o2, o2 + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const i2 = this.length;
    if (i2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let o2 = 0; o2 < i2; o2 += 4)
      x(this, o2, o2 + 3), x(this, o2 + 1, o2 + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const i2 = this.length;
    if (i2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let o2 = 0; o2 < i2; o2 += 8)
      x(this, o2, o2 + 7), x(this, o2 + 1, o2 + 6), x(this, o2 + 2, o2 + 5), x(this, o2 + 3, o2 + 4);
    return this;
  }, u.prototype.toString = function() {
    const i2 = this.length;
    return i2 === 0 ? "" : arguments.length === 0 ? Me(this, 0, i2) : P.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(i2) {
    if (!u.isBuffer(i2))
      throw new TypeError("Argument must be a Buffer");
    return this === i2 ? true : u.compare(this, i2) === 0;
  }, u.prototype.inspect = function() {
    let i2 = "";
    const o2 = e3.INSPECT_MAX_BYTES;
    return i2 = this.toString("hex", 0, o2).replace(/(.{2})/g, "$1 ").trim(), this.length > o2 && (i2 += " ... "), "<Buffer " + i2 + ">";
  }, r && (u.prototype[r] = u.prototype.inspect), u.prototype.compare = function(i2, o2, c, d, y) {
    if (Ue(i2, Uint8Array) && (i2 = u.from(i2, i2.offset, i2.byteLength)), !u.isBuffer(i2))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i2
      );
    if (o2 === void 0 && (o2 = 0), c === void 0 && (c = i2 ? i2.length : 0), d === void 0 && (d = 0), y === void 0 && (y = this.length), o2 < 0 || c > i2.length || d < 0 || y > this.length)
      throw new RangeError("out of range index");
    if (d >= y && o2 >= c)
      return 0;
    if (d >= y)
      return -1;
    if (o2 >= c)
      return 1;
    if (o2 >>>= 0, c >>>= 0, d >>>= 0, y >>>= 0, this === i2)
      return 0;
    let M = y - d, A = c - o2;
    const _ = Math.min(M, A), oe = this.slice(d, y), G = i2.slice(o2, c);
    for (let W = 0; W < _; ++W)
      if (oe[W] !== G[W]) {
        M = oe[W], A = G[W];
        break;
      }
    return M < A ? -1 : A < M ? 1 : 0;
  };
  function U(i2, o2, c, d, y) {
    if (i2.length === 0)
      return -1;
    if (typeof c == "string" ? (d = c, c = 0) : c > 2147483647 ? c = 2147483647 : c < -2147483648 && (c = -2147483648), c = +c, Fn(c) && (c = y ? 0 : i2.length - 1), c < 0 && (c = i2.length + c), c >= i2.length) {
      if (y)
        return -1;
      c = i2.length - 1;
    } else if (c < 0)
      if (y)
        c = 0;
      else
        return -1;
    if (typeof o2 == "string" && (o2 = u.from(o2, d)), u.isBuffer(o2))
      return o2.length === 0 ? -1 : q(i2, o2, c, d, y);
    if (typeof o2 == "number")
      return o2 = o2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? y ? Uint8Array.prototype.indexOf.call(i2, o2, c) : Uint8Array.prototype.lastIndexOf.call(i2, o2, c) : q(i2, [o2], c, d, y);
    throw new TypeError("val must be string, number or Buffer");
  }
  function q(i2, o2, c, d, y) {
    let M = 1, A = i2.length, _ = o2.length;
    if (d !== void 0 && (d = String(d).toLowerCase(), d === "ucs2" || d === "ucs-2" || d === "utf16le" || d === "utf-16le")) {
      if (i2.length < 2 || o2.length < 2)
        return -1;
      M = 2, A /= 2, _ /= 2, c /= 2;
    }
    function oe(W, te) {
      return M === 1 ? W[te] : W.readUInt16BE(te * M);
    }
    let G;
    if (y) {
      let W = -1;
      for (G = c; G < A; G++)
        if (oe(i2, G) === oe(o2, W === -1 ? 0 : G - W)) {
          if (W === -1 && (W = G), G - W + 1 === _)
            return W * M;
        } else
          W !== -1 && (G -= G - W), W = -1;
    } else
      for (c + _ > A && (c = A - _), G = c; G >= 0; G--) {
        let W = true;
        for (let te = 0; te < _; te++)
          if (oe(i2, G + te) !== oe(o2, te)) {
            W = false;
            break;
          }
        if (W)
          return G;
      }
    return -1;
  }
  u.prototype.includes = function(i2, o2, c) {
    return this.indexOf(i2, o2, c) !== -1;
  }, u.prototype.indexOf = function(i2, o2, c) {
    return U(this, i2, o2, c, true);
  }, u.prototype.lastIndexOf = function(i2, o2, c) {
    return U(this, i2, o2, c, false);
  };
  function k(i2, o2, c, d) {
    c = Number(c) || 0;
    const y = i2.length - c;
    d ? (d = Number(d), d > y && (d = y)) : d = y;
    const M = o2.length;
    d > M / 2 && (d = M / 2);
    let A;
    for (A = 0; A < d; ++A) {
      const _ = parseInt(o2.substr(A * 2, 2), 16);
      if (Fn(_))
        return A;
      i2[c + A] = _;
    }
    return A;
  }
  function ue(i2, o2, c, d) {
    return Vt(Wn(o2, i2.length - c), i2, c, d);
  }
  function ne(i2, o2, c, d) {
    return Vt(ws(o2), i2, c, d);
  }
  function me(i2, o2, c, d) {
    return Vt(Br(o2), i2, c, d);
  }
  function De(i2, o2, c, d) {
    return Vt(Es(o2, i2.length - c), i2, c, d);
  }
  u.prototype.write = function(i2, o2, c, d) {
    if (o2 === void 0)
      d = "utf8", c = this.length, o2 = 0;
    else if (c === void 0 && typeof o2 == "string")
      d = o2, c = this.length, o2 = 0;
    else if (isFinite(o2))
      o2 = o2 >>> 0, isFinite(c) ? (c = c >>> 0, d === void 0 && (d = "utf8")) : (d = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const y = this.length - o2;
    if ((c === void 0 || c > y) && (c = y), i2.length > 0 && (c < 0 || o2 < 0) || o2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let M = false;
    for (; ; )
      switch (d) {
        case "hex":
          return k(this, i2, o2, c);
        case "utf8":
        case "utf-8":
          return ue(this, i2, o2, c);
        case "ascii":
        case "latin1":
        case "binary":
          return ne(this, i2, o2, c);
        case "base64":
          return me(this, i2, o2, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return De(this, i2, o2, c);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), M = true;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function je(i2, o2, c) {
    return o2 === 0 && c === i2.length ? t3.fromByteArray(i2) : t3.fromByteArray(i2.slice(o2, c));
  }
  function Me(i2, o2, c) {
    c = Math.min(i2.length, c);
    const d = [];
    let y = o2;
    for (; y < c; ) {
      const M = i2[y];
      let A = null, _ = M > 239 ? 4 : M > 223 ? 3 : M > 191 ? 2 : 1;
      if (y + _ <= c) {
        let oe, G, W, te;
        switch (_) {
          case 1:
            M < 128 && (A = M);
            break;
          case 2:
            oe = i2[y + 1], (oe & 192) === 128 && (te = (M & 31) << 6 | oe & 63, te > 127 && (A = te));
            break;
          case 3:
            oe = i2[y + 1], G = i2[y + 2], (oe & 192) === 128 && (G & 192) === 128 && (te = (M & 15) << 12 | (oe & 63) << 6 | G & 63, te > 2047 && (te < 55296 || te > 57343) && (A = te));
            break;
          case 4:
            oe = i2[y + 1], G = i2[y + 2], W = i2[y + 3], (oe & 192) === 128 && (G & 192) === 128 && (W & 192) === 128 && (te = (M & 15) << 18 | (oe & 63) << 12 | (G & 63) << 6 | W & 63, te > 65535 && te < 1114112 && (A = te));
        }
      }
      A === null ? (A = 65533, _ = 1) : A > 65535 && (A -= 65536, d.push(A >>> 10 & 1023 | 55296), A = 56320 | A & 1023), d.push(A), y += _;
    }
    return j(d);
  }
  const Te = 4096;
  function j(i2) {
    const o2 = i2.length;
    if (o2 <= Te)
      return String.fromCharCode.apply(String, i2);
    let c = "", d = 0;
    for (; d < o2; )
      c += String.fromCharCode.apply(
        String,
        i2.slice(d, d += Te)
      );
    return c;
  }
  function O(i2, o2, c) {
    let d = "";
    c = Math.min(i2.length, c);
    for (let y = o2; y < c; ++y)
      d += String.fromCharCode(i2[y] & 127);
    return d;
  }
  function S(i2, o2, c) {
    let d = "";
    c = Math.min(i2.length, c);
    for (let y = o2; y < c; ++y)
      d += String.fromCharCode(i2[y]);
    return d;
  }
  function Y(i2, o2, c) {
    const d = i2.length;
    (!o2 || o2 < 0) && (o2 = 0), (!c || c < 0 || c > d) && (c = d);
    let y = "";
    for (let M = o2; M < c; ++M)
      y += bs[i2[M]];
    return y;
  }
  function X(i2, o2, c) {
    const d = i2.slice(o2, c);
    let y = "";
    for (let M = 0; M < d.length - 1; M += 2)
      y += String.fromCharCode(d[M] + d[M + 1] * 256);
    return y;
  }
  u.prototype.slice = function(i2, o2) {
    const c = this.length;
    i2 = ~~i2, o2 = o2 === void 0 ? c : ~~o2, i2 < 0 ? (i2 += c, i2 < 0 && (i2 = 0)) : i2 > c && (i2 = c), o2 < 0 ? (o2 += c, o2 < 0 && (o2 = 0)) : o2 > c && (o2 = c), o2 < i2 && (o2 = i2);
    const d = this.subarray(i2, o2);
    return Object.setPrototypeOf(d, u.prototype), d;
  };
  function z(i2, o2, c) {
    if (i2 % 1 !== 0 || i2 < 0)
      throw new RangeError("offset is not uint");
    if (i2 + o2 > c)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(i2, o2, c) {
    i2 = i2 >>> 0, o2 = o2 >>> 0, c || z(i2, o2, this.length);
    let d = this[i2], y = 1, M = 0;
    for (; ++M < o2 && (y *= 256); )
      d += this[i2 + M] * y;
    return d;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(i2, o2, c) {
    i2 = i2 >>> 0, o2 = o2 >>> 0, c || z(i2, o2, this.length);
    let d = this[i2 + --o2], y = 1;
    for (; o2 > 0 && (y *= 256); )
      d += this[i2 + --o2] * y;
    return d;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 1, this.length), this[i2];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 2, this.length), this[i2] | this[i2 + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 2, this.length), this[i2] << 8 | this[i2 + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), (this[i2] | this[i2 + 1] << 8 | this[i2 + 2] << 16) + this[i2 + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), this[i2] * 16777216 + (this[i2 + 1] << 16 | this[i2 + 2] << 8 | this[i2 + 3]);
  }, u.prototype.readBigUInt64LE = Ge(function(i2) {
    i2 = i2 >>> 0, ft(i2, "offset");
    const o2 = this[i2], c = this[i2 + 7];
    (o2 === void 0 || c === void 0) && St(i2, this.length - 8);
    const d = o2 + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 24, y = this[++i2] + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + c * 2 ** 24;
    return BigInt(d) + (BigInt(y) << BigInt(32));
  }), u.prototype.readBigUInt64BE = Ge(function(i2) {
    i2 = i2 >>> 0, ft(i2, "offset");
    const o2 = this[i2], c = this[i2 + 7];
    (o2 === void 0 || c === void 0) && St(i2, this.length - 8);
    const d = o2 * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + this[++i2], y = this[++i2] * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + c;
    return (BigInt(d) << BigInt(32)) + BigInt(y);
  }), u.prototype.readIntLE = function(i2, o2, c) {
    i2 = i2 >>> 0, o2 = o2 >>> 0, c || z(i2, o2, this.length);
    let d = this[i2], y = 1, M = 0;
    for (; ++M < o2 && (y *= 256); )
      d += this[i2 + M] * y;
    return y *= 128, d >= y && (d -= Math.pow(2, 8 * o2)), d;
  }, u.prototype.readIntBE = function(i2, o2, c) {
    i2 = i2 >>> 0, o2 = o2 >>> 0, c || z(i2, o2, this.length);
    let d = o2, y = 1, M = this[i2 + --d];
    for (; d > 0 && (y *= 256); )
      M += this[i2 + --d] * y;
    return y *= 128, M >= y && (M -= Math.pow(2, 8 * o2)), M;
  }, u.prototype.readInt8 = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 1, this.length), this[i2] & 128 ? (255 - this[i2] + 1) * -1 : this[i2];
  }, u.prototype.readInt16LE = function(i2, o2) {
    i2 = i2 >>> 0, o2 || z(i2, 2, this.length);
    const c = this[i2] | this[i2 + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, u.prototype.readInt16BE = function(i2, o2) {
    i2 = i2 >>> 0, o2 || z(i2, 2, this.length);
    const c = this[i2 + 1] | this[i2] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, u.prototype.readInt32LE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), this[i2] | this[i2 + 1] << 8 | this[i2 + 2] << 16 | this[i2 + 3] << 24;
  }, u.prototype.readInt32BE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), this[i2] << 24 | this[i2 + 1] << 16 | this[i2 + 2] << 8 | this[i2 + 3];
  }, u.prototype.readBigInt64LE = Ge(function(i2) {
    i2 = i2 >>> 0, ft(i2, "offset");
    const o2 = this[i2], c = this[i2 + 7];
    (o2 === void 0 || c === void 0) && St(i2, this.length - 8);
    const d = this[i2 + 4] + this[i2 + 5] * 2 ** 8 + this[i2 + 6] * 2 ** 16 + (c << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(o2 + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 24);
  }), u.prototype.readBigInt64BE = Ge(function(i2) {
    i2 = i2 >>> 0, ft(i2, "offset");
    const o2 = this[i2], c = this[i2 + 7];
    (o2 === void 0 || c === void 0) && St(i2, this.length - 8);
    const d = (o2 << 24) + // Overflow
    this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + this[++i2];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++i2] * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + c);
  }), u.prototype.readFloatLE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), n2.read(this, i2, true, 23, 4);
  }, u.prototype.readFloatBE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 4, this.length), n2.read(this, i2, false, 23, 4);
  }, u.prototype.readDoubleLE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 8, this.length), n2.read(this, i2, true, 52, 8);
  }, u.prototype.readDoubleBE = function(i2, o2) {
    return i2 = i2 >>> 0, o2 || z(i2, 8, this.length), n2.read(this, i2, false, 52, 8);
  };
  function ee(i2, o2, c, d, y, M) {
    if (!u.isBuffer(i2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (o2 > y || o2 < M)
      throw new RangeError('"value" argument is out of bounds');
    if (c + d > i2.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(i2, o2, c, d) {
    if (i2 = +i2, o2 = o2 >>> 0, c = c >>> 0, !d) {
      const A = Math.pow(2, 8 * c) - 1;
      ee(this, i2, o2, c, A, 0);
    }
    let y = 1, M = 0;
    for (this[o2] = i2 & 255; ++M < c && (y *= 256); )
      this[o2 + M] = i2 / y & 255;
    return o2 + c;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(i2, o2, c, d) {
    if (i2 = +i2, o2 = o2 >>> 0, c = c >>> 0, !d) {
      const A = Math.pow(2, 8 * c) - 1;
      ee(this, i2, o2, c, A, 0);
    }
    let y = c - 1, M = 1;
    for (this[o2 + y] = i2 & 255; --y >= 0 && (M *= 256); )
      this[o2 + y] = i2 / M & 255;
    return o2 + c;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 1, 255, 0), this[o2] = i2 & 255, o2 + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 2, 65535, 0), this[o2] = i2 & 255, this[o2 + 1] = i2 >>> 8, o2 + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 2, 65535, 0), this[o2] = i2 >>> 8, this[o2 + 1] = i2 & 255, o2 + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 4, 4294967295, 0), this[o2 + 3] = i2 >>> 24, this[o2 + 2] = i2 >>> 16, this[o2 + 1] = i2 >>> 8, this[o2] = i2 & 255, o2 + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 4, 4294967295, 0), this[o2] = i2 >>> 24, this[o2 + 1] = i2 >>> 16, this[o2 + 2] = i2 >>> 8, this[o2 + 3] = i2 & 255, o2 + 4;
  };
  function ct(i2, o2, c, d, y) {
    Qr(o2, d, y, i2, c, 7);
    let M = Number(o2 & BigInt(4294967295));
    i2[c++] = M, M = M >> 8, i2[c++] = M, M = M >> 8, i2[c++] = M, M = M >> 8, i2[c++] = M;
    let A = Number(o2 >> BigInt(32) & BigInt(4294967295));
    return i2[c++] = A, A = A >> 8, i2[c++] = A, A = A >> 8, i2[c++] = A, A = A >> 8, i2[c++] = A, c;
  }
  function He(i2, o2, c, d, y) {
    Qr(o2, d, y, i2, c, 7);
    let M = Number(o2 & BigInt(4294967295));
    i2[c + 7] = M, M = M >> 8, i2[c + 6] = M, M = M >> 8, i2[c + 5] = M, M = M >> 8, i2[c + 4] = M;
    let A = Number(o2 >> BigInt(32) & BigInt(4294967295));
    return i2[c + 3] = A, A = A >> 8, i2[c + 2] = A, A = A >> 8, i2[c + 1] = A, A = A >> 8, i2[c] = A, c + 8;
  }
  u.prototype.writeBigUInt64LE = Ge(function(i2, o2 = 0) {
    return ct(this, i2, o2, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = Ge(function(i2, o2 = 0) {
    return He(this, i2, o2, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(i2, o2, c, d) {
    if (i2 = +i2, o2 = o2 >>> 0, !d) {
      const _ = Math.pow(2, 8 * c - 1);
      ee(this, i2, o2, c, _ - 1, -_);
    }
    let y = 0, M = 1, A = 0;
    for (this[o2] = i2 & 255; ++y < c && (M *= 256); )
      i2 < 0 && A === 0 && this[o2 + y - 1] !== 0 && (A = 1), this[o2 + y] = (i2 / M >> 0) - A & 255;
    return o2 + c;
  }, u.prototype.writeIntBE = function(i2, o2, c, d) {
    if (i2 = +i2, o2 = o2 >>> 0, !d) {
      const _ = Math.pow(2, 8 * c - 1);
      ee(this, i2, o2, c, _ - 1, -_);
    }
    let y = c - 1, M = 1, A = 0;
    for (this[o2 + y] = i2 & 255; --y >= 0 && (M *= 256); )
      i2 < 0 && A === 0 && this[o2 + y + 1] !== 0 && (A = 1), this[o2 + y] = (i2 / M >> 0) - A & 255;
    return o2 + c;
  }, u.prototype.writeInt8 = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 1, 127, -128), i2 < 0 && (i2 = 255 + i2 + 1), this[o2] = i2 & 255, o2 + 1;
  }, u.prototype.writeInt16LE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 2, 32767, -32768), this[o2] = i2 & 255, this[o2 + 1] = i2 >>> 8, o2 + 2;
  }, u.prototype.writeInt16BE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 2, 32767, -32768), this[o2] = i2 >>> 8, this[o2 + 1] = i2 & 255, o2 + 2;
  }, u.prototype.writeInt32LE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 4, 2147483647, -2147483648), this[o2] = i2 & 255, this[o2 + 1] = i2 >>> 8, this[o2 + 2] = i2 >>> 16, this[o2 + 3] = i2 >>> 24, o2 + 4;
  }, u.prototype.writeInt32BE = function(i2, o2, c) {
    return i2 = +i2, o2 = o2 >>> 0, c || ee(this, i2, o2, 4, 2147483647, -2147483648), i2 < 0 && (i2 = 4294967295 + i2 + 1), this[o2] = i2 >>> 24, this[o2 + 1] = i2 >>> 16, this[o2 + 2] = i2 >>> 8, this[o2 + 3] = i2 & 255, o2 + 4;
  }, u.prototype.writeBigInt64LE = Ge(function(i2, o2 = 0) {
    return ct(this, i2, o2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = Ge(function(i2, o2 = 0) {
    return He(this, i2, o2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ke(i2, o2, c, d, y, M) {
    if (c + d > i2.length)
      throw new RangeError("Index out of range");
    if (c < 0)
      throw new RangeError("Index out of range");
  }
  function _e(i2, o2, c, d, y) {
    return o2 = +o2, c = c >>> 0, y || Ke(i2, o2, c, 4), n2.write(i2, o2, c, d, 23, 4), c + 4;
  }
  u.prototype.writeFloatLE = function(i2, o2, c) {
    return _e(this, i2, o2, true, c);
  }, u.prototype.writeFloatBE = function(i2, o2, c) {
    return _e(this, i2, o2, false, c);
  };
  function kr(i2, o2, c, d, y) {
    return o2 = +o2, c = c >>> 0, y || Ke(i2, o2, c, 8), n2.write(i2, o2, c, d, 52, 8), c + 8;
  }
  u.prototype.writeDoubleLE = function(i2, o2, c) {
    return kr(this, i2, o2, true, c);
  }, u.prototype.writeDoubleBE = function(i2, o2, c) {
    return kr(this, i2, o2, false, c);
  }, u.prototype.copy = function(i2, o2, c, d) {
    if (!u.isBuffer(i2))
      throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !d && d !== 0 && (d = this.length), o2 >= i2.length && (o2 = i2.length), o2 || (o2 = 0), d > 0 && d < c && (d = c), d === c || i2.length === 0 || this.length === 0)
      return 0;
    if (o2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), i2.length - o2 < d - c && (d = i2.length - o2 + c);
    const y = d - c;
    return this === i2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(o2, c, d) : Uint8Array.prototype.set.call(
      i2,
      this.subarray(c, d),
      o2
    ), y;
  }, u.prototype.fill = function(i2, o2, c, d) {
    if (typeof i2 == "string") {
      if (typeof o2 == "string" ? (d = o2, o2 = 0, c = this.length) : typeof c == "string" && (d = c, c = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !u.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (i2.length === 1) {
        const M = i2.charCodeAt(0);
        (d === "utf8" && M < 128 || d === "latin1") && (i2 = M);
      }
    } else
      typeof i2 == "number" ? i2 = i2 & 255 : typeof i2 == "boolean" && (i2 = Number(i2));
    if (o2 < 0 || this.length < o2 || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= o2)
      return this;
    o2 = o2 >>> 0, c = c === void 0 ? this.length : c >>> 0, i2 || (i2 = 0);
    let y;
    if (typeof i2 == "number")
      for (y = o2; y < c; ++y)
        this[y] = i2;
    else {
      const M = u.isBuffer(i2) ? i2 : u.from(i2, d), A = M.length;
      if (A === 0)
        throw new TypeError('The value "' + i2 + '" is invalid for argument "value"');
      for (y = 0; y < c - o2; ++y)
        this[y + o2] = M[y % A];
    }
    return this;
  };
  const lt = {};
  function Bn(i2, o2, c) {
    lt[i2] = class extends c {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: o2.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i2}]`, this.stack, delete this.name;
      }
      get code() {
        return i2;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: d,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i2}]: ${this.message}`;
      }
    };
  }
  Bn(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(i2) {
      return i2 ? `${i2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Bn(
    "ERR_INVALID_ARG_TYPE",
    function(i2, o2) {
      return `The "${i2}" argument must be of type number. Received type ${typeof o2}`;
    },
    TypeError
  ), Bn(
    "ERR_OUT_OF_RANGE",
    function(i2, o2, c) {
      let d = `The value of "${i2}" is out of range.`, y = c;
      return Number.isInteger(c) && Math.abs(c) > 2 ** 32 ? y = Pr(String(c)) : typeof c == "bigint" && (y = String(c), (c > BigInt(2) ** BigInt(32) || c < -(BigInt(2) ** BigInt(32))) && (y = Pr(y)), y += "n"), d += ` It must be ${o2}. Received ${y}`, d;
    },
    RangeError
  );
  function Pr(i2) {
    let o2 = "", c = i2.length;
    const d = i2[0] === "-" ? 1 : 0;
    for (; c >= d + 4; c -= 3)
      o2 = `_${i2.slice(c - 3, c)}${o2}`;
    return `${i2.slice(0, c)}${o2}`;
  }
  function ms(i2, o2, c) {
    ft(o2, "offset"), (i2[o2] === void 0 || i2[o2 + c] === void 0) && St(o2, i2.length - (c + 1));
  }
  function Qr(i2, o2, c, d, y, M) {
    if (i2 > c || i2 < o2) {
      const A = typeof o2 == "bigint" ? "n" : "";
      let _;
      throw o2 === 0 || o2 === BigInt(0) ? _ = `>= 0${A} and < 2${A} ** ${(M + 1) * 8}${A}` : _ = `>= -(2${A} ** ${(M + 1) * 8 - 1}${A}) and < 2 ** ${(M + 1) * 8 - 1}${A}`, new lt.ERR_OUT_OF_RANGE("value", _, i2);
    }
    ms(d, y, M);
  }
  function ft(i2, o2) {
    if (typeof i2 != "number")
      throw new lt.ERR_INVALID_ARG_TYPE(o2, "number", i2);
  }
  function St(i2, o2, c) {
    throw Math.floor(i2) !== i2 ? (ft(i2, c), new lt.ERR_OUT_OF_RANGE("offset", "an integer", i2)) : o2 < 0 ? new lt.ERR_BUFFER_OUT_OF_BOUNDS() : new lt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${o2}`,
      i2
    );
  }
  const As = /[^+/0-9A-Za-z-_]/g;
  function vs(i2) {
    if (i2 = i2.split("=")[0], i2 = i2.trim().replace(As, ""), i2.length < 2)
      return "";
    for (; i2.length % 4 !== 0; )
      i2 = i2 + "=";
    return i2;
  }
  function Wn(i2, o2) {
    o2 = o2 || 1 / 0;
    let c;
    const d = i2.length;
    let y = null;
    const M = [];
    for (let A = 0; A < d; ++A) {
      if (c = i2.charCodeAt(A), c > 55295 && c < 57344) {
        if (!y) {
          if (c > 56319) {
            (o2 -= 3) > -1 && M.push(239, 191, 189);
            continue;
          } else if (A + 1 === d) {
            (o2 -= 3) > -1 && M.push(239, 191, 189);
            continue;
          }
          y = c;
          continue;
        }
        if (c < 56320) {
          (o2 -= 3) > -1 && M.push(239, 191, 189), y = c;
          continue;
        }
        c = (y - 55296 << 10 | c - 56320) + 65536;
      } else
        y && (o2 -= 3) > -1 && M.push(239, 191, 189);
      if (y = null, c < 128) {
        if ((o2 -= 1) < 0)
          break;
        M.push(c);
      } else if (c < 2048) {
        if ((o2 -= 2) < 0)
          break;
        M.push(
          c >> 6 | 192,
          c & 63 | 128
        );
      } else if (c < 65536) {
        if ((o2 -= 3) < 0)
          break;
        M.push(
          c >> 12 | 224,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else if (c < 1114112) {
        if ((o2 -= 4) < 0)
          break;
        M.push(
          c >> 18 | 240,
          c >> 12 & 63 | 128,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return M;
  }
  function ws(i2) {
    const o2 = [];
    for (let c = 0; c < i2.length; ++c)
      o2.push(i2.charCodeAt(c) & 255);
    return o2;
  }
  function Es(i2, o2) {
    let c, d, y;
    const M = [];
    for (let A = 0; A < i2.length && !((o2 -= 2) < 0); ++A)
      c = i2.charCodeAt(A), d = c >> 8, y = c % 256, M.push(y), M.push(d);
    return M;
  }
  function Br(i2) {
    return t3.toByteArray(vs(i2));
  }
  function Vt(i2, o2, c, d) {
    let y;
    for (y = 0; y < d && !(y + c >= o2.length || y >= i2.length); ++y)
      o2[y + c] = i2[y];
    return y;
  }
  function Ue(i2, o2) {
    return i2 instanceof o2 || i2 != null && i2.constructor != null && i2.constructor.name != null && i2.constructor.name === o2.name;
  }
  function Fn(i2) {
    return i2 !== i2;
  }
  const bs = function() {
    const i2 = "0123456789abcdef", o2 = new Array(256);
    for (let c = 0; c < 16; ++c) {
      const d = c * 16;
      for (let y = 0; y < 16; ++y)
        o2[d + y] = i2[c] + i2[y];
    }
    return o2;
  }();
  function Ge(i2) {
    return typeof BigInt > "u" ? Ds : i2;
  }
  function Ds() {
    throw new Error("BigInt not supported");
  }
})(nn);
var mt = class _mt {
  static toString(t3, n2 = "utf8") {
    return nn.Buffer.from(t3).toString(n2);
  }
  static toHex(t3) {
    return _mt.toString(t3, "hex");
  }
  static toBase64(t3) {
    return _mt.toString(t3, "base64");
  }
  static fromHex(t3) {
    return _mt.from(t3, "hex");
  }
  static fromBase64(t3) {
    return _mt.from(t3, "base64");
  }
  static from(t3, n2 = "utf8") {
    return Uint8Array.from(nn.Buffer.from(t3, n2));
  }
  static fromArrayLike(t3) {
    const n2 = Object.keys(t3).length, r = new Uint8Array(n2);
    for (let s = 0; s < n2; s++)
      r[s] = t3[s] || 0;
    return r;
  }
  static ensureUint8Array(t3) {
    return typeof t3 == "string" ? Uint8Array.from(nn.Buffer.from(t3, "base64")) : t3 instanceof Uint8Array ? t3 : typeof t3 == "object" && t3 !== null && !Array.isArray(t3) ? this.fromArrayLike(t3) : Uint8Array.from(t3);
  }
  static bytesEqual(t3, n2) {
    if (t3 === n2)
      return true;
    if (t3.length !== n2.length)
      return false;
    for (let r = 0; r < t3.length; r++)
      if (t3[r] !== n2[r])
        return false;
    return true;
  }
};
function En(e3, t3) {
  return Object.prototype.hasOwnProperty.call(e3, t3);
}
async function Ca(e3, t3) {
  let n2;
  if (En(e3, "bytes"))
    n2 = e3.bytes;
  else if (En(e3, "messageBytes"))
    n2 = e3.messageBytes;
  else
    throw new Error(
      "input should be either SuiSignPersonalMessageOutput or SuiSignMessageOutput"
    );
  try {
    const r = await verifyPersonalMessageSignature(
      Ti(n2),
      e3.signature
    );
    return mt.bytesEqual(r.toRawBytes(), t3);
  } catch {
    return false;
  }
}
function Al(e3) {
  return new TextDecoder().decode(Ti(e3));
}
var ie = ((e3) => (e3.UNKNOWN_ERROR = "UNKNOWN_ERROR", e3.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", e3.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", e3.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", e3.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", e3.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", e3.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", e3.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", e3.WALLET__SIGN_PERSONAL_MSG_ERROR = "WALLET.SIGN_PERSONAL_MSG_ERROR", e3.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", e3.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", e3.WALLET__REPORT_EFFECTS_ERROR = "WALLET.REPORT_EFFECTS_ERROR", e3))(ie || {});
var Si = class extends Error {
  constructor(t3, n2 = ie.UNKNOWN_ERROR, r) {
    super(t3), fe2(this, "code"), fe2(this, "details"), this.details = r, this.code = n2, this.message = this.formatErrorStr(n2, t3, r);
  }
  formatErrorStr(t3, n2, r) {
    let s = `[${this.code}] ${n2}`;
    return r && (s += " | details: " + JSON.stringify(r)), s;
  }
};
var re = class extends Si {
  constructor(t3 = "kit unknown error", n2 = ie.KIT__UNKNOWN_ERROR, r) {
    super(t3, n2, r);
  }
};
var Se = class extends Si {
  constructor(t3 = "wallet unknown error", n2 = ie.WALLET__UNKNOWN_ERROR, r) {
    super(t3, n2, r);
  }
};
var Ci = class extends Se {
  constructor(t3) {
    super(`wallet does not implement function: ${t3}`, ie.WALLET__METHOD_NOT_IMPLEMENTED_ERROR);
  }
};
var Tr = ((e3) => (e3.EXTENSION = "EXTENSION", e3.WEB = "WEB", e3))(Tr || {});
var K = ((e3) => (e3.STANDARD__CONNECT = "standard:connect", e3.STANDARD__DISCONNECT = "standard:disconnect", e3.STANDARD__EVENTS = "standard:events", e3.SUI__SIGN_AND_EXECUTE_TRANSACTION = "sui:signAndExecuteTransaction", e3.SUI__SIGN_TRANSACTION = "sui:signTransaction", e3.SUI__SIGN_PERSONAL_MESSAGE = "sui:signPersonalMessage", e3.SUI__REPORT_TRANSACTION_EFFECTS = "sui:reportTransactionEffects", e3.SUI__SIGN_MESSAGE = "sui:signMessage", e3.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", e3.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", e3))(K || {});
var Oa = class {
  constructor(t3) {
    fe2(this, "standardWalletAdapter"), this.standardWalletAdapter = t3;
  }
  get name() {
    return this.standardWalletAdapter.name;
  }
  get icon() {
    return this.standardWalletAdapter.icon;
  }
  get version() {
    return this.standardWalletAdapter.version;
  }
  get accounts() {
    return this.standardWalletAdapter.accounts;
  }
  get chains() {
    return this.standardWalletAdapter.chains;
  }
  get features() {
    return this.standardWalletAdapter.features;
  }
  async connect(t3) {
    const n2 = this.getFeature(
      K.STANDARD__CONNECT
    );
    try {
      return await n2.connect(t3);
    } catch (r) {
      const { code: s, message: a3, details: l } = wo(
        r,
        this.name
      );
      throw new Se(a3, s, l);
    }
  }
  async disconnect() {
    const t3 = this.getFeature(
      K.STANDARD__DISCONNECT
    );
    try {
      return await t3.disconnect();
    } catch (n2) {
      throw new Se(
        n2.message,
        ie.WALLET__DISCONNECT_ERROR
      );
    }
  }
  on(t3, n2) {
    const r = this.getFeature(
      K.STANDARD__EVENTS
    );
    try {
      return r.on(t3, n2);
    } catch (s) {
      throw new Se(
        s.message,
        ie.WALLET__LISTEN_TO_EVENT_ERROR
      );
    }
  }
  async signAndExecuteTransactionBlock(t3) {
    const n2 = this.getFeature(K.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
    try {
      return await n2.signAndExecuteTransactionBlock(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_TX_ERROR
      );
    }
  }
  signTransaction(t3) {
    const n2 = this.getFeature(K.SUI__SIGN_TRANSACTION);
    try {
      return n2.signTransaction(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_TX_ERROR
      );
    }
  }
  /**
   * @deprecated use signTransaction instead
   */
  signTransactionBlock(t3) {
    const n2 = this.getFeature(K.SUI__SIGN_TRANSACTION_BLOCK);
    try {
      return n2.signTransactionBlock(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_TX_ERROR
      );
    }
  }
  async signAndExecuteTransaction(t3) {
    const n2 = this.getFeature(K.SUI__SIGN_AND_EXECUTE_TRANSACTION);
    try {
      return await n2.signAndExecuteTransaction(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_TX_ERROR
      );
    }
  }
  reportTransactionEffects(t3) {
    const n2 = this.getFeature(K.SUI__REPORT_TRANSACTION_EFFECTS);
    try {
      return n2.reportTransactionEffects(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__REPORT_EFFECTS_ERROR
      );
    }
  }
  async signMessage(t3) {
    const n2 = this.getFeature(
      K.SUI__SIGN_MESSAGE
    );
    try {
      return await n2.signMessage(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_MSG_ERROR
      );
    }
  }
  signPersonalMessage(t3) {
    const n2 = this.getFeature(K.SUI__SIGN_PERSONAL_MESSAGE);
    try {
      return n2.signPersonalMessage(t3);
    } catch (r) {
      throw new Se(
        r.message,
        ie.WALLET__SIGN_PERSONAL_MSG_ERROR
      );
    }
  }
  hasFeature(t3) {
    const { features: n2 } = this.standardWalletAdapter;
    return En(n2, t3);
  }
  getFeature(t3) {
    const { features: n2 } = this.standardWalletAdapter;
    if (!En(n2, t3))
      throw new Ci(t3);
    return n2[t3];
  }
};
var xa = function(e3, t3, n2, r) {
  if (typeof t3 == "function" ? e3 !== t3 || true : !t3.has(e3))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n2 === "m" ? r : n2 === "a" ? r.call(e3) : r ? r.value : t3.get(e3);
};
var za = function(e3, t3, n2, r, s) {
  if (typeof t3 == "function" ? e3 !== t3 || true : !t3.has(e3))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t3.set(e3, n2), n2;
};
var rn;
var qt;
var Rn = /* @__PURE__ */ new Set();
function Ra(e3) {
  Ut = void 0, Rn.add(e3);
}
function Ua(e3) {
  Ut = void 0, Rn.delete(e3);
}
var At = {};
function Oi() {
  if (qt || (qt = Object.freeze({ register: _r, get: ka, on: Pa }), typeof window > "u"))
    return qt;
  const e3 = Object.freeze({ register: _r });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: t3 }) => t3(e3));
  } catch (t3) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, t3);
  }
  try {
    window.dispatchEvent(new Qa(e3));
  } catch (t3) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, t3);
  }
  return qt;
}
function _r(...e3) {
  var _a2;
  return e3 = e3.filter((t3) => !Rn.has(t3)), e3.length ? (e3.forEach((t3) => Ra(t3)), (_a2 = At.register) == null ? void 0 : _a2.forEach((t3) => Gr(() => t3(...e3))), function() {
    var _a3;
    e3.forEach((t3) => Ua(t3)), (_a3 = At.unregister) == null ? void 0 : _a3.forEach((t3) => Gr(() => t3(...e3)));
  }) : () => {
  };
}
var Ut;
function ka() {
  return Ut || (Ut = [...Rn]), Ut;
}
function Pa(e3, t3) {
  var _a2;
  return ((_a2 = At[e3]) == null ? void 0 : _a2.push(t3)) || (At[e3] = [t3]), function() {
    var _a3;
    At[e3] = (_a3 = At[e3]) == null ? void 0 : _a3.filter((n2) => t3 !== n2);
  };
}
function Gr(e3) {
  try {
    e3();
  } catch (t3) {
    console.error(t3);
  }
}
var Qa = class extends Event {
  get detail() {
    return xa(this, rn, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(t3) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    }), rn.set(this, void 0), za(this, rn, t3);
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
rn = /* @__PURE__ */ new WeakMap();
var ht = function(e3, t3, n2, r) {
  if (typeof t3 == "function" ? e3 !== t3 || true : !t3.has(e3))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n2 === "m" ? r : n2 === "a" ? r.call(e3) : r ? r.value : t3.get(e3);
};
var gt = function(e3, t3, n2, r, s) {
  if (typeof t3 == "function" ? e3 !== t3 || true : !t3.has(e3))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t3.set(e3, n2), n2;
};
var sn;
var an;
var on;
var un;
var cn;
var ln;
var Lr = class _Lr {
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
  get address() {
    return ht(this, sn, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
  get publicKey() {
    return ht(this, an, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
  get chains() {
    return ht(this, on, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
  get features() {
    return ht(this, un, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
  get label() {
    return ht(this, cn, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
  get icon() {
    return ht(this, ln, "f");
  }
  /**
   * Create and freeze a read-only account.
   *
   * @param account Account to copy properties from.
   */
  constructor(t3) {
    sn.set(this, void 0), an.set(this, void 0), on.set(this, void 0), un.set(this, void 0), cn.set(this, void 0), ln.set(this, void 0), new.target === _Lr && Object.freeze(this), gt(this, sn, t3.address), gt(this, an, t3.publicKey.slice()), gt(this, on, t3.chains.slice()), gt(this, un, t3.features.slice()), gt(this, cn, t3.label), gt(this, ln, t3.icon);
  }
};
sn = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakMap(), on = /* @__PURE__ */ new WeakMap(), un = /* @__PURE__ */ new WeakMap(), cn = /* @__PURE__ */ new WeakMap(), ln = /* @__PURE__ */ new WeakMap();
function Ba(e3) {
  return K.STANDARD__CONNECT in e3.features && K.STANDARD__EVENTS in e3.features && (K.SUI__SIGN_TRANSACTION in e3.features || K.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK in e3.features);
}
var Wa = class {
  constructor() {
    fe2(this, "walletStandardSdk"), fe2(this, "walletAdapterMap"), fe2(this, "clearOnRegisterListener"), fe2(this, "subscriptions", /* @__PURE__ */ new Set()), this.walletStandardSdk = null, this.clearOnRegisterListener = null, this.walletAdapterMap = /* @__PURE__ */ new Map();
  }
  activate() {
    this.walletStandardSdk = Oi(), this.walletStandardSdk.get().forEach((t3) => {
      this.setDetectedWalletAdapters(t3);
    }), this.clearOnRegisterListener = this.walletStandardSdk.on(
      "register",
      (...t3) => {
        t3.forEach((n2) => {
          this.setDetectedWalletAdapters(n2);
        }), this.notifySubscribers();
      }
    );
  }
  deactivate() {
    this.clearOnRegisterListener && this.clearOnRegisterListener(), this.walletAdapterMap.clear();
  }
  getDetectedWalletAdapters() {
    return Array.from(this.walletAdapterMap.values());
  }
  subscribe(t3) {
    return this.subscriptions.add(t3), () => {
      this.subscriptions.delete(t3);
    };
  }
  notifySubscribers() {
    this.subscriptions.forEach((t3) => {
      t3(this.getDetectedWalletAdapters());
    });
  }
  setDetectedWalletAdapters(t3) {
    Ba(t3) && (this.walletAdapterMap.has(t3.name) || this.walletAdapterMap.set(t3.name, new Oa(t3)));
  }
};
var xi = "sui:mainnet";
function Fa(e3) {
  return { all: e3 = e3 || /* @__PURE__ */ new Map(), on: function(t3, n2) {
    var r = e3.get(t3);
    r ? r.push(n2) : e3.set(t3, [n2]);
  }, off: function(t3, n2) {
    var r = e3.get(t3);
    r && (n2 ? r.splice(r.indexOf(n2) >>> 0, 1) : e3.set(t3, []));
  }, emit: function(t3, n2) {
    var r = e3.get(t3);
    r && r.slice().map(function(s) {
      s(n2);
    }), (r = e3.get("*")) && r.slice().map(function(s) {
      s(t3, n2);
    });
  } };
}
var Ya = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
var qn;
function _a(e3) {
  return {
    lang: (e3 == null ? void 0 : e3.lang) ?? (qn == null ? void 0 : qn.lang),
    message: e3 == null ? void 0 : e3.message,
    abortEarly: (e3 == null ? void 0 : e3.abortEarly) ?? (qn == null ? void 0 : qn.abortEarly),
    abortPipeEarly: (e3 == null ? void 0 : e3.abortPipeEarly) ?? (qn == null ? void 0 : qn.abortPipeEarly)
  };
}
var Ga;
function Za(e3) {
  return Ga == null ? void 0 : Ga.get(e3);
}
var Va;
function qa(e3) {
  return Va == null ? void 0 : Va.get(e3);
}
var Xa;
function Ha(e3, t3) {
  var _a2;
  return (_a2 = Xa == null ? void 0 : Xa.get(e3)) == null ? void 0 : _a2.get(t3);
}
function zi(e3) {
  var _a2, _b;
  const t3 = typeof e3;
  return t3 === "string" ? `"${e3}"` : t3 === "number" || t3 === "bigint" || t3 === "boolean" ? `${e3}` : t3 === "object" || t3 === "function" ? (e3 && ((_b = (_a2 = Object.getPrototypeOf(e3)) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name)) ?? "null" : t3;
}
function at(e3, t3, n2, r, s) {
  const a3 = s && "input" in s ? s.input : n2.value, l = (s == null ? void 0 : s.expected) ?? e3.expects ?? null, u = (s == null ? void 0 : s.received) ?? zi(a3), f = {
    kind: e3.kind,
    type: e3.type,
    input: a3,
    expected: l,
    received: u,
    message: `Invalid ${t3}: ${l ? `Expected ${l} but r` : "R"}eceived ${u}`,
    // @ts-expect-error
    requirement: e3.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, h = e3.kind === "schema", g = (s == null ? void 0 : s.message) ?? // @ts-expect-error
  e3.message ?? Ha(e3.reference, f.lang) ?? (h ? qa(f.lang) : null) ?? r.message ?? Za(f.lang);
  g && (f.message = typeof g == "function" ? g(f) : g), h && (n2.typed = false), n2.issues ? n2.issues.push(f) : n2.issues = [f];
}
function Ri(e3) {
  return {
    kind: "validation",
    type: "url",
    reference: Ri,
    async: false,
    expects: null,
    requirement(t3) {
      try {
        return new URL(t3), true;
      } catch {
        return false;
      }
    },
    message: e3,
    _run(t3, n2) {
      return t3.typed && !this.requirement(t3.value) && at(this, "URL", t3, n2), t3;
    }
  };
}
function Sr(e3) {
  return {
    kind: "validation",
    type: "uuid",
    reference: Sr,
    async: false,
    expects: null,
    requirement: Ya,
    message: e3,
    _run(t3, n2) {
      return t3.typed && !this.requirement.test(t3.value) && at(this, "UUID", t3, n2), t3;
    }
  };
}
function Ka(e3, t3, n2) {
  return typeof e3.default == "function" ? (
    // @ts-expect-error
    e3.default(t3, n2)
  ) : (
    // @ts-expect-error
    e3.default
  );
}
function Be(e3, t3) {
  return {
    kind: "schema",
    type: "literal",
    reference: Be,
    expects: zi(e3),
    async: false,
    literal: e3,
    message: t3,
    _run(n2, r) {
      return n2.value === this.literal ? n2.typed = true : at(this, "type", n2, r), n2;
    }
  };
}
function xe(e3, t3) {
  return {
    kind: "schema",
    type: "object",
    reference: xe,
    expects: "Object",
    async: false,
    entries: e3,
    message: t3,
    _run(n2, r) {
      var _a2;
      const s = n2.value;
      if (s && typeof s == "object") {
        n2.typed = true, n2.value = {};
        for (const a3 in this.entries) {
          const l = s[a3], u = this.entries[a3]._run(
            { typed: false, value: l },
            r
          );
          if (u.issues) {
            const f = {
              type: "object",
              origin: "value",
              input: s,
              key: a3,
              value: l
            };
            for (const h of u.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (_a2 = n2.issues) == null ? void 0 : _a2.push(h);
            if (n2.issues || (n2.issues = u.issues), r.abortEarly) {
              n2.typed = false;
              break;
            }
          }
          u.typed || (n2.typed = false), (u.value !== void 0 || a3 in s) && (n2.value[a3] = u.value);
        }
      } else
        at(this, "type", n2, r);
      return n2;
    }
  };
}
function Ui(e3, ...t3) {
  const n2 = {
    kind: "schema",
    type: "optional",
    reference: Ui,
    expects: `${e3.expects} | undefined`,
    async: false,
    wrapped: e3,
    _run(r, s) {
      return r.value === void 0 && ("default" in this && (r.value = Ka(
        this,
        r,
        s
      )), r.value === void 0) ? (r.typed = true, r) : this.wrapped._run(r, s);
    }
  };
  return 0 in t3 && (n2.default = t3[0]), n2;
}
function ye(e3) {
  return {
    kind: "schema",
    type: "string",
    reference: ye,
    expects: "string",
    async: false,
    message: e3,
    _run(t3, n2) {
      return typeof t3.value == "string" ? t3.typed = true : at(this, "type", t3, n2), t3;
    }
  };
}
function ki(e3, t3, n2 = /* @__PURE__ */ new Set()) {
  for (const r of t3)
    r.type === "variant" ? ki(e3, r.options, n2) : n2.add(r.entries[e3].expects);
  return n2;
}
function Un(e3, t3, n2) {
  let r;
  return {
    kind: "schema",
    type: "variant",
    reference: Un,
    expects: "Object",
    async: false,
    key: e3,
    options: t3,
    message: n2,
    _run(s, a3) {
      const l = s.value;
      if (l && typeof l == "object") {
        const u = l[this.key];
        if (this.key in l) {
          let f;
          for (const h of this.options)
            if (h.type === "variant" || !h.entries[this.key]._run(
              { typed: false, value: u },
              a3
            ).issues) {
              const g = h._run(
                { typed: false, value: l },
                a3
              );
              if (!g.issues)
                return g;
              (!f || !f.typed && g.typed) && (f = g);
            }
          if (f)
            return f;
        }
        r || (r = [...ki(this.key, this.options)].join(" | ") || "never"), at(this, "type", s, a3, {
          input: u,
          expected: r,
          path: [
            {
              type: "object",
              origin: "value",
              input: l,
              key: this.key,
              value: u
            }
          ]
        });
      } else
        at(this, "type", s, a3);
      return s;
    }
  };
}
function ir(...e3) {
  return {
    ...e3[0],
    pipe: e3,
    _run(t3, n2) {
      for (let r = 0; r < e3.length; r++) {
        if (t3.issues && (e3[r].kind === "schema" || e3[r].kind === "transformation")) {
          t3.typed = false;
          break;
        }
        (!t3.issues || !n2.abortEarly && !n2.abortPipeEarly) && (t3 = e3[r]._run(t3, n2));
      }
      return t3;
    }
  };
}
function Ja(e3, t3, n2) {
  const r = e3._run(
    { typed: false, value: t3 },
    _a(n2)
  );
  return {
    typed: r.typed,
    success: !r.issues,
    output: r.value,
    issues: r.issues
  };
}
function $a() {
  let e3, t3;
  return { promise: new Promise((n2, r) => {
    e3 = n2, t3 = r;
  }), reject: t3, resolve: e3 };
}
var eo = Un("type", [
  xe({
    type: Be("connect")
  }),
  xe({
    type: Be("sign-transaction-block"),
    data: ye("`data` is required"),
    address: ye("`address` is required")
  }),
  xe({
    type: Be("sign-personal-message"),
    bytes: ye("`bytes` is required"),
    address: ye("`address` is required")
  })
]);
xe({
  id: ir(ye("`id` is required"), Sr()),
  origin: ir(ye(), Ri("`origin` must be a valid URL")),
  name: Ui(ye()),
  payload: eo
});
var to = Un("type", [
  xe({
    type: Be("connect"),
    address: ye()
  }),
  xe({
    type: Be("sign-transaction-block"),
    bytes: ye(),
    signature: ye()
  }),
  xe({
    type: Be("sign-personal-message"),
    bytes: ye(),
    signature: ye()
  })
]);
var no = Un("type", [
  xe({
    type: Be("reject")
  }),
  xe({
    type: Be("resolve"),
    data: to
  })
]);
var ro = xe({
  id: ir(ye(), Sr()),
  source: Be("zksend-channel"),
  payload: no
});
var Pi = (e3) => {
  throw TypeError(e3);
};
var Cr = (e3, t3, n2) => t3.has(e3) || Pi("Cannot " + n2);
var ce = (e3, t3, n2) => (Cr(e3, t3, "read from private field"), n2 ? n2.call(e3) : t3.get(e3));
var Le = (e3, t3, n2) => t3.has(e3) ? Pi("Cannot add the same private member more than once") : t3 instanceof WeakSet ? t3.add(e3) : t3.set(e3, n2);
var ke = (e3, t3, n2, r) => (Cr(e3, t3, "write to private field"), t3.set(e3, n2), n2);
var Xn = (e3, t3, n2) => (Cr(e3, t3, "access private method"), n2);
var Nt;
var Ct;
var Ot;
var fn;
var dn;
var hn;
var gn;
var yn;
var Et;
var bn;
var xt;
var pn;
var Qi = "https://getstashed.com";
var Xt = class {
  constructor({
    name: t3,
    network: n2,
    origin: r = Qi
  }) {
    Le(this, xt), Le(this, Nt), Le(this, Ct), Le(this, Ot), Le(this, fn), Le(this, dn), Le(this, hn), Le(this, gn), Le(this, yn), Le(this, Et, null), Le(this, bn, (f) => {
      if (f.origin !== ce(this, Ot))
        return;
      const { success: h, output: g } = Ja(ro, f.data);
      !h || g.id !== ce(this, Ct) || (Xn(this, xt, pn).call(this), g.payload.type === "reject" ? ce(this, yn).call(this, new Error("User rejected the request")) : g.payload.type === "resolve" && ce(this, gn).call(this, g.payload.data));
    });
    const s = window.open("about:blank", "_blank");
    if (!s)
      throw new Error("Failed to open new window");
    ke(this, Nt, s), ke(this, Ct, crypto.randomUUID()), ke(this, Ot, r), ke(this, fn, t3), ke(this, dn, n2);
    const { promise: a3, resolve: l, reject: u } = $a();
    ke(this, hn, a3), ke(this, gn, l), ke(this, yn, u), ke(this, Et, setInterval(() => {
      try {
        ce(this, Nt).closed && (Xn(this, xt, pn).call(this), u(new Error("User closed the Stashed window")));
      } catch {
      }
    }, 1e3));
  }
  send({
    type: t3,
    ...n2
  }) {
    return window.addEventListener("message", ce(this, bn)), ce(this, Nt).location.assign(
      `${ce(this, Ot)}/dapp/${t3}?${new URLSearchParams({
        id: ce(this, Ct),
        origin: window.origin,
        network: ce(this, dn),
        name: ce(this, fn)
      })}${n2 ? `#${new URLSearchParams(n2)}` : ""}`
    ), ce(this, hn);
  }
  close() {
    Xn(this, xt, pn).call(this), ce(this, Nt).close();
  }
};
Nt = /* @__PURE__ */ new WeakMap();
Ct = /* @__PURE__ */ new WeakMap();
Ot = /* @__PURE__ */ new WeakMap();
fn = /* @__PURE__ */ new WeakMap();
dn = /* @__PURE__ */ new WeakMap();
hn = /* @__PURE__ */ new WeakMap();
gn = /* @__PURE__ */ new WeakMap();
yn = /* @__PURE__ */ new WeakMap();
Et = /* @__PURE__ */ new WeakMap();
bn = /* @__PURE__ */ new WeakMap();
xt = /* @__PURE__ */ new WeakSet();
pn = function() {
  ce(this, Et) && (clearInterval(ce(this, Et)), ke(this, Et, null)), window.removeEventListener("message", ce(this, bn));
};
var Bi = (e3) => {
  throw TypeError(e3);
};
var Or = (e3, t3, n2) => t3.has(e3) || Bi("Cannot " + n2);
var Z = (e3, t3, n2) => (Or(e3, t3, "read from private field"), n2 ? n2.call(e3) : t3.get(e3));
var Ae = (e3, t3, n2) => t3.has(e3) ? Bi("Cannot add the same private member more than once") : t3 instanceof WeakSet ? t3.add(e3) : t3.set(e3, n2);
var nt = (e3, t3, n2, r) => (Or(e3, t3, "write to private field"), t3.set(e3, n2), n2);
var Ht = (e3, t3, n2) => (Or(e3, t3, "access private method"), n2);
var vt;
var bt;
var Je;
var $e;
var et;
var sr;
var ar;
var or;
var ur;
var It;
var zt;
var cr;
var lr;
var fr = "stashed:recentAddress";
var Wi = "Stashed";
var io = class {
  constructor({
    name: t3,
    network: n2,
    address: r,
    origin: s = Qi
  }) {
    Ae(this, It), Ae(this, vt), Ae(this, bt), Ae(this, Je), Ae(this, $e), Ae(this, et), Ae(this, sr, async ({ transactionBlock: a3, account: l }) => {
      a3.setSenderIfNotSet(l.address);
      const u = a3.serialize(), f = await new Xt({
        name: Z(this, $e),
        origin: Z(this, Je),
        network: Z(this, et)
      }).send({
        type: "sign-transaction-block",
        data: u,
        address: l.address
      });
      return {
        transactionBlockBytes: f.bytes,
        signature: f.signature
      };
    }), Ae(this, ar, async ({ transaction: a3, account: l }) => {
      const u = new Xt({
        name: Z(this, $e),
        origin: Z(this, Je),
        network: Z(this, et)
      }), f = Transaction.from(await a3.toJSON());
      f.setSenderIfNotSet(l.address);
      const h = f.serialize(), g = await u.send({
        type: "sign-transaction-block",
        data: h,
        address: l.address
      });
      return {
        bytes: g.bytes,
        signature: g.signature
      };
    }), Ae(this, or, async ({ message: a3, account: l }) => {
      const u = new Xt({
        name: Z(this, $e),
        origin: Z(this, Je),
        network: Z(this, et)
      }), f = toB64(a3), h = await u.send({
        type: "sign-personal-message",
        bytes: f,
        address: l.address
      });
      return {
        bytes: f,
        signature: h.signature
      };
    }), Ae(this, ur, (a3, l) => (Z(this, vt).on(a3, l), () => Z(this, vt).off(a3, l))), Ae(this, cr, async (a3) => {
      if (a3 == null ? void 0 : a3.silent) {
        const u = localStorage.getItem(fr);
        return u && Ht(this, It, zt).call(this, u), { accounts: this.accounts };
      }
      const l = await new Xt({
        name: Z(this, $e),
        origin: Z(this, Je),
        network: Z(this, et)
      }).send({
        type: "connect"
      });
      if (!("address" in l))
        throw new Error("Unexpected response");
      return Ht(this, It, zt).call(this, l.address), { accounts: this.accounts };
    }), Ae(this, lr, async () => {
      localStorage.removeItem(fr), Ht(this, It, zt).call(this);
    }), nt(this, bt, []), nt(this, vt, Fa()), nt(this, Je, s), nt(this, $e, t3), nt(this, et, n2), r && Ht(this, It, zt).call(this, r);
  }
  get name() {
    return Wi;
  }
  get icon() {
    return "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiB4PSIxIiB5PSIxIiBmaWxsPSIjNTE5REU5IiByeD0iMjciLz48cmVjdCB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHg9IjEiIHk9IjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iMjciLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTguMzUzIDM1LjA2NGMuOTIxIDMuNDM4IDQuMzYzIDYuNTUxIDExLjQ4MyA0LjY0NCA2Ljc5NC0xLjgyMSAxMS4wNTItNy40MSA5Ljk0OC0xMS41My0uMzgxLTEuNDIzLTEuNTMtMi4zODctMy4zLTIuMjNsLTE1LjgzMiAxLjMyYy0uOTk3LjA3Ni0xLjQ1NC0uMDg4LTEuNzE4LS43MTYtLjI1Ni0uNTk5LS4xMS0xLjI0MSAxLjA5NC0xLjg1bDEyLjA0OC02LjE4M2MuOTI0LS40NyAxLjUzOS0uNjY2IDIuMTAxLS40NjguMzUyLjEyOC41ODQuNjM4LjM3MSAxLjI2N2wtLjc4MSAyLjMwNmMtLjk1OSAyLjgzIDEuMDk0IDMuNDg4IDIuMjUgMy4xNzggMS43NTEtLjQ2OSAyLjE2My0yLjEzNiAxLjU5OS00LjI0LTEuNDMtNS4zMzctNy4wOS02LjE3LTEyLjIyMy00Ljc5Ni01LjIyMiAxLjQtOS43NDggNS42My04LjM2NiAxMC43ODkuMzI1IDEuMjE1IDEuNDQ0IDIuMTg2IDIuNzQgMi4xNTdsMS45NzgtLjAwNWMuNDA3LS4wMS4yNi4wMjQgMS4wNDYtLjA0MS43ODQtLjA2NSAyLjg4LS4zMjMgMi44OC0uMzIzbDEwLjI4Ni0xLjE2NC4yNjUtLjAzOGMuNjAyLS4xMDMgMS4wNTYuMDUzIDEuNDQuNzE1LjU3Ni45OTEtLjMwMiAxLjczOC0xLjM1MiAyLjYzM2wtLjA4NS4wNzItOS4wNDEgNy43OTJjLTEuNTUgMS4zMzctMi42MzkuODM0LTMuMDItLjU4OWwtMS4zNS01LjA0Yy0uMzM0LTEuMjQ0LTEuNTUtMi4yMjEtMi45NzQtMS44NC0xLjc4LjQ3Ny0xLjkyNCAyLjU1LTEuNDg3IDQuMThaIi8+PC9zdmc+Cg==";
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [xi];
  }
  get accounts() {
    return Z(this, bt);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: Z(this, cr)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: Z(this, lr)
      },
      "standard:events": {
        version: "1.0.0",
        on: Z(this, ur)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: Z(this, sr)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: Z(this, ar)
      },
      "sui:signPersonalMessage": {
        version: "1.0.0",
        signPersonalMessage: Z(this, or)
      }
    };
  }
};
vt = /* @__PURE__ */ new WeakMap();
bt = /* @__PURE__ */ new WeakMap();
Je = /* @__PURE__ */ new WeakMap();
$e = /* @__PURE__ */ new WeakMap();
et = /* @__PURE__ */ new WeakMap();
sr = /* @__PURE__ */ new WeakMap();
ar = /* @__PURE__ */ new WeakMap();
or = /* @__PURE__ */ new WeakMap();
ur = /* @__PURE__ */ new WeakMap();
It = /* @__PURE__ */ new WeakSet();
zt = function(e3) {
  e3 ? (nt(this, bt, [
    new Lr({
      address: e3,
      chains: [xi],
      features: ["sui:signTransactionBlock", "sui:signPersonalMessage"],
      // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway
      publicKey: new Uint8Array()
    })
  ]), localStorage.setItem(fr, e3)) : nt(this, bt, []), Z(this, vt).emit("change", { accounts: this.accounts });
};
cr = /* @__PURE__ */ new WeakMap();
lr = /* @__PURE__ */ new WeakMap();
var so = (e3) => {
  const t3 = Oi(), { appName: n2, origin: r, network: s = "mainnet" } = e3, a3 = new io({
    name: n2,
    origin: r,
    network: s
  });
  return t3.register(a3);
};
function he(e3) {
  return Object.freeze(e3);
}
function vl(e3) {
  const t3 = {
    name: Wi,
    type: Tr.WEB,
    label: "Stashed Wallet",
    iconUrl: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiB4PSIxIiB5PSIxIiBmaWxsPSIjNTE5REU5IiByeD0iMjciLz48cmVjdCB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHg9IjEiIHk9IjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iMjciLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTguMzUzIDM1LjA2NGMuOTIxIDMuNDM4IDQuMzYzIDYuNTUxIDExLjQ4MyA0LjY0NCA2Ljc5NC0xLjgyMSAxMS4wNTItNy40MSA5Ljk0OC0xMS41My0uMzgxLTEuNDIzLTEuNTMtMi4zODctMy4zLTIuMjNsLTE1LjgzMiAxLjMyYy0uOTk3LjA3Ni0xLjQ1NC0uMDg4LTEuNzE4LS43MTYtLjI1Ni0uNTk5LS4xMS0xLjI0MSAxLjA5NC0xLjg1bDEyLjA0OC02LjE4M2MuOTI0LS40NyAxLjUzOS0uNjY2IDIuMTAxLS40NjguMzUyLjEyOC41ODQuNjM4LjM3MSAxLjI2N2wtLjc4MSAyLjMwNmMtLjk1OSAyLjgzIDEuMDk0IDMuNDg4IDIuMjUgMy4xNzggMS43NTEtLjQ2OSAyLjE2My0yLjEzNiAxLjU5OS00LjI0LTEuNDMtNS4zMzctNy4wOS02LjE3LTEyLjIyMy00Ljc5Ni01LjIyMiAxLjQtOS43NDggNS42My04LjM2NiAxMC43ODkuMzI1IDEuMjE1IDEuNDQ0IDIuMTg2IDIuNzQgMi4xNTdsMS45NzgtLjAwNWMuNDA3LS4wMS4yNi4wMjQgMS4wNDYtLjA0MS43ODQtLjA2NSAyLjg4LS4zMjMgMi44OC0uMzIzbDEwLjI4Ni0xLjE2NC4yNjUtLjAzOGMuNjAyLS4xMDMgMS4wNTYuMDUzIDEuNDQuNzE1LjU3Ni45OTEtLjMwMiAxLjczOC0xLjM1MiAyLjYzM2wtLjA4NS4wNzItOS4wNDEgNy43OTJjLTEuNTUgMS4zMzctMi42MzkuODM0LTMuMDItLjU4OWwtMS4zNS01LjA0Yy0uMzM0LTEuMjQ0LTEuNTUtMi4yMjEtMi45NzQtMS44NC0xLjc4LjQ3Ny0xLjkyNCAyLjU1LTEuNDg3IDQuMThaIi8+PC9zdmc+Cg==",
    downloadUrl: {
      registerWebWallet: () => so(e3)
    }
  };
  return Object.freeze(t3);
}
var Ze = ((e3) => (e3.SUI_WALLET = "Sui Wallet", e3.SUIET_WALLET = "Suiet", e3.ETHOS_WALLET = "Ethos Wallet", e3.SURF_WALLET = "Surf Wallet", e3.GLASS_WALLET = "GlassWallet", e3.MORPHIS_WALLET = "Morphis Wallet", e3.MARTIAN_WALLET = "Martian Sui Wallet", e3.ONEKEY_WALLET = "OneKey Wallet", e3.SPACECY_WALLET = "Spacecy Sui Wallet", e3.SENSUI_WALLET = "Sensui Wallet", e3.NIGHTLY_WALLET = "Nightly", e3.ELLI_WALLET = "Elli", e3.TOKENPOCKET_WALLET = "TokenPocket Wallet", e3.FRONTIER_WALLET = "Frontier Wallet", e3.PHANTOM_WALLET = "Phantom", e3))(Ze || {});
var ao = he({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
});
var oo = he({
  name: "Sui Wallet",
  label: "Sui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////9/f39/f3+/v7x+Pz///95wfGj1PXI5fgEMJeQAAAAB3RSTlMAECNgmNr40ET05wAAAOBJREFUeNplUksOgjAQbYw38LdloQdw5VZJDGuNiWtXdGvUFjlAtT2AVC4AekrLvKKYvoTMm5fpfGGswWCdit2cfTFNZYO49YfSYwW/t2+FS0TCTH6x/Q/wISPZwcYJSVc4uxdg1wI2Yn0QbmCXbAKin7AHtiCbq6wicvI5syK/+azowlZSoxNGc4l7IWswhqKlagtD4Kl9CAWBAmspbGHwhJK+HDMlkiaIcJ9BWWqMu64yhcbGVMU5nKoc/XC2fGs/HMbPra78+MGCwhUGSw7OEB4qOKU7Nrki/p2/8zt8ABpiv63tyiOHAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
});
var uo = he({
  name: "Ethos Wallet",
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
});
var co = he({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
});
var lo = he({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
});
var fo = he({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAADkrSURBVHgB5X0LuF5ldea79n9OasAZY+v1mak5ccaOlwrBqtWq5UTxWqeJWgWVS6JSL1VJdBy1oklwqiICwXqhgBIEK4KSE0eUqpDgpbUzjkYFbe1UTtSnzwPBTnweCcrJv9d8+/vW7dv/nxu5kNAPcv7L3vu7rbXe9a71fXv/hHthuXPZsqn7DCeOncNg0YB4IYgXMGEqHZoiAlpwfoX+AzMTp694lqjZ3nK7HQ1vB2OWB9hKjC08xPZ5V89swb2sEI7wcudzTpqaBB1Pg3Zx+jidBL0wCXRBGhm5cEEmcNbPzHoOp/+6QnK+fJvOS98k6ZPX84t0JCkBbyFqb5zbObFl/pUzsziCyxGnADy9bAHmzz+2RbsMaJYly53q5MTJrm00Zt0iWFGCLMROzk2uSQ+WI52g5dqsEBQUAvk4ad25vsZaS8rAW9I3l01e8fnNOMLKEaMAcyecNE2D5rQklKWdhTPcwikLsFi5Ck+OIVp0PoOCQug5lIVcRFwUwYUelIrkeD651AtRLD2+PR2aAe3cOLH+izM4AsphrQC85ORj28l2WZLWytTTBSqc4q8xTohwYef/uDumClIJ3xAgY4Jcw1CRV8pU6gX6yqUo0wGLIoIr5db0ZvMchmvnr79uFodpOSwVYO6Ek6dTx1Z3gF+EpsJ2BVCL7nx5RAPz/Vkw4CLg7r/uy5YrbiDuQDmAzgaVa8q53AoXQO1SmjB31ObuMbVBmbTNdE2DzRgO106uv24zDrNyWCkALznl+CF4TZqwabFaiHXrGcnSSCytwDspAJuASI9FSy3ET67LZ5kltwL3hRiWV7LruSCIuIhYLwLXkHasX9JXQRflF6me2fR3zcTHrr0Mh0k5LBRgbjpZPNHq1Jtp8knPCkCRxWfYZjj0oyJ7YnnqBopbEGYgyBG4QrZ0LrgSEUAErt+bgMXvN+F7VktnNgJpPSt9oe78cF4+rcHWFIqunXfxdetxD5d7VAF4+qSpISYvpYamuWdBJMLj4GvzTFZwrAQPqF1ARILyfYF6PYYQ/2eF4E41iDiggR/Pp1eugj0aAEaIJYXruISRWUFYlErHllzHzM67aNU9yRHuEQXoQrkW//6M9HYNR0KVeyQsvCnzyIHUqaCgx+X8/FKOWVhnSKKcIdQPJZImZIpMHooeWXTEFcRnReguaTrlbKVdBDKKMKttrpopKJ67psBHsGbiqF9dQOs2b8chLodcAfhppxzfNs361PKUQT2KQXDw2zUHCK8k6OuCByKzV5jvvm4y8SsNU83qI8L0iGQScndyWzqhGER93y8cBCHCoFGU0DEClmuoXZqgQtPQ7BywYv6Fh5YoHjIF4OnlC9qWV6e3K3kEMkcFqj7TCV7+Hj1LHoVmxOtzGFhei1KwW6MigWYFVXzyFoX9W8ZQw8ZMQlsTouCEoc94RChtwVwAIgqguB/IBbhg8q/+ZhUOUTkkCnDnk5ZPzZuHTWm8C8cnbICeb44TV1mtJl4c2itf34Vc8i5MdNawViKImje4hRbn0rfMvtXX2cFSQ26T7bgoQCGskHRyGJsRyRIpljHVbfHsZLNzmj58w1Yc5NLgIBd+yorT5k3iO2l8Uzbx6nZRyZ9JzFJf1bClJgnopAYERieRXrzGNDvLQQRRqL+mjITEy4XRFEIcqP1SGM8EAMEhWEgRuiINKtCb39IPrLDE2muox5PTpnbyxJa7XvfsM3CQy0FVgOHTXnF+S1ifRnm/7jNr9GQTo4XdmuA+XE0dcKWgynbZBF8Im5/r55MrVW5czzffXCgAK+VIpW3Z2qCcIiY2/SrEoRoC1W0Crug6pqDMRV3E63jdxhRYPMuC5GrWzb3uWatxEMtBcQGdvx/e1VyaZmpZhPJMrQr7zr7ZuYBn9DzWFqtWto0q9SsVsmfbStIFFWnUxJFC/LgYHxhJ+xZRtLYaKG1V7sD6xq19ZiOC6gJK8igmljx89RC3KGecD5kHTSIRzUxM3LXiYEQJB1wBOPl7Hgw2pNW6xbkBGXTRcRGxWq5G7ARfjZM0qyFrZPbscTt8onvK0XKVjq3CLfP/Rcm6jw2qKITqZFLpYxSMKgtg0QMR4rGsz7o66VxFZ5yLfTemKpVCxjmw80uZHQ7nlsy/cPMsDmA5oArQCT+FeJtSpQsDpI8slOiAS7glApYpD9YkEYKwccQVPKCyTPhKH0SIFkI2RDEUq0iYzPY4YavSxNAUwUmj931vhdFWKI1iaLQSUcWsvSutoB1GwlJDDqLZyXZ4QMnhAeMA2fKp2ZTeTrXRHfbZnrwjyZAaoZJJVGdLFT3yeswZl1aD+XJgVORtqy7AhEmBcijIsJEFBNHGpnQAom+uiEoAnCZaHaxctVsuAtm1pa/qs4pz0vFhTICEAqJp7AvnmsHmO18zPYUDVA6IAmTho9mU+j1lphxYvfMgDlxIkJ9qbZFUr4KnEDlmZezq5y2BTz3VolFbdbanihHy/+prBfk9NJe2lRzCPJkaMZOsTZimWDM5AoBvQ3KdtEGIm7IMtQQpUNIZsVkUrGhMu3Awb3IT/9nTF+IAFMJ+liL8QRF+jHcpGnDOdIkCcOU7ozDMHwefPhKXi8DqJdmMI0Eh3O0ol3A4VSm6H889Oeoo4IlPAD3wgaXGn9wCbJ0Fbr+twMTYtQDVROUQqFPHPc2JWUuKc4TCgcyFFSWPS+CWKNM5STXODpvhkvnr9o8T7JcCdGyfd0x8mxtepCbfRPNUoqOoqGDfFCtW/w/xlxYIVTZcp4UDpmvkAFDfX8LbbNy/mzLCohFkXXvxi6n5o+cjK0GvtNdcBf7spznu/OmtP0SC6YjUhP7A3xfu0xtnGGMkmXXkEb8TFCTaMkE7l+xPdLBfLoB3TF6aNHOR9CzLvWS1yKZbDsk/4ztscbX5PgVUJ2yK6AyfhxIykk9bSC5BtEpPdfdAZJCOomxNQVmm5SuoefFLxgo/T9ALXwJ60YlUCVM6xEAQfrHpggpQvS/jtFSF0pI4PicU5ONAzShiIRtiOnXxTh5civ0od1sB+ImvWs1dnF/3jTz5oW9ZXH/gPerjyb1zl6r1VIhczRwJGatxMFfCUHP0uqw7mTixsW92ZpGJ6vP+iJrnPQ97nKSkBM3Jr6j0yTiA7xWVbUrBLcE1pMyN9StOmtm8EQybA9J6y3sntzZr6cplcytPOB93sxDuRhk+4fQz0gysU9FoRKspNWNJ1leu4M0TPOZLUXwe22KKxtZi58yRFlX+M4SZ0QVQpJsOv/ljUvvk67n5yIf2afz8tU1oL/qgrfXXbkdgQcLS/p6CAnM1T4n7B2KoXIWtYf58LpRCeq4hhdQrJs6//jLsY9lnBeDFifRNTnwniWqBrarJpNsGiQZqsiTr553bZ98QUQ805gQ8aRKSM/aq8XH0jTr5Qh4bMTru8YH4/kEPxGDN6vy6z+P/2g1oL/4QbHuYWvdIO11pq/xE4AoFLIwjebKIqnnB6PxWwYVnT9P3vxiiPW5fSeE+u4B2crJj/AsKp6sRj1FzGM99oOTFwiKQcjlzp626DoVNC88dIM37+4WVR42LquaF5Vj426w47W4JP1/9tKeDTn99GCWCMgZ70s7DQ0RhCWSDZK78BMEoQHjjTYSkMtw9su5HWDBJdAOvnF6AfSj7pADDx7/q/NTrhZZCI92kY8SnYjTqyk35KwZEukqeD7M4ORLipBtyEGNsZp+XjLa2Gq/+F/W0wa1ejtFL/gT0hCfsdpy87TZgxx27PN4kJWhOf0PuUai+FprMhxyAc0HYV+TvFRBt+mxu/RR4ZkmTFjrNpaQVk0VzTbebeu/LXruAuce/ajqh66axsNp1qx/2BJ/VwkMuUwyquYABAwWrH419y0dyrTIpVGEagHpzSDm+aCEGHzh7/ACTwNsvXAv+4rX5fb76vkehefwT0bwoRQkPeNDIJW3nDi75YDCjnquJMF99j9od6NiCG3Vf72pd7yTK6w2sfCu2OWQ8PbmCzdiLslcKkPz+Ap6c953UtakqIQJIIsUGQLUCtNJR9/vq83RNlfskzxWnSn647wRs48VIqBmSSOP8/lnvGg/9yeLbtWu4vX1b31/bDDWnrEDznOePzs3XsxIUhYzCln4argdBV3PRKFRwTHrZ9UquYfuPhGPBciJVKFoSZDw7OcTj9iY/sHcuoJl3Rqp3oTSj8GW5WTYbVfLvOK+ZvXKV+zzdiGkRPVAzXy67uEMvxE9qUA1y/87m9dmRMsxhGsIbXjte+Dt2JOGvZd62DUWnAqxauJcOXPFxbq/59Mjl9NTkDl71RkKN2ICjv/l4Ni/uXbRQ2YaY55FCPkVNxJeJtQUiChbgfICx6K4GK7EXZY8K0LH+lrBGVVDJjS7iRd4j2SyhvSP8huLMCIibUlsdeoDIgK0vlHIe2NDCHCIZ2bB2uv6cmPz+Yx49fnxXX90Jn1hwhY3MMgdtz8faDZ8GbxivBINXvjFUCjeSIDBCsHbXfmmvGLgx16gS5dwyqMgNOOANoYLDdNbqO1dOT2EPZc8KMJh3vnaEo5FSvaUJCNk96Y4qTM8uNGJWX1AWulCmiuvMnl7j17N4SoLPg2kAq8Vpl5PgH4UmKcC40l59Ndprr7XsctFfQRi2bEsVWrTXXMk8cxX368pI8MozoMiYt40bIoGD+jP5BJY2RV/Vwi1PppiHoB3eFekvBWWwkCl/MTGBS7GHslsF2Pm405enVpeW+tgE5tm1oHRF7XSM8lpU0XCKzLWLRhNIM3xlqBoMlFkJ8CKDg63AQRxOFXqp/GUzT4L8DP3jyuxsZ/1lYOafYSsE5CpVIXv3dnjNpzIajExmUQIK0Yqmhk0wjo1A5SbUINRrsaKknu0DNUpN1WKlVhGSC5i+879NT2M3pdn9QVqtDcf1avP5I2uWXHttGJxph6CD1GMFAYoyCJ+IsbC+stq+mouRvYKZPjflxIIyb3jNeL9/2zYM338O9NyyoGcooH30Tzby/Jo/tTNXot1w5UjV9JROCVaG65zSdZrRVmrtxzmYui1YGqcCEAylVEagkdnWbrpgBth9WLhLBcjWD5qinppWbVUjMQU3X2eOgHo5ENEVCtVW6U+IpZPEPWTJL90wUtbEqglwfMxmceKLQL873u+353wgkz5rB4IwArMFWrUfHti4Poh3n7mSxylB0ynBK86oLupG0MKToAEOPKYnMQKKpAjB2j0aVrZgkxc76ErU/Zuee8uS47GL0uz6QLPaelWDFgXKEpI1NFJH8FlcXS+ddZWxC4JAqfpOLSRux2U1S7VQPfakx1Nz0oswrrRXXQ2+ZVZ0r6BPF76pilFVIxt8kclMNFDWLNqZRAw3fnrEOpqnPAMDVQLON5lXrMgg0Fkyc4Czes1Q3J2OmSyy0lNsfVRRSsYgDbZrsIsyVgH4uNd2GjMlIF3a4OinrV15MyblyXoTH7tg4NqvhN3JF2EkA27p1HBB8COGMEHB6EEPouaVp2DsuDbdCL7qM4ClCuTWcLcm6kOK+i6Opmxko4xwuCFxgpkx7uAPnpGRgBqKiTDiuGxmgqQKUBnmmeQLnd5cATNqMu2N6quRmK6qXXKB8QqQNIbhUJe/C0s0ym6zB/cYVs2HI/GXcUuqmHWWzbLExjxfwHojBtklQbkpQkbZKVbPUPP2N+3S7/Oll/UslSqfa/21Q+IAKqJZ8hNZeK2Ps92YOMGnLhlptklKQMvPqPhDdIeuWG4I8pEpuAcjfmW2NIlS5QDDsBxBJGocUL4tb7R//S948Wum0svxMlaHoYAA3hxVAygLOhGLwzlsoy6zamu9chZrCpRMZyB7Pyp/5/ADSZRIfemrk14IPHwhRsodOzBcfRb4jh0B+s2q5cYPs3Y1elPMulD9lrw7/KX/ye3HLhhpvlOCwYqVFVYVYTvB8zGbVZPmVArqOm1wY/CZtoU5GRhHNCvnTN/11qceO9K3/heJqKzWGJu8MxbNsWlxgT8dgC7U6vnRV5Oy+ConIFdIt/32SMuFl6CifHKV4tCn8loQo/P7L92F3//4ZQkBbveZJVgSq8y0J7R8fLD9qWEbYYHeEtwiRhDatfYbN3D78VEloIwEK0mi2cAkwIi5Hfme62mK8S47FbQLUCkmTMGAYLDMEy/o92tEAah7Lg9g3inm26O1mwcr55KG0naOATaXHaGVFGGqa5qtQogIIB/VsQTXYXCY3zzwAWl1brzfb6/8TPL9X4Vl9rhuv1EoNZPS4emY2UdihK1opxHGAMUoSoBxSpCRYPlKuB8AKvShSDD686TF5E26Ghr5GcxVw3yMX8Ij9xpWCsCLX700nTulF3o40tcuhx2DoBAKcEQGVwgOLk19eyXlAgjs8BhUSTgHUOtQEeI73kxj/f4tW4GrPmt1wODSZ7h1uStKeZvcW6OA9UcuZsvE9VAJ7Teux/Dj60a6RE9OxHD5qqpWiXTDfJFNi6ZQHGXcilhhmcSNBQOt2nRPvWDuLU87Ph6rFCBx4mXxajd+rgh5MfT4B2VzErtbhk6dAX+IqEVxVCgGe0Yh4Mkhjgoh+Bl78dIXER7+MIyULtnzvnPLPFkvS2VtHJrXVDoU+kU2PMBStPI+M3kDPkNqBCQA/21CgktHlaDplOC0lcWhFq1zzhOF78QkyMRZL3HFt3t8AGUqfeJKTQ2WV32JH4iaZRaeUd1s6WlrWggDLJFecFHaUaEMFFGsOG3XfobHDhbLolK0Yo0ONYBC8JMej+ZlL8S40r73vML8YQG0I6/QF3KUJOtXmFGFV4Van3rrWnDB5GmDUEd2B5dewP3+NU8+ISnBqnJllfnhkjUQNK+CQ5KGQjJMMUdoGzycLkbojszc19K4a8i3Mjz2tcdz94xdJzRVnl5HidBRVrM27wdTW+mc8L8QL8k4qskEdHFH+tsyef3ou8UsmgeneP9PT8a4wld+tkv2oNdkZCWqQ0EZzNbiGG0lUNTe7ZEwvjj8Qb1O+7dfoeFZZ4zsMspKcOoqkMrM6lDFZHWcxKTp8mBALmeUnIYigkAHc/Cd0MP3/9V9di62PlijA15eGpU8ulYViY/2ryc91wFxZpWfFmDtWQYJhFHt1gDX4GJ9oMpna9vNmcl6HvQA9At/7rpE/D7b01Uo/5DphCsUm8Gofak/lvY0QqgE5GloChRHxhW+g+naT3+M4Qf+fLwSnLLK0TFgnPUHklRjrvQuz5/MIcdUppIHgqy1AHC+lUTd2HZ+RwDmxap3lugIsZcnaty6zXphKhabApwYerwfLE3vd3ML9ImHDoqFMMT5f3kX74/z+7cX66/wRnHE/bMHTk4+OFiK8x0Slm6jo1GksLX9qg341Fhpf/bPGJ47qgTUKcHJK6EcRDpHPoXlVSmQdmg01BbNZqgv0KOqHIqyS/VI2VyUkj9pBAYLtiBdz6RbtyhZPVQOeWP50/P1Gi4xomZbmifOo/Wa1ca0K128P87vJ+EP3/HulOy5QydMO22VmVVJTsJcKCmHYRumX002AgNDhFH1JiF+EHtkjzTSgtBPkxKc9zYeRYJnYnDqKq8WMf5mIPIT4VWWl9CBAL0VQkNqR6dy1hS/4w8W5na7P8MkfJ+cIMQAdWW3busTVymHjY98AByNjyic6VOqbD9qNGsmyyzRHM2D0/r+a8b7/faSyzPpk173D5cMqhLSeIL2kdW+mS38E61GfXpvyHYlqD5JQxgil09uuv3pLTRWCZ70zIQEq4QPtblaR0qOdyGWnoVsHMscV/skLe4lcuMsIDY3R9O5ze7PoMXxAsVcQxhzrfTuDWVsfczvzxBqVi35f/meEOaWEZ2gLTj55czNO1eO9/ufSrD/zW9Zm+auYiGhNYG1c2XevRCOa4jVer2z0ApFKGIZ0rjCGQdjKJpdxt3+9Mc0PH+8EgxOeZP2WV4kCWZuKtqeyESdM3pGrIMxH6vXDY7L7cmJGf6d8Imv56IC+mgWmzhtt+chODZaK5yhiJ1C8YEMms/Q+FqzK+RE9+UvHBvvd4Jv//oaGWURfKP8YdQPuGtj33QqkV7snz63oFzG/Q2qAr8x9tW6JR6zlHIwmQiQ2SgTMdx5/ttGieHvJyQ45c2k0Yoqq0ySWb0Qa3X3IwDk3bXNVBxkdnxuq/uTwGaxD83B0CL9KgaHojTxGKwNgbF2xpMlYa0gGlMRvG54YI4Jo1zbkx6XoHEkjZ39fnvxFaE1nQiVvTseU2plWmRf246wGI6zGLjG1br7iKoQwlr2+XHZ61RJbWRzYGPrrvhZig7WjUGCpASDk98krlfG5sgu86hI54tFekI+FgxOjc7PKLu86a5Hv27xxET7bXiC25E9ZLhLTl9v6BQoa4iqW2OoPM6nLc/QrXUyPyCihfgpeWXIqpO0rVrOft6DU57//W8HHjwK/cNXJtJ02201cMdEpKACyIVQPZGUZIwqEYk5ZcAuKamzzIGmpGFzRGoSfq8fYpqGLd/JqJ6ARqaZaP7LMRisfN/IGNu//3JCuPPEs3D9oCobl9VXPulNOkB1js2JyHpyYriooaZdYCImChilrsA7ExMn5t/qZBGZDvWvzhBbLWqJbeiD/JS7Gdxm3dqV8DlZPt22zfQ2Wpl1toIAB+MAMNZHNp2gup0gfF24ER215xmx9p7d0ZsAJYvN2gcO/AbunvlH30P7mYtGxpndwXNebqg7coJI1vfPoSzLB7qFCqjJ0P2uucFxDTftYjZFdU3qN6ibMUMOiC0sRYiPBSpbSDXVP9kRLfS+9iwebGu4SCcvGy/8jX+DduN1PsLo20s7oe9CJKJr4jB34koDVYln2HtLC4sZGE+x6ZCzJcxQ/1IFRqFCNlSWt6nu4aYZ4M7RexKb556MwXTtAiUv6K2TC0cjnVFtKTOj9sIDTDUDNFOk/XUmWxkTEXyqBfMQGbQx0HANzOdDpySfzKFytrpLPMt+Dj3zqaBxfv/W5Pf/6nIhQTqSmuyRTT6CMpOllT3XYiMQS7SQU4AuzK9IkwOaVzOs6BhBbxRQHI2JnCYS/JGX3/07jCvNc08Bzb+vzY+k5jxvxL7+ryBkISGzz4w0nt0O01TyWs3CfFkbWhNbN2GzJxLU4/h7mW9NVJhQEKMmNUmLmeQ8tcqQtUqDfcgDuDllvPCHb/sL61+lpS4BH0WVVuOQw1Ckhiqz2GCtx0q1qlDVDiAolQzBQ1ZUpIwhTwMzGfBISKmf7ryDMa7MPxr0iGMqpdUMpn2EdcjptoCj+z1ISiFPwP06arbA5qWKKYmCu7KsE4Lfswpl/k0R+ohXhXyKi1StX0vYVUjOOW+ncdDfnncR6NZtLAMUDmIthWe9ocbxAGniGu2HHDiGUdp1mdeSC0BQ7NGizfhApCeq1ObS/PJWBNWPovMUzj+asItC/+E/Ocyr7dlsm1wQ1CnomXlAKmQ1XznVcH4osVunTkzslq5GhXp90J4fKO3X5MscnKCdgy8FT+AAg2z54/z+J68Bf/+HGDFzX8U39+VmoUbvZkoCFcYbQ/dVIRl94Daf6q6HFBEj8HMmP+yPKwizEEIwVEdgpKCr83eOwa6Kuk+yUTqo2SCD7JwgR3tQZMjvp7q9Wgv0E4fJI0P7yKxRfw7tepuikyFhUcE7gn6pe1I2+eynEZ1SP3cqn/Z3/wftJ2fE13C1mVJt1b2cZpSVtCjkG+yb39K5UGuvdzgBnqJ25IvhbUTIOAMOjgi9Qi+r6kYnb4iOeTLwm6PPIbDyL7fIsCXILIgLz0FJdAJmqhkhHJG4cnUJAbqEgH7ur/8zAoSEY671vlRWA5rqkbgAO6XSCAGiPPnJ6scJv/P7fO7Fok1cr4DlJ4F3m+4bnwHrkrod1kM9XWYjTuTzhGoQpGkJVzADDo6nWxhq47LmosvkaoIsl5778lsPRvMnr8Yuy7/eCv7eNzjOpy6xl60AOt0KbKqqbOoYMIIEHhc2XMXHPkN273lAzzJEjloRIDkS5yySMHDzTJXlRs7VnPu2Uei/Ywfa//4exi/vUL/CcSgW9JnHrmde8jLSlsy59tbjfxcICNWziM1/S3uR4ZjplpPAPd6j72z6pEIhv7ri2lXYPKJLAp2dlGDX1t8lhFwG3j3RUslGsZF0R3LiYMOsE6ZkcUI657MX8auJR4KviWtAjbsMRfNshVAnwLYsqve2t570KfWcunS8379iQ8r0/TzfBlERPGi9Aa8x4prsgbTi4PIpraKuZbn9CvYJYNZd422NJSpv+0VRuKvRLrEFwNovVlsp+0ssIk1K+vRl1Lz4dOyutJs3YHjdFdCgzOZUyHWQjGZZnfI5FKsko1FjgnwqhS4Re0hplZFPS5GsBcLqg8nVRFZDEP2U1lnmky0yaJ6V4v1Tl40VfrvhS2F4AUZJBKsQ1VNfsfuwuMWa9KNekGLWbC+a7xEDVU6rUgwXFYk3Om5VEt1Qw0rUtV8Gsvmyo49OS9tnEv3OY7HLkpJC7RevwDApgON0yz527o9BAnxpRQdk8JbHXn7msjzKDxMu3LZMFTkvyZyogem2DZWjRpkRaphouf7o+zXnb16mO/khye+ftnR04P/8k6QAM2b17tOKshVg0WjVaYTWGxdcDMIpCMgFY9+qZ+iNxfb+cziGoAZKnszSqcr2mrXG/tB/fDgGrzsT2A3kdz5/50VnJeL347oqCvBOUc3hI2CuV9Ty3LXuMfK+jnJ0QnQCKmCfTM4Pb+TwCFf3fX1r1DSBXE/ka+/kliX9MV/anPfWUej/ZfL7ay6AG15pTTulKdjST7UD7vUOERS1m6Isuk8DtfrCyGx/SmHjYiWhAeHFAxgss066TBIpGcq/GIDm6X+M5sQ9QH7KBrafPDchwC85dNC6Im4maB3UvML89p0y+ZqwR8P5udWzcdnQPT6R3PgAVnvXvpBDorgd1n62tT1Yn1Uz86euD53lP2TU73ePZqNTX5CjAnVBUCyl2gLF1ehxUp10uXTfNHL3j2t4mDRYWKSnx1Ah+AapwiqPhDKf2d39pIIRslYMQyo56r7UvPZM2qPw04JQe/FZ3MG/LJSZo1UIBGARmZ4DCi6BEIKPOBsxzs3eYnZCjpKeJcpRLC2SNfOdgr0ym0qWVKtUBNlTyRJwbs/tk/GcFO+funSXk5DXAY55JHjmS9xuuE6M1VI6MjKGuwXYOCvTJSPn+hNOZSVbRkOqqiSTU040SWsL5oooWDrCu+7M7pfGGq9JY6Isng7y/+wdNO5Zg1YS5A8/cT74n77LvvcgVqYjdA5VxssaSpFkpzx9QWVhkExzyV10V1FD2yfSxbPpzZQgnCzNoufDRK4qiqBp5vMiK0cXQOQAtVzSwIfy0LS+f9ofY4+lywu8+mU0WPYstIkQ8vVfI5lRBRsfqO5T4MpMzcSFFJn5GA2JosYY2K8BABpuwQxADnRDbZyS6uVZPU5YiuakV2F3pVsKHl707m4dQHUL1itovVQZajFE1v0Bqr0BHvUZjAR/xnLpu0M0b6fhMa9dn744Vde9y7VmN9B1cPckiuM2eWy2QjLhXfEneLOe29U6uPL946F/T6VLCH0yRQZf+aooXj0d9tl9s4hX2xe113Or46Xvxi0oxjThVeuWcWtQ53zJ6SIdlRZvXnEGmuN+f7fDaq++CMMbNqK/+YaDA6lUggIah76RQLOOj40cc5aFswO4R+1+ji59v12hQf5oL6indSJChXpj3plKMFoHeXMcwkykY83yZXdP+F3pEOFNp2Pw8hegvT4pwVe+Bi67gGUw5fdbOfQq/FysIzxFxh8SeoatHlXYqxI5tXCbSgWjbvi6Cyr9/e0pbl7/50S7g/yf31Yg/0ff42D2pr4hAUNCIL3bdo70L7hkeIymj1yDOswK4wr36TgA31KiJDZWrc2wa1eZP4kdA7fWtmC800LU0GQ3X899CtHyvYD+PZVui1h3X0D6lxeHOmXo7gK+ZWsAdPn1eZVcwHBz4xrcNpFFuHsxeLVJFl5kSR7xrt08NjKDnTc64flolr6UkBBgV4V/9H20H303d5AfU0amZOR/lZhZfzggMNBzWwxTJrmarI5ykXiAPAHDhrdOJOe1lZwiFG8jaRObOkJlF/obl2pVkLZY0Ctf2bj24aEPIHr9STjQhR77qPwvlzt2EHeK8ONZNDt2dDeIgFIqmXek127DZfc00NtuC0JlC5s0OAScxVgoBeO1YetQ5CJiPEcfTc1LX5mfFbi70l51MYbXZ8h3xsTM1X5CA3ntlxml3SVFjnVBgYsQAhrEYxBUgI4zfdoyMRjwlrZ1A87yJ8e2cDVcA4DqjOIu2EiaKlRuMI1t3VuoC+8Oajk6hY+/+6j8zzvWK52SdA+IvPkHhJtvBv3wZtVg98CBy7o4UEMoURBAGvPDFtHEG98O7Any16/L1l+q9IRO+QlaEXJjkydGq3smC9ZrHyt00i8BRC7n2m1nkTn11OCwndiev22Pec2/orsz2KxbcuTVwIsLqNML7ETQfT3Lxqly7RtOQvPiE3BYlm3bkjLcDP7M1eDbOz7hv1KqylzcGns+R8iZECFqnpUg/wUJ3XYH+f/YQf57Ehr9EsamjIuw/6w9uBIgyS+v2IZ5dWqkSSC2HcuBu6EE4cFEFTEoyBLYPu/sr95/Qq7amqq7v2pR1k7h7VYM6Em4cwuNDGL4B035dEef++TDV/hdeeADQdPT+R//7/+V8u5fIPzwZolpyFaNdCrZoDh9cdR8NCfvBeRfeUniKRvZ8hZG5cQV5x9UNIGZ3xVTQnnxhEdxsxBXrLV5SOhaEsGf600Y2cCbLd2nCWlwc7r82GK5uXmDefV4IyNTC4dHTzBGmspDfpPpDScRjpBCT3giBukf/+BmtBd+iLvfEIijdkaU3j9sChMr30Z7hPyPr2P+0U3FBi11RLVhqRuoqKD67+B4JCSrehQcgImCUG2/E2s0tBHl7vTlu903WQESG/xuk9M9FJMLUNZoXVfGrAMxkFGV5PKjTf8u+eMPHgK/fxAKPfoxGHzwo8Rf3YT2s1cl13Ab4q1xzbMT5L/wxN1D/j/c1D0VBPzzW2upiu+NzL8ctDAc5lKFlpXjLEEHjHgqLqg8PPqCWXtDBsakrxbQMm/uXrMCDBICtN5TMgiKgQkh8E7FhrZmW6qly//r3Y/3D5NCf7gEg0c9BsOkBPj6JqJEMps/fQPo95642+vajZ/K/wD4r5ZK0eDTw+jQXoecDVX3YRpJJHjCya+A5jbN63bCt6SPEkvlZTCS330xb3L4HalaOrf4tbckJZuKWTIlOk4yGNX7cqUE3fL60N9Cc/X7cG8qHRp0yLBbyE9IMfzYBzPhy0XvIHBQdvJmBDvkVGROZbER9pNzMr9V+h2SeYRmaok0a5ujhugE5HwORDCVLfPOvjHcHYy8mXWj2jXIVnaoEFaPRbXe0hdXFFOl//ww3NtKhwa7E34H+Tvfd2Z6/X4wOEuZOX0gqiJM6r8GyC+rfKI+RhOUQZIGBxaKlv9pRFRav3j0bM1Jd7bosaAAmKk2PwK6s0Viztpr5b+SapQhljYe8dv4t1S6h0QPzz4zkz6EAMhyBBqEqXvUQAJun1oEsi3vBj81HAfCY+AsUIk1EVFVu0cARSHnQJfpuRP+5ldbWpr/i3TCAqqSCjHpAZiKKw9A7Aryho5/E6WD/Iv/EvjHm8pnE6lSZuF0jSef+yJXrkVKzvLmJd274hGYMTiVA4X3qLiZaJ1hD1lAYcqC7fPf5z8pZwhAW9anRSHeqDqs1ZFXF7rtWOaxRmmI/+knuLcX/mGC/Pe+M0O/W6XZd+RpZrbMbMTPgQB+lchH4Z5ZGYHKLbTPQZUopv4K4sRj1hPpS3qzMY6lflIosN6dUh9IfEwl62tdjQcJ//dn92oU6H41rH3vO3OeoCvGf2j8+QoEzrb9XoRiyxrQ630X0YEzOOhIjMGqPgW/TyFbYCv35CxjyLUCjHR7uPjV/y99eT+7ld/8iC4jhLDC2EK4166Lfk48ISWBTtzFlByhJUF+e9GH0Cbr11SL/DB2mf0mBOJAoWPVmopEBSSbZ8IvpjKZQrgN589c5Xk4RGHuDmBRg26MKQReKbwsiZc6Z+e9/8ZFcVgjTwtPEcc6ZYuyEBG2KtTkw4ueJ77jqq+AL/0c7i0lQ/5fvCtlCW9iclbP0PyLrYCH0Li8BJSMWRSy6E15o3N/yClaFSyaJxF8IIFwbPAIQIkndNVGmkh0ZHN/bKO/GEKTM+zjQ4SlYvTEGp8IWdAHRQQqkE7qFGD95xhHeGmvuQrD/7EatO02vV++TC6V7eYu9NpTluSZx3WMyNskXu8+trbCq9vdKxLBvbU9iEth9yKVD0agFwb9sgo8R7S2P76xML1z8atT6ounDV40yRPbCL9nK/pPmmzwBEZ6k7KCtOIAbAQ51GXHHRied3ay/pt7kBskZOOFL57puUVH3FbMuiUpI3MbvmcgLPOS5YcLthL166fatUAdPVPj64XFW2eZ3Dh5zuYl/WGO/80gJE0hdflsSWdPRCCOWKdE4lcKapW6sf5z6d9GHEmlWxAavv0t6fUHI8fCPpByblxt95PyX326uvJEFYqhe/QU4kqMVFpjJbDwrZjlOJF9N7Lb1XyGHi5MdC3GlLEI0JX2uFdvYtJfD5FqSYArxqHVE6lKXxolOwp1HTFcsRQHZEvYQS7dz8cPP3GppWjzIBqPxUJqh3dpmfnkuHij8yPvKTrL3CpzlXqvU8QehOvnQAADMSylDdGjHZudd87mRePGO7GriRjycG2D5niFdyEAAchgaxBBjVi2ZspHsolrEwp0W0dp+a7vB7hHS4L89txzOFk/kY1KBFWMEJp/DagHU35E56siIehP04WFIdmwqXedadQg28+gOSRP/VTCB3uYB9+sWl6YI2pAFogwxvd7HbspGQUanrbNSyM8oHoVhBhZAFHNRn6fFGDs/YD3YOmgvv3oh4Ftt8qaqe6AYI+rG4Sdtio0mWExjto3QxdSJOrLqGi8gH3vhTBohkmfjH0rD1C8D6rF5veNM1joGdAHPDvv3BsX7WrsE7ubmJQ0SCjA04XRVpYQLKIarnU6UxoSsKPwjJz1M0UnDxMlaL9wbeIo63ULtduPx+rk7Aqq32TbNaTI1mwp5XRWyq7QLpbNvT7EmF6ytkK93KVoThfaN/1Iso0voLNWKZa3dnfj3y0C5An6vYQC0IiAbYDyHKR6mbJ3Y0j0aRDtVtbbKcA9qgR33NH9hnBh+V0JKGZWKfxGWXrld5X7hHxp9NuwhG1IEIU9lazoIi7Wkm7eetkTmKtqMw8hNbrGo4tyYuQqJiOmATYm5v+C3U3DbhEg1z2kFTzgWwqaqyZLXAvXbpIZUgJSLSBZhggw/3rZTFH1Uw+9EvDNCfI/8pG8KdSAksuOHA79VKRTzxqryPJrfH+NAp/qQwmJVRPYDDhs7LBaKXADxFWW7i7uRgOr3l4tyfKF/KzGJ+ZUds5h1Z7motnTCbTlwtmWsFaFb09MYMe50tuKH4iWl7fUYw46Av7ERvBlhzZE5Gu/gOHqtfLbAuzKaYKXOZawzKE5qIAleBz17YelEDZvIMxLb+2khGYM+T0l2fpN4TcEhVdIEkkR3dpi1jsbxOzF7ebfW8o1r52/bvMs9lD2iAD5pJ13rWsH806j7oFSqsFknFZ0va1yYqySjqmqbhSNhCg68E/MID/i6WAjQfe8ofcnyL/pZkuUNDIEI88CsSp0Us6jL4pn6uyCUrCvuNj5bUZxjhGFsahGbahp8gMbFN2VJdpdfOZaIIrXelscwtBACrjL+bdYtxezsmcEyO2mpeKW2hXsc6LyNa22e+LhgGhTYROp6c+W9Uiu5LINjMs3Mg5S4ZsS5L/5rdxBf4RQdVmRYAUIdromVsn6LQcyppV4ThiKHCUKEB4sR3QiAjLo+dAkkW4eoQAeYV0ptoOea8qNDlteQes2b8delL1SgK5MfuuSzantdeSoX90g6dheetmye1c5zhbq5PEJPgipGX5iA/HlG3CgC3/+Om7fdRZ42+0+VQKh8jb2Uma5muZCWuthSlSgfAdcPWl9pB11JRRdQaXwMikWgVTxvluTYm/Vhvc8X3VBgv7N2MtC2IfCi5cvaCcnv5N6OKVX1wxZ8g7ht8igqhzWDkDOte16UfHm1GXjnxe4r6X7xfDul0M7q4/MPKud8nIPtYoLCLoaY3oltRSmWd2bx+9iuW0cpyaAfD5CnToHTbjLSpx8OZ2C8zAGVb5XLq4hoOw23jpx/qZF2Iey1wiQ+5NcQTMYLEn92F76Z6vhhlYU0NQYVTF2G4I6Xl/WJNs1wZfPYL+R4JataFe9DbjJcvnR2nTzDnsnjcxb6KIPcyOZe+1e2fdgy+QQwxULZnMx0GUjb5l1LmJjWrd1jvw1sEl2HdMvuDLf9OkXc8xLsI9lnxQgd+ybF86mrqwyV6AdZjUc6ZxEUaV3NTki9QPCvAoJg2+eunyG764StJ+7DsNVb0+Qv00bB3qeMjpcNjuTJBY5DLtgweZ92flLGFvwELUQQ57ETpFmqR9bRneaX8jcAtnlmt5FrThtWsDbG9bfLwPcjXLWv3x7y7se+rgFCbuenAfUhIE0sPRZIYdhUk36LLtXoPCpAXGelbzC9r1/yNyIjnnk3rmpjuWf85fA578oMBtcMmk7gkbRyrpXiedNqOShqoIT3Is7T7RdUjD2EFyNMHilFWRw7zRQ8FIjJXWpXh+s/mAyVp24rnRk7X3W3XC3bsbYu8ndRWmfePoGpnZZ7h0FRyB+Chj1+9EfxzVvjvl0rSnV0f1Y1Ngfjojlxwny33Me5yeGWC6crA5d1dNJV99vPfLcvvtg6Us5bjQ/i8pvygD7cxW53NkD9sQPRZ6D0XE3ygq5PO5YHiXn80SWRWVfU/F5Kgo5M3nB9S/A3Sx7lQfYVaG75lbwbwymkH92zr1T8Gj6UilaQQOnzcpsZaFNQKH87R4QRbfdXn417EGjzxLm67/G7V9/hrBjh3KlsDmCLcSHRSzMFPxzIazkilc5bQRBIlBAOZM9BascgA19GEUn6hlRq4U9WMvUQlMAkqQwzpQ7WiXiNCwgnp1I4Tn2o+wXAnTlzictn/oNDDal9MSUM2lWWO+xYyBuhtTn7VZM3LwyGZdQS85PAznmkaXiW28H/v5b5UkgZElbea/X9CAZQFyPz/0oGzsRLY/8fYFns+AQHUCtXudQLJqUNPgc2N6IclH1jAHroz/PqN4N5H0O+f/sSm4ZDHkJffiGrdiPst8KkLuTlKBFsyn1eiEHshNhEGH5c9QFhMGFzRMeYrILs+dGXMj6uXZFcVOFn9fGR7LocqtUbLsfpAoevTfP+X9vYcZdB/dD3aqPCNBu+OIK0SgiRKXRG0S441lbh3cNl8y/cN9JX7/scxQwrtA31882aJek3m2VOXXtzUaiO6f8O6hbNZ9cP4QgsvD+9+ETqdMvH0XUwfEaIzc+KPbeWsCn9hqwJ1xUdbwCFuZeAlADC9/uG30KwYXvGuH9gvMXT/yTb8UhVcwk/MkDIvyuHBAF6IoqQer2LHRm8wFLEXugJwStTGC5XiZfx1rn1qmYq5t6DVxch5kxPIM4XbNRfRySP5dHZpgM14s1xoUe/UvCKtxpBPVkR/mw+mknMAc7910BrHf2e+yofMJhjwsypc+zky1Pz7/wulkcoHLAFKArWQlKMmLWMYCrwQHwhQ/41wEhR0Jn3xTF9twe9HK5ujE2BEtckNPTvsF9W7cMBgL5Q6g6Lu2RjYHqEK/ySbJTMCe6giJYWsnVTqtTnVInVDqkBiCowdgy2Q6n99fn98sBVYCuZCWYx8cltzkj37g16thh6Fo+tZoxlyuotnF/hmH8UjimOIGyFKuykmCOup+x9faMa8SzYOAsxBpV3JZdgHXfrtRkIoMrNPBsocJ38WNc3Hs1TLX20o780X5ZCJouS2tnM5OTO5ccaOGXlg9imXvq8jUN410FVjWmZdu/BpEdg6vY1q0muE+1iXjMYcOgO1iNY7dGJo06aZbwTyydJOw0JA5MnzSuJ8QcPQmBizt0q72TzHYvRR1pVGNSiKH6gQ8Sp5RzL5j3kS+vxEEqBxwBYpn8+vo1aUSr0jB+EezNhq5f5L8sJoqgAX32FZOgQI8QFh9Mxgtr5VbCpjsrSn5I3IfYc/DmnrSEhOeoeUbA/BBOhE73vJq/j70yR8LorQuk1269ZcXBFL504OAXnk5hYotN6e1UNpxMwFqOaWKxKmVf5sRJwVmtVzBViIDG2YFIBL8Z0IIp+gJZBYQgkWUrxUPpFm5yClDQhxGzg0Cw8gq9BG26U2UfYCtIVFwRINkFRarSKzKlm51sBsnff2ErDnI5JAqgZe4Pl69rwG+EkDlUKVhGTNIopBay4Dl3EXgdEKiL6CdmLCoDwg0bejJpIqjAtfZC2g6uwPMRAVtIggEN0uSGmYoPRjdCrlShfyr8cEMJLpi8z6/X7O2Gjv0th1QBupJ4wXQz4Es5Zw6hDCzcwhwsTC26xw8Io8mhMrscwN8Fb2sBjWOIth3RABSVMbwPHIP6/TPlg64LMIhrJxT5SlBAV5asJLekDr9i8sLrNuMQloPKAcaVxAs2J1kflyZ3jYk7snP53L3ta2edEbJz+juozOmycU4o3cyhYaPQa86ZyD2IhpXVccDNOT7mWY9GC1aR9v29RA1C8vUr5NzE2sH8Xz/uUAsfuAcQIJY7EzeYBJ+fgrWlxrrH5eYdisVvG0Mux/Maq5yXK1HrIuj2TQPekIPXDGTlYgIyKNeoXVbsmyPT2AimtnpbRQw85cadA6w4kImdfS33qAJo4elTT2uJVyc8WuSkS0iaQLcLS9AeSvyiiwhEMEKtfgdRgJ5guL8wYzEKI65TVFwlX48e/5DcBLyfPX6jsL85va6dvOTQW3y/HBYKoIWfkRSBeU2arIWST6OIANGiytYstVLftNPPHbg1C7pIfZVghTzaLVdkLL9I0X47EWSKZfdJqjWLcMtTwcCjZLDjBjemf4eF4LUcVgqgZe6Ek6dTx1YD4SEVPQJGmkSprNYjCw3ghMGX98J4LJyj8JweIYMWEpZQ1bXAogF/pLwt66oCSrv26rO7eScP185ff/gIXsthqQBa7nzOSVOTw2Z1muBp1p3IMcaP0UFXgvWrpVPTf0pHd6o+l0VzD/LPcxO9bFxUrn541w/9TAlTGNeu+zXmNt53/Ze34DAth7UCxLLzWScvA4bL0gQvTb1eEC0wFxVAFnj5uToXZK0k7jJiSMjCMKuETk34yLeXjTsn1bM9/ZtpwZdNrv/8ZhwB5YhRgFjmnnPSdJr95QnSj00CWVxgWuw83JPQCamx+JzDNis2oeu5Eeb7RM8SUoF4qhIkpZhN386kTxsnJn65hdYfmgTOgSpHpALEwslNDCdoMXF7fBLE4iSRY5PA798ng5EDVJatC1TK0ZXVm1sI2cBs4TybHMWNPOAtw7nB5vlXzsziCC5HvAKMK3cte9li2tkuSIqQFKKdSqNcSMVtdN8tSMNeCNJMABC2q80KeZtNf2aTUm0fDrA16c3sXFqPP9KFPa78f3JWYVNfaX2rAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
});
var ho = he({
  name: "Morphis Wallet",
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
});
var go = he({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
});
var yo = he({
  name: "Spacecy Sui Wallet",
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
});
var po = he({
  name: "Sensui Wallet",
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbLSURBVGje7Vh9bNVXGX7ec87vtrdfdEA/oN2AlAyIgMKq4qbrwrJlGQuJupGoi0YTXZhmKxqdLnGMRI1LXEzI3By4LLiPxJmpi8im0aESkqEMh2yEjUHH+kGBAu3uvb299/7O+/jH/ehte9t9tKsl6Zu8ucnN7z3nfc77vB/nALMyK7MyK/9Pkene8Nj8c9V9Ib8Sc3b9oLWIO/fc7u49T/4Wm/yMB3Cy7OSyRMT9KWGClpgLELMB4s4hbt1LkMjNd74tF9/vmma6nO/GwYpA8GigbLEgHLNqSVhiXUr0Fx9k3WkDUFERXRbQX2tJOM067qgFIAJe9/PFrJ2xAEzKNjhS8qfuqLlfwmaBVCcVC2csAGvCXpt3FmOch1MfK1f0zlgAlRm8acgXHAmrI53P0Wr3t7vkwowFIFgZlxDtQj3kkI8E4Qg68kXPzL2XRB/ojL7eFGrklnjEfTxmAp9wZftPu9SzXz7TmJgWB/41p+frB2pO//FI5ZmGS64TH6zp/KTCvChABSDnrMpta+ML/vF+N/11Q2+9M5fNHXBp57Xq9Le65fyHDoDX0b18qOeIAMuH/0TSwGxeE1uw672s8YeGC6tS4n6UtqYtDVuTMkYyxiRDyr8heOA7p9yeDy2JDx/q2mzJ5YZEQcEo4He+Ut19zzOgncj+hbrzm0DZa4iN1nOOo0qgCqcatYJrDfHciehbDxKvVk05gK3YagTYMsL5YQ2Euu3Ksu6W8ez/PK9vPRQPW8W84u4b5NSpggLXVV6xBYIdREf5lAK4tfIb1xvlEguipCp2Dtaxs5TtPxtjdYHqowacZwsNTIf7gCocFQGJrrKopIEvpE3i/ikFYMXfaUufPoR8sr8ice/VXZcnSxqnB79rgKW2MLjlNet0PhKOipgL8I5zIPDNJF77zJQAICiGerUBMVZxLGnclk/3LY+Vst03p+cqS95hkAU7YgbSfCdWBKqxQPVtFUFvWSUVUgUr9xGUSQN4o7JjtSHqDYERqkgFYbixNdbUNx7wiJgfClljiuhmRg1yEer2ICUfqfH9rY6860ykPPQiUOBTCby2+t38c+9KH5U2AUsV4PaWVMvx8exeru65BpQbDATI2ROAleyvg0IUexDO3Xprv/TnQD+0/7L+dSryRQUqYe3X4HH3pCLghKtGU0eII5WD0ScmpJ6RLUJUZOmT3SgbvcLwFnea/t5nc85nz0TYkBx6XkWQ06smTSGjaB6TvJD2Row/uxyu6F4L4gaR/CZZ4BbDSeyou266sODoaNvaTNorBAqBCpqJ42WTopBAoyMzSY43Dy3aO5FN2vFuAaoLzJPs6VMAAwHJAQ7xwQK3Rpa85fnbvVCqL0DqAXR+8AgA4YjkFdkhEI57+lW9KyFy24hZhYDk6QPCqu5qG2rsKJH4zkNu9hB4CLxIoGUSnVQEVMMzDsNTQpLuwETfJ114j2V2UykCQRCGAgUHyxh5pJTtubJTN3qgtWBJIIMUJ5UDEZjDxQl82kXGffp4qaZrndBuIorqFodBCAgBn26NzT822rajtqM2JeE2FSCvNBjyKcQnV4VU9hV30BNVc+aV+u7VurNV3rgfe0GEACDFIAghASBmMnikBHUMUnqfh7QW6AOBwsQWYcW5SQGYGy49YMCBfARSTm4f/c0zoD3ruc1D1jN36CxKgjyVLPls62DToTEPXhUnbwJkM0VQrCHYIZBwUgAEoobYmS+hBL76q8bEhoLzzZ3R2vnnf+LFtKvkSCICcvRtgwOhD7ePXv9o7dFFoHnIi5R7ERQrYfZPyYWGeLM+bsNTBMt/33AFhqxjxIf/ifrwYoRYFaGvD1QLo7HNXdots7w3AIzXBz6WuPz7xeu+Xt093/hwL8GVJbZNgWy7MrnkwKSnUcHSs0L9gQVRnx5iRkRCMWszxl4fitSHEHgx8PkOCoC535y8xaDvp2MrXPpnoWDl6JPP6YlXkosPTtmNrFJXbDfA80sGY5IWi9CYnOadBxTIgsh1UmZp8I4Qt6/pX9NfosY9TSBT6LxFSsrDmyB+ygAIRFM+/NLiZOJv5RoibQwyYhAiB0SyqiJQk48C4iTa18SaSnJ5RaLpL572cxATKy6fEHkjFTn/1JQ/bNVi9cUyJj9/RTKxw8MwIwYZIwhlmEIe+UHMdKvXuz4RW/D4RGuuGmzeHYrZoMZ05qiTCcn7S0dsCl7mBK0Dt/TNvcMws1GN/D0Um8hIAQQ9pE8hf/VMb7gm1vT4e1nzo7GF+4YkbAPxlBK//F3isd9M28vcEwuHllF9S0CprtDMQJTp/97YV9eDWZmVWZmVWbkU5H+A2tIeEhTccwAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
});
var Mo = he({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
});
var No = he({
  name: "Elli",
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYySURBVHgBdVdLbBVlFD5nemtvuRLKGxMTaVlBUgIREzExQJCFCTG4cONC6ka3JkbjAhMxSCExutTEhXRhjIkJ0bjk0YWBghBLqZiItnFHa5Fi+m5njuf5z9xemKb33vnn/8/jO995DELlarvx9/GCsI+A9iBm64gI+eJb4g+75F7X7YYfESD/kd/KXqju8X28Lt+DvPsc7Ht6ID3Sz1/Hu2AFz7PwAy5AHpkQl6IK9DPj5SIMULvEhuq+dFUfqG2mkDUMQxsdgr3d05nKyeEy6zuox1Vmof+Ihd2jWFWYBbGWyWYWCgXaWpH2xb/LIpFFIdvO7YEczhsC1//sw7bsazWvFTL33KBl6QZZLIZHAaWfIwfXjwcaKEHR/XEQ6M0aZnSc2BzZHfEVkeiaUnTRDcFSoG5yjiQ7FAXxVf9cpVmoshDMD1RwjiPc/IPKKMUTcrUlAXFVfLFUXEXAOUEIq8+b9sDEmUvTNYuVyUFncBgsHpjlaMTDZIsbSWFMkBRLw4vwuQJaIJuM7qpBInKklseLoLrZlRcI4Sm5I0aQpCQAgsyNwCpokEKGHsQaKeNdVxyShaxMfScoJnKSm52FhZS8CjQTYtUaEuCHU/xdQ/VVMYYgm3NFD9WvXSWcmUFoAhMg37IVlnp3q/Mdo7egbXIi4AOvRJBv3Ya6J3D1whblQX7UglqYueFRfPijPnQVN5w6CasvajRg6vRZ0JCIwMYa7PrqS8DZ2Za9D955F+cPH5FTaIIZmcyzDaWs8YKEgSEDUNiMXO1/3cX1n3/6GOVnYHlHj9OwQP5NU/1n9Nnqax0bVhu7CxpqL1ZW5CyWmVQ7++cFqbL8sDZ5DzacPtXikSrv72fl3RBCtFqKET1iRH+LERnL2PjJKZY5AV5h0Z3WaGRGZ3mQ822uCVUfugJtExMt3sy9dBiWera7N+JBjlG25bc8W+ztbTkn/Fhz8YKdi1JtLEFFgDTjybMrh/kjh2mlp7tFUOeFi+zRjNV5NtaoK0I1FOIl1YeGWs4ts6yZY0dJUbbeApYlQFmUWzTrZBPkjTpOnfiAWbylBU72hNrHx2DNpUsqTHjV+OFHaB8fh46REVytXGT8y7Ko0YmWvI64hi7n3hQQat55HxActm6GqTMftxjRefUato+NSYjQCk1BtX8mGOZ7sPbb71qUq4xtm8nJZyFztEVfBgaLxpNSW+UYMSHZCLp/4v0mYj1x+zdYYeP+e/01kP1Cpodv9UkqslGTaZ8S9uxJlrEJTDGVmaCVq1DSZ6BCck1F9DLnfVz7/MqOZ+j+h+81Cc7mZixzytChkLZq6NTZj2hly0Z0eUo4DPK64Ywgy7n9c+FnMEYC7wEUJVdu60O/QMFeLu/YDt4zSe5FXDY3p04VTzY4RDc0lAvPP5dmhmjlROXYoAqsEnrXSp0KvblEWTUBoqxj5A6s/eZ7/X749hs4e+xl48WV69D12RewtHsXLOzfB0vd291rnyl9HmrqWNbhIKMUm2iveYLVRijjSLFtE80deZHr/04yMt6wEYz3iFFyLfbuhPn9z2Lx1KaScFp0CDEqIJg88pRHHB0sjP0Bi0MkJ4oYSqOhkeZKfegmN6hZXHhhnz7pYGMEoUX2vjqqgaMXk4zPCpB2aN8ZveTJ6cMIGRZYOVkOGclMrE4/WFIlzXvNUxakx9A0nxDWvAaENPRRyMOC6Vh6R0jjNUFpp53T9ayZvH4GnYHBA+/9PA+QppPPdz5++bwGPhb5+EKYFDq4BNXpmVxZxUdI051HEZWYptz08ExID3hxPWJsp8QDCrih+oJRplGMmNrZ4hsTmyucl3xnNhc5YjmX2hDGCNxCKCtgsDd1LmU6KIOp8gJCXsCkgprO1JRSqy2rrDjF+zKtFvHSIpkwyEvFgAmjNCR4u9RqF0okHVOltLZNmIUSa2JWHd1I0laNqcpa58QmRykfsCS789Nl/jqYalCFro/6hmZ8yysmR2parQ7YZQyJhmnX0b02CS4uv8qah6P4UBqZCkchOqZOQIQxB/ge6/E60vHPeCdMBQ6j/RJGXygGqXP5UKsjv5/v4/mFX5fggLP1Eflcca3ZeV/zVMFgs/cYhGkWyU7CAOx85Vyc+x+o7DqjAADBkAAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
});
var Io = he({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://tokenpocket.pro/"
  }
});
var mo = he({
  name: "Frontier Wallet",
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
});
var Ao = he({
  name: "Phantom",
  label: "Phantom",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
var vo = [
  ao,
  oo,
  ...[
    uo,
    co,
    lo,
    ho,
    fo,
    go,
    yo,
    po,
    Mo,
    No,
    Io,
    mo,
    Ao
  ].sort((e3, t3) => e3.name < t3.name ? -1 : 1)
];
function wo(e3, t3) {
  let n2 = ie.WALLET__CONNECT_ERROR, r = e3.message;
  switch (t3) {
    case Ze.SUI_WALLET:
    case Ze.ETHOS_WALLET:
    case Ze.GLASS_WALLET:
    case Ze.MORPHIS_WALLET:
      r.includes("Permission rejected") && (n2 = ie.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case Ze.SUIET_WALLET:
      r.includes("User rejects approval") && (n2 = ie.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case Ze.SPACECY_WALLET:
      n2 = ie.WALLET__CONNECT_ERROR__USER_REJECTED;
      break;
    case Ze.SURF_WALLET:
      r.includes("The user rejected the request") && (n2 = ie.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
  }
  return {
    code: n2,
    message: r,
    details: {
      wallet: t3
    }
  };
}
async function Eo(e3) {
  if (!e3)
    throw new re("Cannot serialize empty transaction");
  if (typeof e3 == "string")
    return e3;
  if ("toJSON" in e3)
    return await e3.toJSON();
  if ("serialize" in e3)
    return e3.serialize();
  throw new re(
    'Cannot serialize transaction, missing "toJSON" or "serialize" method'
  );
}
async function bo(e3) {
  return Transaction.from(await Eo(e3));
}
var Do = ((e3) => (e3.DEV_NET = "sui:devnet", e3.TEST_NET = "sui:testnet", e3.MAIN_NET = "sui:mainnet", e3.DEVNET = "sui:devnet", e3.TestNET = "sui:testnet", e3))(Do || {});
var jo = {
  id: "sui:devnet",
  name: "Sui Devnet",
  rpcUrl: "https://fullnode.devnet.sui.io/"
};
var To = {
  id: "sui:testnet",
  name: "Sui Testnet",
  rpcUrl: "https://fullnode.testnet.sui.io/"
};
var Lo = {
  id: "sui:mainnet",
  name: "Sui Mainnet",
  rpcUrl: "https://rpc.mainnet.sui.io/"
};
var wt = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
};
var So = [jo, To, Lo];
function ve(e3) {
  return `Failed to call ${e3}, missing context provider to run within`;
}
var Co = {
  configuredWallets: [],
  detectedWallets: [],
  allAvailableWallets: [],
  chains: [],
  chain: void 0,
  name: void 0,
  adapter: void 0,
  connecting: false,
  connected: false,
  account: void 0,
  status: Ce.DISCONNECTED,
  address: void 0,
  async select() {
    throw new re(ve("select"));
  },
  on() {
    throw new re(ve("on"));
  },
  async disconnect() {
    throw new re(ve("disconnect"));
  },
  getAccounts() {
    throw new re(ve("getAccounts"));
  },
  async signTransaction() {
    throw new re(ve("signTransaction"));
  },
  async signAndExecuteTransaction() {
    throw new re(ve("signAndExecuteTransaction"));
  },
  async signPersonalMessage() {
    throw new re(ve("signPersonalMessage"));
  },
  async reportTransactionEffects() {
    throw new re(ve("reportTransactionEffects"));
  },
  verifySignedMessage() {
    throw new re(ve("verifySignedMessage"));
  },
  async signMessage() {
    throw new re(ve("signMessage"));
  },
  async signTransactionBlock() {
    throw new re(ve("signTransactionBlock"));
  },
  async signAndExecuteTransactionBlock() {
    throw new re(ve("signAndExecuteTransactionBlock"));
  }
};
var Fi = (0, import_react.createContext)(Co);
function _t() {
  return (0, import_react.useContext)(Fi);
}
function dr(e3, t3) {
  return dr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, r) {
    return n2.__proto__ = r, n2;
  }, dr(e3, t3);
}
function Gt(e3, t3) {
  e3.prototype = Object.create(t3.prototype), e3.prototype.constructor = e3, dr(e3, t3);
}
var Zt = function() {
  function e3() {
    this.listeners = [];
  }
  var t3 = e3.prototype;
  return t3.subscribe = function(r) {
    var s = this, a3 = r || function() {
    };
    return this.listeners.push(a3), this.onSubscribe(), function() {
      s.listeners = s.listeners.filter(function(l) {
        return l !== a3;
      }), s.onUnsubscribe();
    };
  }, t3.hasListeners = function() {
    return this.listeners.length > 0;
  }, t3.onSubscribe = function() {
  }, t3.onUnsubscribe = function() {
  }, e3;
}();
function L() {
  return L = Object.assign ? Object.assign.bind() : function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n2 = arguments[t3];
      for (var r in n2)
        ({}).hasOwnProperty.call(n2, r) && (e3[r] = n2[r]);
    }
    return e3;
  }, L.apply(null, arguments);
}
var Dn = typeof window > "u";
function le() {
}
function Oo(e3, t3) {
  return typeof e3 == "function" ? e3(t3) : e3;
}
function hr(e3) {
  return typeof e3 == "number" && e3 >= 0 && e3 !== 1 / 0;
}
function jn(e3) {
  return Array.isArray(e3) ? e3 : [e3];
}
function Yi(e3, t3) {
  return Math.max(e3 + (t3 || 0) - Date.now(), 0);
}
function Mn(e3, t3, n2) {
  return kn(e3) ? typeof t3 == "function" ? L({}, n2, {
    queryKey: e3,
    queryFn: t3
  }) : L({}, t3, {
    queryKey: e3
  }) : e3;
}
function Ve(e3, t3, n2) {
  return kn(e3) ? [L({}, t3, {
    queryKey: e3
  }), n2] : [e3 || {}, t3];
}
function xo(e3, t3) {
  if (e3 === true && t3 === true || e3 == null && t3 == null)
    return "all";
  if (e3 === false && t3 === false)
    return "none";
  var n2 = e3 ?? !t3;
  return n2 ? "active" : "inactive";
}
function Zr(e3, t3) {
  var n2 = e3.active, r = e3.exact, s = e3.fetching, a3 = e3.inactive, l = e3.predicate, u = e3.queryKey, f = e3.stale;
  if (kn(u)) {
    if (r) {
      if (t3.queryHash !== xr(u, t3.options))
        return false;
    } else if (!Tn(t3.queryKey, u))
      return false;
  }
  var h = xo(n2, a3);
  if (h === "none")
    return false;
  if (h !== "all") {
    var g = t3.isActive();
    if (h === "active" && !g || h === "inactive" && g)
      return false;
  }
  return !(typeof f == "boolean" && t3.isStale() !== f || typeof s == "boolean" && t3.isFetching() !== s || l && !l(t3));
}
function Vr(e3, t3) {
  var n2 = e3.exact, r = e3.fetching, s = e3.predicate, a3 = e3.mutationKey;
  if (kn(a3)) {
    if (!t3.options.mutationKey)
      return false;
    if (n2) {
      if (rt(t3.options.mutationKey) !== rt(a3))
        return false;
    } else if (!Tn(t3.options.mutationKey, a3))
      return false;
  }
  return !(typeof r == "boolean" && t3.state.status === "loading" !== r || s && !s(t3));
}
function xr(e3, t3) {
  var n2 = (t3 == null ? void 0 : t3.queryKeyHashFn) || rt;
  return n2(e3);
}
function rt(e3) {
  var t3 = jn(e3);
  return zo(t3);
}
function zo(e3) {
  return JSON.stringify(e3, function(t3, n2) {
    return gr(n2) ? Object.keys(n2).sort().reduce(function(r, s) {
      return r[s] = n2[s], r;
    }, {}) : n2;
  });
}
function Tn(e3, t3) {
  return _i(jn(e3), jn(t3));
}
function _i(e3, t3) {
  return e3 === t3 ? true : typeof e3 != typeof t3 ? false : e3 && t3 && typeof e3 == "object" && typeof t3 == "object" ? !Object.keys(t3).some(function(n2) {
    return !_i(e3[n2], t3[n2]);
  }) : false;
}
function Ln(e3, t3) {
  if (e3 === t3)
    return e3;
  var n2 = Array.isArray(e3) && Array.isArray(t3);
  if (n2 || gr(e3) && gr(t3)) {
    for (var r = n2 ? e3.length : Object.keys(e3).length, s = n2 ? t3 : Object.keys(t3), a3 = s.length, l = n2 ? [] : {}, u = 0, f = 0; f < a3; f++) {
      var h = n2 ? f : s[f];
      l[h] = Ln(e3[h], t3[h]), l[h] === e3[h] && u++;
    }
    return r === a3 && u === r ? e3 : l;
  }
  return t3;
}
function Ro(e3, t3) {
  if (e3 && !t3 || t3 && !e3)
    return false;
  for (var n2 in e3)
    if (e3[n2] !== t3[n2])
      return false;
  return true;
}
function gr(e3) {
  if (!qr(e3))
    return false;
  var t3 = e3.constructor;
  if (typeof t3 > "u")
    return true;
  var n2 = t3.prototype;
  return !(!qr(n2) || !n2.hasOwnProperty("isPrototypeOf"));
}
function qr(e3) {
  return Object.prototype.toString.call(e3) === "[object Object]";
}
function kn(e3) {
  return typeof e3 == "string" || Array.isArray(e3);
}
function Uo(e3) {
  return new Promise(function(t3) {
    setTimeout(t3, e3);
  });
}
function Xr(e3) {
  Promise.resolve().then(e3).catch(function(t3) {
    return setTimeout(function() {
      throw t3;
    });
  });
}
function Gi() {
  if (typeof AbortController == "function")
    return new AbortController();
}
var ko = function(e3) {
  Gt(t3, e3);
  function t3() {
    var r;
    return r = e3.call(this) || this, r.setup = function(s) {
      var a3;
      if (!Dn && ((a3 = window) != null && a3.addEventListener)) {
        var l = function() {
          return s();
        };
        return window.addEventListener("visibilitychange", l, false), window.addEventListener("focus", l, false), function() {
          window.removeEventListener("visibilitychange", l), window.removeEventListener("focus", l);
        };
      }
    }, r;
  }
  var n2 = t3.prototype;
  return n2.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n2.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var s;
      (s = this.cleanup) == null || s.call(this), this.cleanup = void 0;
    }
  }, n2.setEventListener = function(s) {
    var a3, l = this;
    this.setup = s, (a3 = this.cleanup) == null || a3.call(this), this.cleanup = s(function(u) {
      typeof u == "boolean" ? l.setFocused(u) : l.onFocus();
    });
  }, n2.setFocused = function(s) {
    this.focused = s, s && this.onFocus();
  }, n2.onFocus = function() {
    this.listeners.forEach(function(s) {
      s();
    });
  }, n2.isFocused = function() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? true : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }, t3;
}(Zt);
var kt = new ko();
var Po = function(e3) {
  Gt(t3, e3);
  function t3() {
    var r;
    return r = e3.call(this) || this, r.setup = function(s) {
      var a3;
      if (!Dn && ((a3 = window) != null && a3.addEventListener)) {
        var l = function() {
          return s();
        };
        return window.addEventListener("online", l, false), window.addEventListener("offline", l, false), function() {
          window.removeEventListener("online", l), window.removeEventListener("offline", l);
        };
      }
    }, r;
  }
  var n2 = t3.prototype;
  return n2.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n2.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var s;
      (s = this.cleanup) == null || s.call(this), this.cleanup = void 0;
    }
  }, n2.setEventListener = function(s) {
    var a3, l = this;
    this.setup = s, (a3 = this.cleanup) == null || a3.call(this), this.cleanup = s(function(u) {
      typeof u == "boolean" ? l.setOnline(u) : l.onOnline();
    });
  }, n2.setOnline = function(s) {
    this.online = s, s && this.onOnline();
  }, n2.onOnline = function() {
    this.listeners.forEach(function(s) {
      s();
    });
  }, n2.isOnline = function() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? true : navigator.onLine;
  }, t3;
}(Zt);
var Nn = new Po();
function Qo(e3) {
  return Math.min(1e3 * Math.pow(2, e3), 3e4);
}
function Sn(e3) {
  return typeof (e3 == null ? void 0 : e3.cancel) == "function";
}
var Zi = function(t3) {
  this.revert = t3 == null ? void 0 : t3.revert, this.silent = t3 == null ? void 0 : t3.silent;
};
function In(e3) {
  return e3 instanceof Zi;
}
var Vi = function(t3) {
  var n2 = this, r = false, s, a3, l, u;
  this.abort = t3.abort, this.cancel = function(I) {
    return s == null ? void 0 : s(I);
  }, this.cancelRetry = function() {
    r = true;
  }, this.continueRetry = function() {
    r = false;
  }, this.continue = function() {
    return a3 == null ? void 0 : a3();
  }, this.failureCount = 0, this.isPaused = false, this.isResolved = false, this.isTransportCancelable = false, this.promise = new Promise(function(I, N) {
    l = I, u = N;
  });
  var f = function(N) {
    n2.isResolved || (n2.isResolved = true, t3.onSuccess == null || t3.onSuccess(N), a3 == null ? void 0 : a3(), l(N));
  }, h = function(N) {
    n2.isResolved || (n2.isResolved = true, t3.onError == null || t3.onError(N), a3 == null ? void 0 : a3(), u(N));
  }, g = function() {
    return new Promise(function(N) {
      a3 = N, n2.isPaused = true, t3.onPause == null || t3.onPause();
    }).then(function() {
      a3 = void 0, n2.isPaused = false, t3.onContinue == null || t3.onContinue();
    });
  }, p = function I() {
    if (!n2.isResolved) {
      var N;
      try {
        N = t3.fn();
      } catch (v) {
        N = Promise.reject(v);
      }
      s = function(m) {
        if (!n2.isResolved && (h(new Zi(m)), n2.abort == null || n2.abort(), Sn(N)))
          try {
            N.cancel();
          } catch {
          }
      }, n2.isTransportCancelable = Sn(N), Promise.resolve(N).then(f).catch(function(v) {
        var m, D;
        if (!n2.isResolved) {
          var b = (m = t3.retry) != null ? m : 3, C = (D = t3.retryDelay) != null ? D : Qo, w = typeof C == "function" ? C(n2.failureCount, v) : C, P = b === true || typeof b == "number" && n2.failureCount < b || typeof b == "function" && b(n2.failureCount, v);
          if (r || !P) {
            h(v);
            return;
          }
          n2.failureCount++, t3.onFail == null || t3.onFail(n2.failureCount, v), Uo(w).then(function() {
            if (!kt.isFocused() || !Nn.isOnline())
              return g();
          }).then(function() {
            r ? h(v) : I();
          });
        }
      });
    }
  };
  p();
};
var Bo = function() {
  function e3() {
    this.queue = [], this.transactions = 0, this.notifyFn = function(n2) {
      n2();
    }, this.batchNotifyFn = function(n2) {
      n2();
    };
  }
  var t3 = e3.prototype;
  return t3.batch = function(r) {
    var s;
    this.transactions++;
    try {
      s = r();
    } finally {
      this.transactions--, this.transactions || this.flush();
    }
    return s;
  }, t3.schedule = function(r) {
    var s = this;
    this.transactions ? this.queue.push(r) : Xr(function() {
      s.notifyFn(r);
    });
  }, t3.batchCalls = function(r) {
    var s = this;
    return function() {
      for (var a3 = arguments.length, l = new Array(a3), u = 0; u < a3; u++)
        l[u] = arguments[u];
      s.schedule(function() {
        r.apply(void 0, l);
      });
    };
  }, t3.flush = function() {
    var r = this, s = this.queue;
    this.queue = [], s.length && Xr(function() {
      r.batchNotifyFn(function() {
        s.forEach(function(a3) {
          r.notifyFn(a3);
        });
      });
    });
  }, t3.setNotifyFunction = function(r) {
    this.notifyFn = r;
  }, t3.setBatchNotifyFunction = function(r) {
    this.batchNotifyFn = r;
  }, e3;
}();
var V = new Bo();
var qi = console;
function Cn() {
  return qi;
}
function Wo(e3) {
  qi = e3;
}
var Fo = function() {
  function e3(n2) {
    this.abortSignalConsumed = false, this.hadObservers = false, this.defaultOptions = n2.defaultOptions, this.setOptions(n2.options), this.observers = [], this.cache = n2.cache, this.queryKey = n2.queryKey, this.queryHash = n2.queryHash, this.initialState = n2.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = n2.meta, this.scheduleGc();
  }
  var t3 = e3.prototype;
  return t3.setOptions = function(r) {
    var s;
    this.options = L({}, this.defaultOptions, r), this.meta = r == null ? void 0 : r.meta, this.cacheTime = Math.max(this.cacheTime || 0, (s = this.options.cacheTime) != null ? s : 5 * 60 * 1e3);
  }, t3.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t3.scheduleGc = function() {
    var r = this;
    this.clearGcTimeout(), hr(this.cacheTime) && (this.gcTimeout = setTimeout(function() {
      r.optionalRemove();
    }, this.cacheTime));
  }, t3.clearGcTimeout = function() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }, t3.optionalRemove = function() {
    this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this));
  }, t3.setData = function(r, s) {
    var a3, l, u = this.state.data, f = Oo(r, u);
    return (a3 = (l = this.options).isDataEqual) != null && a3.call(l, u, f) ? f = u : this.options.structuralSharing !== false && (f = Ln(u, f)), this.dispatch({
      data: f,
      type: "success",
      dataUpdatedAt: s == null ? void 0 : s.updatedAt
    }), f;
  }, t3.setState = function(r, s) {
    this.dispatch({
      type: "setState",
      state: r,
      setStateOptions: s
    });
  }, t3.cancel = function(r) {
    var s, a3 = this.promise;
    return (s = this.retryer) == null || s.cancel(r), a3 ? a3.then(le).catch(le) : Promise.resolve();
  }, t3.destroy = function() {
    this.clearGcTimeout(), this.cancel({
      silent: true
    });
  }, t3.reset = function() {
    this.destroy(), this.setState(this.initialState);
  }, t3.isActive = function() {
    return this.observers.some(function(r) {
      return r.options.enabled !== false;
    });
  }, t3.isFetching = function() {
    return this.state.isFetching;
  }, t3.isStale = function() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(r) {
      return r.getCurrentResult().isStale;
    });
  }, t3.isStaleByTime = function(r) {
    return r === void 0 && (r = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !Yi(this.state.dataUpdatedAt, r);
  }, t3.onFocus = function() {
    var r, s = this.observers.find(function(a3) {
      return a3.shouldFetchOnWindowFocus();
    });
    s && s.refetch(), (r = this.retryer) == null || r.continue();
  }, t3.onOnline = function() {
    var r, s = this.observers.find(function(a3) {
      return a3.shouldFetchOnReconnect();
    });
    s && s.refetch(), (r = this.retryer) == null || r.continue();
  }, t3.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && (this.observers.push(r), this.hadObservers = true, this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: r
    }));
  }, t3.removeObserver = function(r) {
    this.observers.indexOf(r) !== -1 && (this.observers = this.observers.filter(function(s) {
      return s !== r;
    }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
      revert: true
    }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: r
    }));
  }, t3.getObserversCount = function() {
    return this.observers.length;
  }, t3.invalidate = function() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }, t3.fetch = function(r, s) {
    var a3 = this, l, u, f;
    if (this.state.isFetching) {
      if (this.state.dataUpdatedAt && (s == null ? void 0 : s.cancelRefetch))
        this.cancel({
          silent: true
        });
      else if (this.promise) {
        var h;
        return (h = this.retryer) == null || h.continueRetry(), this.promise;
      }
    }
    if (r && this.setOptions(r), !this.options.queryFn) {
      var g = this.observers.find(function(C) {
        return C.options.queryFn;
      });
      g && this.setOptions(g.options);
    }
    var p = jn(this.queryKey), I = Gi(), N = {
      queryKey: p,
      pageParam: void 0,
      meta: this.meta
    };
    Object.defineProperty(N, "signal", {
      enumerable: true,
      get: function() {
        if (I)
          return a3.abortSignalConsumed = true, I.signal;
      }
    });
    var v = function() {
      return a3.options.queryFn ? (a3.abortSignalConsumed = false, a3.options.queryFn(N)) : Promise.reject("Missing queryFn");
    }, m = {
      fetchOptions: s,
      options: this.options,
      queryKey: p,
      state: this.state,
      fetchFn: v,
      meta: this.meta
    };
    if ((l = this.options.behavior) != null && l.onFetch) {
      var D;
      (D = this.options.behavior) == null || D.onFetch(m);
    }
    if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((u = m.fetchOptions) == null ? void 0 : u.meta)) {
      var b;
      this.dispatch({
        type: "fetch",
        meta: (b = m.fetchOptions) == null ? void 0 : b.meta
      });
    }
    return this.retryer = new Vi({
      fn: m.fetchFn,
      abort: I == null || (f = I.abort) == null ? void 0 : f.bind(I),
      onSuccess: function(w) {
        a3.setData(w), a3.cache.config.onSuccess == null || a3.cache.config.onSuccess(w, a3), a3.cacheTime === 0 && a3.optionalRemove();
      },
      onError: function(w) {
        In(w) && w.silent || a3.dispatch({
          type: "error",
          error: w
        }), In(w) || (a3.cache.config.onError == null || a3.cache.config.onError(w, a3), Cn().error(w)), a3.cacheTime === 0 && a3.optionalRemove();
      },
      onFail: function() {
        a3.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        a3.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        a3.dispatch({
          type: "continue"
        });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay
    }), this.promise = this.retryer.promise, this.promise;
  }, t3.dispatch = function(r) {
    var s = this;
    this.state = this.reducer(this.state, r), V.batch(function() {
      s.observers.forEach(function(a3) {
        a3.onQueryUpdate(r);
      }), s.cache.notify({
        query: s,
        type: "queryUpdated",
        action: r
      });
    });
  }, t3.getDefaultState = function(r) {
    var s = typeof r.initialData == "function" ? r.initialData() : r.initialData, a3 = typeof r.initialData < "u", l = a3 ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0, u = typeof s < "u";
    return {
      data: s,
      dataUpdateCount: 0,
      dataUpdatedAt: u ? l ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchMeta: null,
      isFetching: false,
      isInvalidated: false,
      isPaused: false,
      status: u ? "success" : "idle"
    };
  }, t3.reducer = function(r, s) {
    var a3, l;
    switch (s.type) {
      case "failed":
        return L({}, r, {
          fetchFailureCount: r.fetchFailureCount + 1
        });
      case "pause":
        return L({}, r, {
          isPaused: true
        });
      case "continue":
        return L({}, r, {
          isPaused: false
        });
      case "fetch":
        return L({}, r, {
          fetchFailureCount: 0,
          fetchMeta: (a3 = s.meta) != null ? a3 : null,
          isFetching: true,
          isPaused: false
        }, !r.dataUpdatedAt && {
          error: null,
          status: "loading"
        });
      case "success":
        return L({}, r, {
          data: s.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: (l = s.dataUpdatedAt) != null ? l : Date.now(),
          error: null,
          fetchFailureCount: 0,
          isFetching: false,
          isInvalidated: false,
          isPaused: false,
          status: "success"
        });
      case "error":
        var u = s.error;
        return In(u) && u.revert && this.revertState ? L({}, this.revertState) : L({}, r, {
          error: u,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          isFetching: false,
          isPaused: false,
          status: "error"
        });
      case "invalidate":
        return L({}, r, {
          isInvalidated: true
        });
      case "setState":
        return L({}, r, s.state);
      default:
        return r;
    }
  }, e3;
}();
var Yo = function(e3) {
  Gt(t3, e3);
  function t3(r) {
    var s;
    return s = e3.call(this) || this, s.config = r || {}, s.queries = [], s.queriesMap = {}, s;
  }
  var n2 = t3.prototype;
  return n2.build = function(s, a3, l) {
    var u, f = a3.queryKey, h = (u = a3.queryHash) != null ? u : xr(f, a3), g = this.get(h);
    return g || (g = new Fo({
      cache: this,
      queryKey: f,
      queryHash: h,
      options: s.defaultQueryOptions(a3),
      state: l,
      defaultOptions: s.getQueryDefaults(f),
      meta: a3.meta
    }), this.add(g)), g;
  }, n2.add = function(s) {
    this.queriesMap[s.queryHash] || (this.queriesMap[s.queryHash] = s, this.queries.push(s), this.notify({
      type: "queryAdded",
      query: s
    }));
  }, n2.remove = function(s) {
    var a3 = this.queriesMap[s.queryHash];
    a3 && (s.destroy(), this.queries = this.queries.filter(function(l) {
      return l !== s;
    }), a3 === s && delete this.queriesMap[s.queryHash], this.notify({
      type: "queryRemoved",
      query: s
    }));
  }, n2.clear = function() {
    var s = this;
    V.batch(function() {
      s.queries.forEach(function(a3) {
        s.remove(a3);
      });
    });
  }, n2.get = function(s) {
    return this.queriesMap[s];
  }, n2.getAll = function() {
    return this.queries;
  }, n2.find = function(s, a3) {
    var l = Ve(s, a3), u = l[0];
    return typeof u.exact > "u" && (u.exact = true), this.queries.find(function(f) {
      return Zr(u, f);
    });
  }, n2.findAll = function(s, a3) {
    var l = Ve(s, a3), u = l[0];
    return Object.keys(u).length > 0 ? this.queries.filter(function(f) {
      return Zr(u, f);
    }) : this.queries;
  }, n2.notify = function(s) {
    var a3 = this;
    V.batch(function() {
      a3.listeners.forEach(function(l) {
        l(s);
      });
    });
  }, n2.onFocus = function() {
    var s = this;
    V.batch(function() {
      s.queries.forEach(function(a3) {
        a3.onFocus();
      });
    });
  }, n2.onOnline = function() {
    var s = this;
    V.batch(function() {
      s.queries.forEach(function(a3) {
        a3.onOnline();
      });
    });
  }, t3;
}(Zt);
var _o = function() {
  function e3(n2) {
    this.options = L({}, n2.defaultOptions, n2.options), this.mutationId = n2.mutationId, this.mutationCache = n2.mutationCache, this.observers = [], this.state = n2.state || Go(), this.meta = n2.meta;
  }
  var t3 = e3.prototype;
  return t3.setState = function(r) {
    this.dispatch({
      type: "setState",
      state: r
    });
  }, t3.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && this.observers.push(r);
  }, t3.removeObserver = function(r) {
    this.observers = this.observers.filter(function(s) {
      return s !== r;
    });
  }, t3.cancel = function() {
    return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(le).catch(le)) : Promise.resolve();
  }, t3.continue = function() {
    return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();
  }, t3.execute = function() {
    var r = this, s, a3 = this.state.status === "loading", l = Promise.resolve();
    return a3 || (this.dispatch({
      type: "loading",
      variables: this.options.variables
    }), l = l.then(function() {
      r.mutationCache.config.onMutate == null || r.mutationCache.config.onMutate(r.state.variables, r);
    }).then(function() {
      return r.options.onMutate == null ? void 0 : r.options.onMutate(r.state.variables);
    }).then(function(u) {
      u !== r.state.context && r.dispatch({
        type: "loading",
        context: u,
        variables: r.state.variables
      });
    })), l.then(function() {
      return r.executeMutation();
    }).then(function(u) {
      s = u, r.mutationCache.config.onSuccess == null || r.mutationCache.config.onSuccess(s, r.state.variables, r.state.context, r);
    }).then(function() {
      return r.options.onSuccess == null ? void 0 : r.options.onSuccess(s, r.state.variables, r.state.context);
    }).then(function() {
      return r.options.onSettled == null ? void 0 : r.options.onSettled(s, null, r.state.variables, r.state.context);
    }).then(function() {
      return r.dispatch({
        type: "success",
        data: s
      }), s;
    }).catch(function(u) {
      return r.mutationCache.config.onError == null || r.mutationCache.config.onError(u, r.state.variables, r.state.context, r), Cn().error(u), Promise.resolve().then(function() {
        return r.options.onError == null ? void 0 : r.options.onError(u, r.state.variables, r.state.context);
      }).then(function() {
        return r.options.onSettled == null ? void 0 : r.options.onSettled(void 0, u, r.state.variables, r.state.context);
      }).then(function() {
        throw r.dispatch({
          type: "error",
          error: u
        }), u;
      });
    });
  }, t3.executeMutation = function() {
    var r = this, s;
    return this.retryer = new Vi({
      fn: function() {
        return r.options.mutationFn ? r.options.mutationFn(r.state.variables) : Promise.reject("No mutationFn found");
      },
      onFail: function() {
        r.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        r.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        r.dispatch({
          type: "continue"
        });
      },
      retry: (s = this.options.retry) != null ? s : 0,
      retryDelay: this.options.retryDelay
    }), this.retryer.promise;
  }, t3.dispatch = function(r) {
    var s = this;
    this.state = Zo(this.state, r), V.batch(function() {
      s.observers.forEach(function(a3) {
        a3.onMutationUpdate(r);
      }), s.mutationCache.notify(s);
    });
  }, e3;
}();
function Go() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
function Zo(e3, t3) {
  switch (t3.type) {
    case "failed":
      return L({}, e3, {
        failureCount: e3.failureCount + 1
      });
    case "pause":
      return L({}, e3, {
        isPaused: true
      });
    case "continue":
      return L({}, e3, {
        isPaused: false
      });
    case "loading":
      return L({}, e3, {
        context: t3.context,
        data: void 0,
        error: null,
        isPaused: false,
        status: "loading",
        variables: t3.variables
      });
    case "success":
      return L({}, e3, {
        data: t3.data,
        error: null,
        status: "success",
        isPaused: false
      });
    case "error":
      return L({}, e3, {
        data: void 0,
        error: t3.error,
        failureCount: e3.failureCount + 1,
        isPaused: false,
        status: "error"
      });
    case "setState":
      return L({}, e3, t3.state);
    default:
      return e3;
  }
}
var Vo = function(e3) {
  Gt(t3, e3);
  function t3(r) {
    var s;
    return s = e3.call(this) || this, s.config = r || {}, s.mutations = [], s.mutationId = 0, s;
  }
  var n2 = t3.prototype;
  return n2.build = function(s, a3, l) {
    var u = new _o({
      mutationCache: this,
      mutationId: ++this.mutationId,
      options: s.defaultMutationOptions(a3),
      state: l,
      defaultOptions: a3.mutationKey ? s.getMutationDefaults(a3.mutationKey) : void 0,
      meta: a3.meta
    });
    return this.add(u), u;
  }, n2.add = function(s) {
    this.mutations.push(s), this.notify(s);
  }, n2.remove = function(s) {
    this.mutations = this.mutations.filter(function(a3) {
      return a3 !== s;
    }), s.cancel(), this.notify(s);
  }, n2.clear = function() {
    var s = this;
    V.batch(function() {
      s.mutations.forEach(function(a3) {
        s.remove(a3);
      });
    });
  }, n2.getAll = function() {
    return this.mutations;
  }, n2.find = function(s) {
    return typeof s.exact > "u" && (s.exact = true), this.mutations.find(function(a3) {
      return Vr(s, a3);
    });
  }, n2.findAll = function(s) {
    return this.mutations.filter(function(a3) {
      return Vr(s, a3);
    });
  }, n2.notify = function(s) {
    var a3 = this;
    V.batch(function() {
      a3.listeners.forEach(function(l) {
        l(s);
      });
    });
  }, n2.onFocus = function() {
    this.resumePausedMutations();
  }, n2.onOnline = function() {
    this.resumePausedMutations();
  }, n2.resumePausedMutations = function() {
    var s = this.mutations.filter(function(a3) {
      return a3.state.isPaused;
    });
    return V.batch(function() {
      return s.reduce(function(a3, l) {
        return a3.then(function() {
          return l.continue().catch(le);
        });
      }, Promise.resolve());
    });
  }, t3;
}(Zt);
function qo() {
  return {
    onFetch: function(t3) {
      t3.fetchFn = function() {
        var n2, r, s, a3, l, u, f = (n2 = t3.fetchOptions) == null || (r = n2.meta) == null ? void 0 : r.refetchPage, h = (s = t3.fetchOptions) == null || (a3 = s.meta) == null ? void 0 : a3.fetchMore, g = h == null ? void 0 : h.pageParam, p = (h == null ? void 0 : h.direction) === "forward", I = (h == null ? void 0 : h.direction) === "backward", N = ((l = t3.state.data) == null ? void 0 : l.pages) || [], v = ((u = t3.state.data) == null ? void 0 : u.pageParams) || [], m = Gi(), D = m == null ? void 0 : m.signal, b = v, C = false, w = t3.options.queryFn || function() {
          return Promise.reject("Missing queryFn");
        }, P = function(Me, Te, j, O) {
          return b = O ? [Te].concat(b) : [].concat(b, [Te]), O ? [j].concat(Me) : [].concat(Me, [j]);
        }, x = function(Me, Te, j, O) {
          if (C)
            return Promise.reject("Cancelled");
          if (typeof j > "u" && !Te && Me.length)
            return Promise.resolve(Me);
          var S = {
            queryKey: t3.queryKey,
            signal: D,
            pageParam: j,
            meta: t3.meta
          }, Y = w(S), X = Promise.resolve(Y).then(function(ee) {
            return P(Me, j, ee, O);
          });
          if (Sn(Y)) {
            var z = X;
            z.cancel = Y.cancel;
          }
          return X;
        }, U;
        if (!N.length)
          U = x([]);
        else if (p) {
          var q = typeof g < "u", k = q ? g : Hr(t3.options, N);
          U = x(N, q, k);
        } else if (I) {
          var ue = typeof g < "u", ne = ue ? g : Xo(t3.options, N);
          U = x(N, ue, ne, true);
        } else
          (function() {
            b = [];
            var je = typeof t3.options.getNextPageParam > "u", Me = f && N[0] ? f(N[0], 0, N) : true;
            U = Me ? x([], je, v[0]) : Promise.resolve(P([], v[0], N[0]));
            for (var Te = function(S) {
              U = U.then(function(Y) {
                var X = f && N[S] ? f(N[S], S, N) : true;
                if (X) {
                  var z = je ? v[S] : Hr(t3.options, Y);
                  return x(Y, je, z);
                }
                return Promise.resolve(P(Y, v[S], N[S]));
              });
            }, j = 1; j < N.length; j++)
              Te(j);
          })();
        var me = U.then(function(je) {
          return {
            pages: je,
            pageParams: b
          };
        }), De = me;
        return De.cancel = function() {
          C = true, m == null ? void 0 : m.abort(), Sn(U) && U.cancel();
        }, me;
      };
    }
  };
}
function Hr(e3, t3) {
  return e3.getNextPageParam == null ? void 0 : e3.getNextPageParam(t3[t3.length - 1], t3);
}
function Xo(e3, t3) {
  return e3.getPreviousPageParam == null ? void 0 : e3.getPreviousPageParam(t3[0], t3);
}
var Ho = function() {
  function e3(n2) {
    n2 === void 0 && (n2 = {}), this.queryCache = n2.queryCache || new Yo(), this.mutationCache = n2.mutationCache || new Vo(), this.defaultOptions = n2.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];
  }
  var t3 = e3.prototype;
  return t3.mount = function() {
    var r = this;
    this.unsubscribeFocus = kt.subscribe(function() {
      kt.isFocused() && Nn.isOnline() && (r.mutationCache.onFocus(), r.queryCache.onFocus());
    }), this.unsubscribeOnline = Nn.subscribe(function() {
      kt.isFocused() && Nn.isOnline() && (r.mutationCache.onOnline(), r.queryCache.onOnline());
    });
  }, t3.unmount = function() {
    var r, s;
    (r = this.unsubscribeFocus) == null || r.call(this), (s = this.unsubscribeOnline) == null || s.call(this);
  }, t3.isFetching = function(r, s) {
    var a3 = Ve(r, s), l = a3[0];
    return l.fetching = true, this.queryCache.findAll(l).length;
  }, t3.isMutating = function(r) {
    return this.mutationCache.findAll(L({}, r, {
      fetching: true
    })).length;
  }, t3.getQueryData = function(r, s) {
    var a3;
    return (a3 = this.queryCache.find(r, s)) == null ? void 0 : a3.state.data;
  }, t3.getQueriesData = function(r) {
    return this.getQueryCache().findAll(r).map(function(s) {
      var a3 = s.queryKey, l = s.state, u = l.data;
      return [a3, u];
    });
  }, t3.setQueryData = function(r, s, a3) {
    var l = Mn(r), u = this.defaultQueryOptions(l);
    return this.queryCache.build(this, u).setData(s, a3);
  }, t3.setQueriesData = function(r, s, a3) {
    var l = this;
    return V.batch(function() {
      return l.getQueryCache().findAll(r).map(function(u) {
        var f = u.queryKey;
        return [f, l.setQueryData(f, s, a3)];
      });
    });
  }, t3.getQueryState = function(r, s) {
    var a3;
    return (a3 = this.queryCache.find(r, s)) == null ? void 0 : a3.state;
  }, t3.removeQueries = function(r, s) {
    var a3 = Ve(r, s), l = a3[0], u = this.queryCache;
    V.batch(function() {
      u.findAll(l).forEach(function(f) {
        u.remove(f);
      });
    });
  }, t3.resetQueries = function(r, s, a3) {
    var l = this, u = Ve(r, s, a3), f = u[0], h = u[1], g = this.queryCache, p = L({}, f, {
      active: true
    });
    return V.batch(function() {
      return g.findAll(f).forEach(function(I) {
        I.reset();
      }), l.refetchQueries(p, h);
    });
  }, t3.cancelQueries = function(r, s, a3) {
    var l = this, u = Ve(r, s, a3), f = u[0], h = u[1], g = h === void 0 ? {} : h;
    typeof g.revert > "u" && (g.revert = true);
    var p = V.batch(function() {
      return l.queryCache.findAll(f).map(function(I) {
        return I.cancel(g);
      });
    });
    return Promise.all(p).then(le).catch(le);
  }, t3.invalidateQueries = function(r, s, a3) {
    var l, u, f, h = this, g = Ve(r, s, a3), p = g[0], I = g[1], N = L({}, p, {
      // if filters.refetchActive is not provided and filters.active is explicitly false,
      // e.g. invalidateQueries({ active: false }), we don't want to refetch active queries
      active: (l = (u = p.refetchActive) != null ? u : p.active) != null ? l : true,
      inactive: (f = p.refetchInactive) != null ? f : false
    });
    return V.batch(function() {
      return h.queryCache.findAll(p).forEach(function(v) {
        v.invalidate();
      }), h.refetchQueries(N, I);
    });
  }, t3.refetchQueries = function(r, s, a3) {
    var l = this, u = Ve(r, s, a3), f = u[0], h = u[1], g = V.batch(function() {
      return l.queryCache.findAll(f).map(function(I) {
        return I.fetch(void 0, L({}, h, {
          meta: {
            refetchPage: f == null ? void 0 : f.refetchPage
          }
        }));
      });
    }), p = Promise.all(g).then(le);
    return (h == null ? void 0 : h.throwOnError) || (p = p.catch(le)), p;
  }, t3.fetchQuery = function(r, s, a3) {
    var l = Mn(r, s, a3), u = this.defaultQueryOptions(l);
    typeof u.retry > "u" && (u.retry = false);
    var f = this.queryCache.build(this, u);
    return f.isStaleByTime(u.staleTime) ? f.fetch(u) : Promise.resolve(f.state.data);
  }, t3.prefetchQuery = function(r, s, a3) {
    return this.fetchQuery(r, s, a3).then(le).catch(le);
  }, t3.fetchInfiniteQuery = function(r, s, a3) {
    var l = Mn(r, s, a3);
    return l.behavior = qo(), this.fetchQuery(l);
  }, t3.prefetchInfiniteQuery = function(r, s, a3) {
    return this.fetchInfiniteQuery(r, s, a3).then(le).catch(le);
  }, t3.cancelMutations = function() {
    var r = this, s = V.batch(function() {
      return r.mutationCache.getAll().map(function(a3) {
        return a3.cancel();
      });
    });
    return Promise.all(s).then(le).catch(le);
  }, t3.resumePausedMutations = function() {
    return this.getMutationCache().resumePausedMutations();
  }, t3.executeMutation = function(r) {
    return this.mutationCache.build(this, r).execute();
  }, t3.getQueryCache = function() {
    return this.queryCache;
  }, t3.getMutationCache = function() {
    return this.mutationCache;
  }, t3.getDefaultOptions = function() {
    return this.defaultOptions;
  }, t3.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t3.setQueryDefaults = function(r, s) {
    var a3 = this.queryDefaults.find(function(l) {
      return rt(r) === rt(l.queryKey);
    });
    a3 ? a3.defaultOptions = s : this.queryDefaults.push({
      queryKey: r,
      defaultOptions: s
    });
  }, t3.getQueryDefaults = function(r) {
    var s;
    return r ? (s = this.queryDefaults.find(function(a3) {
      return Tn(r, a3.queryKey);
    })) == null ? void 0 : s.defaultOptions : void 0;
  }, t3.setMutationDefaults = function(r, s) {
    var a3 = this.mutationDefaults.find(function(l) {
      return rt(r) === rt(l.mutationKey);
    });
    a3 ? a3.defaultOptions = s : this.mutationDefaults.push({
      mutationKey: r,
      defaultOptions: s
    });
  }, t3.getMutationDefaults = function(r) {
    var s;
    return r ? (s = this.mutationDefaults.find(function(a3) {
      return Tn(r, a3.mutationKey);
    })) == null ? void 0 : s.defaultOptions : void 0;
  }, t3.defaultQueryOptions = function(r) {
    if (r == null ? void 0 : r._defaulted)
      return r;
    var s = L({}, this.defaultOptions.queries, this.getQueryDefaults(r == null ? void 0 : r.queryKey), r, {
      _defaulted: true
    });
    return !s.queryHash && s.queryKey && (s.queryHash = xr(s.queryKey, s)), s;
  }, t3.defaultQueryObserverOptions = function(r) {
    return this.defaultQueryOptions(r);
  }, t3.defaultMutationOptions = function(r) {
    return (r == null ? void 0 : r._defaulted) ? r : L({}, this.defaultOptions.mutations, this.getMutationDefaults(r == null ? void 0 : r.mutationKey), r, {
      _defaulted: true
    });
  }, t3.clear = function() {
    this.queryCache.clear(), this.mutationCache.clear();
  }, e3;
}();
var Ko = function(e3) {
  Gt(t3, e3);
  function t3(r, s) {
    var a3;
    return a3 = e3.call(this) || this, a3.client = r, a3.options = s, a3.trackedProps = [], a3.selectError = null, a3.bindMethods(), a3.setOptions(s), a3;
  }
  var n2 = t3.prototype;
  return n2.bindMethods = function() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }, n2.onSubscribe = function() {
    this.listeners.length === 1 && (this.currentQuery.addObserver(this), Kr(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }, n2.onUnsubscribe = function() {
    this.listeners.length || this.destroy();
  }, n2.shouldFetchOnReconnect = function() {
    return yr(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }, n2.shouldFetchOnWindowFocus = function() {
    return yr(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }, n2.destroy = function() {
    this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this);
  }, n2.setOptions = function(s, a3) {
    var l = this.options, u = this.currentQuery;
    if (this.options = this.client.defaultQueryObserverOptions(s), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = l.queryKey), this.updateQuery();
    var f = this.hasListeners();
    f && Jr(this.currentQuery, u, this.options, l) && this.executeFetch(), this.updateResult(a3), f && (this.currentQuery !== u || this.options.enabled !== l.enabled || this.options.staleTime !== l.staleTime) && this.updateStaleTimeout();
    var h = this.computeRefetchInterval();
    f && (this.currentQuery !== u || this.options.enabled !== l.enabled || h !== this.currentRefetchInterval) && this.updateRefetchInterval(h);
  }, n2.getOptimisticResult = function(s) {
    var a3 = this.client.defaultQueryObserverOptions(s), l = this.client.getQueryCache().build(this.client, a3);
    return this.createResult(l, a3);
  }, n2.getCurrentResult = function() {
    return this.currentResult;
  }, n2.trackResult = function(s, a3) {
    var l = this, u = {}, f = function(g) {
      l.trackedProps.includes(g) || l.trackedProps.push(g);
    };
    return Object.keys(s).forEach(function(h) {
      Object.defineProperty(u, h, {
        configurable: false,
        enumerable: true,
        get: function() {
          return f(h), s[h];
        }
      });
    }), (a3.useErrorBoundary || a3.suspense) && f("error"), u;
  }, n2.getNextResult = function(s) {
    var a3 = this;
    return new Promise(function(l, u) {
      var f = a3.subscribe(function(h) {
        h.isFetching || (f(), h.isError && (s == null ? void 0 : s.throwOnError) ? u(h.error) : l(h));
      });
    });
  }, n2.getCurrentQuery = function() {
    return this.currentQuery;
  }, n2.remove = function() {
    this.client.getQueryCache().remove(this.currentQuery);
  }, n2.refetch = function(s) {
    return this.fetch(L({}, s, {
      meta: {
        refetchPage: s == null ? void 0 : s.refetchPage
      }
    }));
  }, n2.fetchOptimistic = function(s) {
    var a3 = this, l = this.client.defaultQueryObserverOptions(s), u = this.client.getQueryCache().build(this.client, l);
    return u.fetch().then(function() {
      return a3.createResult(u, l);
    });
  }, n2.fetch = function(s) {
    var a3 = this;
    return this.executeFetch(s).then(function() {
      return a3.updateResult(), a3.currentResult;
    });
  }, n2.executeFetch = function(s) {
    this.updateQuery();
    var a3 = this.currentQuery.fetch(this.options, s);
    return (s == null ? void 0 : s.throwOnError) || (a3 = a3.catch(le)), a3;
  }, n2.updateStaleTimeout = function() {
    var s = this;
    if (this.clearStaleTimeout(), !(Dn || this.currentResult.isStale || !hr(this.options.staleTime))) {
      var a3 = Yi(this.currentResult.dataUpdatedAt, this.options.staleTime), l = a3 + 1;
      this.staleTimeoutId = setTimeout(function() {
        s.currentResult.isStale || s.updateResult();
      }, l);
    }
  }, n2.computeRefetchInterval = function() {
    var s;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (s = this.options.refetchInterval) != null ? s : false;
  }, n2.updateRefetchInterval = function(s) {
    var a3 = this;
    this.clearRefetchInterval(), this.currentRefetchInterval = s, !(Dn || this.options.enabled === false || !hr(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(function() {
      (a3.options.refetchIntervalInBackground || kt.isFocused()) && a3.executeFetch();
    }, this.currentRefetchInterval));
  }, n2.updateTimers = function() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }, n2.clearTimers = function() {
    this.clearStaleTimeout(), this.clearRefetchInterval();
  }, n2.clearStaleTimeout = function() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }, n2.clearRefetchInterval = function() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }, n2.createResult = function(s, a3) {
    var l = this.currentQuery, u = this.options, f = this.currentResult, h = this.currentResultState, g = this.currentResultOptions, p = s !== l, I = p ? s.state : this.currentQueryInitialState, N = p ? this.currentResult : this.previousQueryResult, v = s.state, m = v.dataUpdatedAt, D = v.error, b = v.errorUpdatedAt, C = v.isFetching, w = v.status, P = false, x = false, U;
    if (a3.optimisticResults) {
      var q = this.hasListeners(), k = !q && Kr(s, a3), ue = q && Jr(s, l, a3, u);
      (k || ue) && (C = true, m || (w = "loading"));
    }
    if (a3.keepPreviousData && !v.dataUpdateCount && (N == null ? void 0 : N.isSuccess) && w !== "error")
      U = N.data, m = N.dataUpdatedAt, w = N.status, P = true;
    else if (a3.select && typeof v.data < "u")
      if (f && v.data === (h == null ? void 0 : h.data) && a3.select === this.selectFn)
        U = this.selectResult;
      else
        try {
          this.selectFn = a3.select, U = a3.select(v.data), a3.structuralSharing !== false && (U = Ln(f == null ? void 0 : f.data, U)), this.selectResult = U, this.selectError = null;
        } catch (De) {
          Cn().error(De), this.selectError = De;
        }
    else
      U = v.data;
    if (typeof a3.placeholderData < "u" && typeof U > "u" && (w === "loading" || w === "idle")) {
      var ne;
      if ((f == null ? void 0 : f.isPlaceholderData) && a3.placeholderData === (g == null ? void 0 : g.placeholderData))
        ne = f.data;
      else if (ne = typeof a3.placeholderData == "function" ? a3.placeholderData() : a3.placeholderData, a3.select && typeof ne < "u")
        try {
          ne = a3.select(ne), a3.structuralSharing !== false && (ne = Ln(f == null ? void 0 : f.data, ne)), this.selectError = null;
        } catch (De) {
          Cn().error(De), this.selectError = De;
        }
      typeof ne < "u" && (w = "success", U = ne, x = true);
    }
    this.selectError && (D = this.selectError, U = this.selectResult, b = Date.now(), w = "error");
    var me = {
      status: w,
      isLoading: w === "loading",
      isSuccess: w === "success",
      isError: w === "error",
      isIdle: w === "idle",
      data: U,
      dataUpdatedAt: m,
      error: D,
      errorUpdatedAt: b,
      failureCount: v.fetchFailureCount,
      errorUpdateCount: v.errorUpdateCount,
      isFetched: v.dataUpdateCount > 0 || v.errorUpdateCount > 0,
      isFetchedAfterMount: v.dataUpdateCount > I.dataUpdateCount || v.errorUpdateCount > I.errorUpdateCount,
      isFetching: C,
      isRefetching: C && w !== "loading",
      isLoadingError: w === "error" && v.dataUpdatedAt === 0,
      isPlaceholderData: x,
      isPreviousData: P,
      isRefetchError: w === "error" && v.dataUpdatedAt !== 0,
      isStale: zr(s, a3),
      refetch: this.refetch,
      remove: this.remove
    };
    return me;
  }, n2.shouldNotifyListeners = function(s, a3) {
    if (!a3)
      return true;
    var l = this.options, u = l.notifyOnChangeProps, f = l.notifyOnChangePropsExclusions;
    if (!u && !f || u === "tracked" && !this.trackedProps.length)
      return true;
    var h = u === "tracked" ? this.trackedProps : u;
    return Object.keys(s).some(function(g) {
      var p = g, I = s[p] !== a3[p], N = h == null ? void 0 : h.some(function(m) {
        return m === g;
      }), v = f == null ? void 0 : f.some(function(m) {
        return m === g;
      });
      return I && !v && (!h || N);
    });
  }, n2.updateResult = function(s) {
    var a3 = this.currentResult;
    if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !Ro(this.currentResult, a3)) {
      var l = {
        cache: true
      };
      (s == null ? void 0 : s.listeners) !== false && this.shouldNotifyListeners(this.currentResult, a3) && (l.listeners = true), this.notify(L({}, l, s));
    }
  }, n2.updateQuery = function() {
    var s = this.client.getQueryCache().build(this.client, this.options);
    if (s !== this.currentQuery) {
      var a3 = this.currentQuery;
      this.currentQuery = s, this.currentQueryInitialState = s.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (a3 == null ? void 0 : a3.removeObserver(this), s.addObserver(this));
    }
  }, n2.onQueryUpdate = function(s) {
    var a3 = {};
    s.type === "success" ? a3.onSuccess = true : s.type === "error" && !In(s.error) && (a3.onError = true), this.updateResult(a3), this.hasListeners() && this.updateTimers();
  }, n2.notify = function(s) {
    var a3 = this;
    V.batch(function() {
      s.onSuccess ? (a3.options.onSuccess == null || a3.options.onSuccess(a3.currentResult.data), a3.options.onSettled == null || a3.options.onSettled(a3.currentResult.data, null)) : s.onError && (a3.options.onError == null || a3.options.onError(a3.currentResult.error), a3.options.onSettled == null || a3.options.onSettled(void 0, a3.currentResult.error)), s.listeners && a3.listeners.forEach(function(l) {
        l(a3.currentResult);
      }), s.cache && a3.client.getQueryCache().notify({
        query: a3.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }, t3;
}(Zt);
function Jo(e3, t3) {
  return t3.enabled !== false && !e3.state.dataUpdatedAt && !(e3.state.status === "error" && t3.retryOnMount === false);
}
function Kr(e3, t3) {
  return Jo(e3, t3) || e3.state.dataUpdatedAt > 0 && yr(e3, t3, t3.refetchOnMount);
}
function yr(e3, t3, n2) {
  if (t3.enabled !== false) {
    var r = typeof n2 == "function" ? n2(e3) : n2;
    return r === "always" || r !== false && zr(e3, t3);
  }
  return false;
}
function Jr(e3, t3, n2, r) {
  return n2.enabled !== false && (e3 !== t3 || r.enabled === false) && (!n2.suspense || e3.state.status !== "error") && zr(e3, n2);
}
function zr(e3, t3) {
  return e3.isStaleByTime(t3.staleTime);
}
var $o = import_react_dom.default.unstable_batchedUpdates;
V.setBatchNotifyFunction($o);
var eu = console;
Wo(eu);
var $r = import_react.default.createContext(void 0);
var Xi = import_react.default.createContext(false);
function Hi(e3) {
  return e3 && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = $r), window.ReactQueryClientContext) : $r;
}
var tu = function() {
  var t3 = import_react.default.useContext(Hi(import_react.default.useContext(Xi)));
  if (!t3)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t3;
};
var nu = function(t3) {
  var n2 = t3.client, r = t3.contextSharing, s = r === void 0 ? false : r, a3 = t3.children;
  import_react.default.useEffect(function() {
    return n2.mount(), function() {
      n2.unmount();
    };
  }, [n2]);
  var l = Hi(s);
  return (0, import_jsx_runtime.jsx)(Xi.Provider, {
    value: s,
    children: (0, import_jsx_runtime.jsx)(l.Provider, {
      value: n2,
      children: a3
    })
  });
};
function ru() {
  var e3 = false;
  return {
    clearReset: function() {
      e3 = false;
    },
    reset: function() {
      e3 = true;
    },
    isReset: function() {
      return e3;
    }
  };
}
var iu = import_react.default.createContext(ru());
var su = function() {
  return import_react.default.useContext(iu);
};
function au(e3, t3, n2) {
  return typeof t3 == "function" ? t3.apply(void 0, n2) : typeof t3 == "boolean" ? t3 : !!e3;
}
function ou(e3, t3) {
  var n2 = import_react.default.useRef(false), r = import_react.default.useState(0), s = r[1], a3 = tu(), l = su(), u = a3.defaultQueryObserverOptions(e3);
  u.optimisticResults = true, u.onError && (u.onError = V.batchCalls(u.onError)), u.onSuccess && (u.onSuccess = V.batchCalls(u.onSuccess)), u.onSettled && (u.onSettled = V.batchCalls(u.onSettled)), u.suspense && (typeof u.staleTime != "number" && (u.staleTime = 1e3), u.cacheTime === 0 && (u.cacheTime = 1)), (u.suspense || u.useErrorBoundary) && (l.isReset() || (u.retryOnMount = false));
  var f = import_react.default.useState(function() {
    return new t3(a3, u);
  }), h = f[0], g = h.getOptimisticResult(u);
  if (import_react.default.useEffect(function() {
    n2.current = true, l.clearReset();
    var p = h.subscribe(V.batchCalls(function() {
      n2.current && s(function(I) {
        return I + 1;
      });
    }));
    return h.updateResult(), function() {
      n2.current = false, p();
    };
  }, [l, h]), import_react.default.useEffect(function() {
    h.setOptions(u, {
      listeners: false
    });
  }, [u, h]), u.suspense && g.isLoading)
    throw h.fetchOptimistic(u).then(function(p) {
      var I = p.data;
      u.onSuccess == null || u.onSuccess(I), u.onSettled == null || u.onSettled(I, null);
    }).catch(function(p) {
      l.clearReset(), u.onError == null || u.onError(p), u.onSettled == null || u.onSettled(void 0, p);
    });
  if (g.isError && !l.isReset() && !g.isFetching && au(u.suspense, u.useErrorBoundary, [g.error, h.getCurrentQuery()]))
    throw g.error;
  return u.notifyOnChangeProps === "tracked" && (g = h.trackResult(g, u)), g;
}
function uu(e3, t3, n2) {
  var r = Mn(e3, t3, n2);
  return ou(r, Ko);
}
var Ki = ((e3) => (e3.COIN_BALANCE = "SUIET_COIN_BALANCE", e3))(Ki || {});
function cu(e3, t3) {
  const n2 = new URLSearchParams(t3);
  return e3 + "?" + n2.toString();
}
function lu(e3) {
  const t3 = _t();
  return e3 ? (0, import_react.useMemo)(() => t3.chains.find((n2) => n2.id === e3), [e3, t3.chains]) : t3.chain;
}
function fu(e3) {
  var _a2;
  const t3 = _t(), {
    address: n2 = t3.address,
    typeArg: r = SUI_TYPE_ARG,
    chainId: s = (_a2 = t3.chain) == null ? void 0 : _a2.id
  } = e3 || {}, a3 = lu(s), l = cu(Ki.COIN_BALANCE, {
    address: n2,
    typeArg: r,
    chainId: s
  }), u = (0, import_react.useCallback)(() => !n2 || !a3 ? BigInt(0) : new Na(n2, {
    chainRpcUrl: a3.rpcUrl
  }).getCoinBalance(r), [a3, n2]);
  return uu(l, u, {
    initialData: BigInt(0)
  });
}
function du(e3) {
  const {
    typeArg: t3,
    chainId: n2
  } = e3 || {}, r = fu({
    typeArg: t3,
    chainId: n2
  });
  return Object.assign(r, {
    // legacy interfaces
    balance: r.data,
    loading: r.isLoading
  });
}
function wl(e3) {
  return (0, import_react.useMemo)(() => new SuiClient({ url: e3 }), [e3]);
}
var Ji = (0, import_react.createContext)(
  new SuiClient({
    url: wt.rpcUrl
  })
);
var El = () => (0, import_react.useContext)(Ji);
function ze(e3) {
  return Array.isArray(e3) && e3.length > 0;
}
function hu() {
  const e3 = (0, import_react.useRef)(null), [t3, n2] = (0, import_react.useState)([]);
  return (0, import_react.useEffect)(() => {
    e3.current || (e3.current = new Wa(), e3.current.activate());
    const r = e3.current.getDetectedWalletAdapters();
    return n2(r), e3.current.subscribe((s) => {
      n2(s);
    }), () => {
      e3.current && (e3.current.deactivate(), e3.current = null);
    };
  }, []), {
    data: t3
  };
}
function gu(e3) {
  (0, import_react.useLayoutEffect)(() => {
    const t3 = [];
    return ze(e3) && e3.forEach((n2) => {
      var _a2;
      if (n2.type === Tr.WEB && ((_a2 = n2.downloadUrl) == null ? void 0 : _a2.registerWebWallet)) {
        const r = n2.downloadUrl.registerWebWallet();
        t3.push(r);
      }
    }), () => {
      ze(t3) && t3.forEach((n2) => {
        n2();
      });
    };
  }, [e3]);
}
var yu = (e3) => {
  gu(e3);
  const { data: t3 } = hu(), n2 = (0, import_react.useMemo)(() => ze(e3) ? ze(t3) ? e3.map((a3) => {
    const l = t3.find(
      (u) => a3.name === u.name
    );
    return l ? {
      ...a3,
      adapter: l,
      installed: true
    } : {
      ...a3,
      adapter: void 0,
      installed: false
    };
  }) : e3.map(
    (a3) => ({
      ...a3,
      adapter: void 0,
      installed: false
    })
  ) : [], [e3, t3]), r = (0, import_react.useMemo)(() => ze(t3) ? t3.filter((a3) => !e3.find((l) => l.name === a3.name)).map((a3) => ({
    name: a3.name,
    label: a3.name,
    adapter: a3,
    installed: true,
    iconUrl: a3.icon,
    downloadUrl: {
      browserExtension: ""
      // no need to know
    }
  })) : [], [e3, t3]);
  return {
    allAvailableWallets: (0, import_react.useMemo)(() => [...n2, ...r].filter(
      (a3) => a3.installed
    ), [n2, r]),
    configuredWallets: n2,
    detectedWallets: r
  };
};
var pr = class {
  constructor() {
    if (!window)
      throw new Error("window not found: storage should be used in browser env");
  }
  get length() {
    return window.localStorage.length;
  }
  setItem(t3, n2) {
    try {
      let r = JSON.stringify(n2);
      return window.localStorage.setItem(t3, r);
    } catch (r) {
      throw new Error("stringify data failed when setItem: " + r.message);
    }
  }
  getItem(t3) {
    const n2 = window.localStorage.getItem(t3);
    if (!n2)
      return n2;
    try {
      return JSON.parse(n2);
    } catch (r) {
      throw new Error("parse data failed when getItem: " + r.message);
    }
  }
  removeItem(t3) {
    return window.localStorage.removeItem(t3);
  }
  clear() {
    return window.localStorage.clear();
  }
};
var On = ((e3) => (e3.LAST_CONNECT_WALLET_NAME = "WK__LAST_CONNECT_WALLET_NAME", e3))(On || {});
function pu(e3, t3, n2, r) {
  const s = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (!r || s.current || !ze(n2) || t3 !== Ce.DISCONNECTED)
      return;
    const l = new pr().getItem(
      On.LAST_CONNECT_WALLET_NAME
    );
    l && n2.find((u) => u.name == l) && e3(l).then(() => {
      s.current = true;
    }).catch((u) => {
    });
  }, [n2]);
}
function Mu(e3) {
  var _a2, _b, _c2;
  return ((_c2 = (_b = (_a2 = e3 == null ? void 0 : e3.accounts) == null ? void 0 : _a2[0]) == null ? void 0 : _b.chains) == null ? void 0 : _c2[0]) ? e3.accounts[0].chains[0] : "sui:unknown";
}
var bl = (e3) => {
  const {
    defaultWallets: t3 = vo,
    chains: n2 = So,
    autoConnect: r = true,
    children: s
  } = e3, {
    allAvailableWallets: a3,
    configuredWallets: l,
    detectedWallets: u
  } = yu(t3), [f, h] = (0, import_react.useState)(), [g, p] = (0, import_react.useState)(Ce.DISCONNECTED), [I, N] = (0, import_react.useState)(() => ze(n2) ? n2[0] : wt), v = (0, import_react.useMemo)(() => new SuiClient({
    url: I.rpcUrl
  }), [I]), m = (0, import_react.useRef)([]), D = (j, O) => j && O === Ce.CONNECTED, b = (0, import_react.useMemo)(() => {
    if (D(f, g))
      return f.accounts[0];
  }, [f, g]), C = (j, O) => {
    if (!D(j, O))
      throw new re("Failed to call function, wallet not connected");
  }, w = (0, import_react.useCallback)(() => {
    if (C(f, g), !b)
      throw new re("no active account");
    return [f, b];
  }, [f, b, g]), P = (0, import_react.useCallback)(async (j, O) => {
    if (!j)
      throw new re("param adapter is missing");
    p(Ce.CONNECTING);
    try {
      const S = await j.connect(O);
      if (ze(S == null ? void 0 : S.accounts)) {
        const X = Mu(S), z = n2.find((ee) => ee.id === X);
        N(z ?? wt);
      }
      return h(j), p(Ce.CONNECTED), new pr().setItem(On.LAST_CONNECT_WALLET_NAME, j.name), S;
    } catch (S) {
      throw h(void 0), p(Ce.DISCONNECTED), S;
    }
  }, []), x = (0, import_react.useCallback)(async () => {
    C(f, g);
    const j = f;
    ze(m.current) && (m.current.forEach((S) => {
      try {
        S();
      } catch (Y) {
        console.error("error when clearing wallet listener", Y.message);
      }
    }), m.current = []), new pr().removeItem(On.LAST_CONNECT_WALLET_NAME);
    try {
      j.hasFeature(K.STANDARD__DISCONNECT) && await j.disconnect();
    } finally {
      h(void 0), p(Ce.DISCONNECTED), N((n2 == null ? void 0 : n2[0]) ?? wt);
    }
  }, [f, g]), U = (0, import_react.useCallback)(async (j) => {
    if (D(f, g)) {
      if (j === f.name)
        return;
      await x();
    }
    const O = a3.find((S) => S.name === j);
    if (!O) {
      const S = a3.map((Y) => Y.name);
      throw new re(`select failed: wallet ${j} is not available, all wallets are listed here: [${S.join(", ")}]`);
    }
    await P(O.adapter);
  }, [f, g, a3]), q = (0, import_react.useCallback)((j, O) => {
    const [S] = w(), Y = S.on("change", (X) => {
      var _a2, _b;
      if (j === "change") {
        O(X);
        return;
      }
      if (X.chains && j === "chainChange") {
        O({
          chain: (_a2 = X.chains) == null ? void 0 : _a2[0]
        });
        return;
      }
      if (X.accounts && j === "accountChange") {
        O({
          account: (_b = X.accounts) == null ? void 0 : _b[0]
        });
        return;
      }
      if (X.features && j === "featureChange") {
        O({
          features: X.features
        });
        return;
      }
    });
    return m.current.push(Y), Y;
  }, [w]), k = (0, import_react.useCallback)(() => {
    const [j] = w();
    return j.accounts;
  }, [w]), ue = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    return await O.signAndExecuteTransactionBlock({
      account: S,
      chain: I.id,
      transactionBlock: j.transactionBlock
    });
  }, [w, I]), ne = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    let Y, X = await bo(j.transaction);
    if (O.hasFeature(K.SUI__SIGN_TRANSACTION))
      Y = await O.signTransaction({
        transaction: X,
        account: S,
        chain: I.id
      });
    else if (O.hasFeature(K.SUI__SIGN_TRANSACTION_BLOCK)) {
      const z = await O.signTransactionBlock({
        transactionBlock: X,
        account: S,
        chain: I.id
      });
      Y = {
        signature: z.signature,
        bytes: z.transactionBlockBytes
      };
    } else
      throw new Ci(`${K.SUI__SIGN_TRANSACTION} or ${K.SUI__SIGN_TRANSACTION_BLOCK}`);
    return Y;
  }, [w, I]), me = (0, import_react.useCallback)(async (j, O) => {
    const [S, Y] = w(), X = async (_e) => typeof (O == null ? void 0 : O.execute) == "function" ? await O.execute(_e) : await v.executeTransactionBlock({
      transactionBlock: _e.bytes,
      signature: _e.signature,
      options: {
        showRawEffects: true
      }
    }), z = await ne({
      transaction: j.transaction
    }), {
      digest: ee,
      effects: ct,
      ...He
    } = await X(z);
    let Ke;
    if (ct && "bcs" in ct)
      Ke = ct == null ? void 0 : ct.bcs;
    else if (He && "rawEffects" in He)
      Ke = toB64(new Uint8Array(He.rawEffects));
    else
      throw new Error("effects or rawEffects not found in the execution result");
    if (S.hasFeature(K.SUI__REPORT_TRANSACTION_EFFECTS))
      try {
        await S.reportTransactionEffects({
          effects: Ke,
          account: Y,
          chain: I.id
        });
      } catch (_e) {
        console.warn("Failed to report transaction effects:", _e);
      }
    return {
      bytes: z.bytes,
      signature: z.signature,
      digest: ee,
      effects: Ke,
      ...He
    };
  }, [w, I, v]), De = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    return await O.reportTransactionEffects({
      account: S,
      chain: I.id,
      ...j
    });
  }, [w, I]), je = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    return await O.signTransactionBlock({
      account: S,
      chain: I.id,
      transactionBlock: j.transactionBlock
    });
  }, [w, I]), Me = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    return await O.signMessage({
      account: S,
      message: j.message
    });
  }, [w]), Te = (0, import_react.useCallback)(async (j) => {
    const [O, S] = w();
    return await O.signPersonalMessage({
      account: S,
      message: j.message
    });
  }, [w]);
  return pu(U, g, a3, r), (0, import_react.useEffect)(() => {
    if (!f || g !== "connected")
      return;
    const j = q("chainChange", (O) => {
      if (O.chain === I.id)
        return;
      const S = n2.find((Y) => Y.id === O.chain);
      if (!S) {
        N(wt);
        return;
      }
      N(S);
    });
    return () => {
      j();
    };
  }, [f, g, I, n2, q]), (0, import_jsx_runtime.jsx)(Fi.Provider, {
    value: {
      name: f == null ? void 0 : f.name,
      chains: n2,
      chain: I,
      allAvailableWallets: a3,
      configuredWallets: l,
      detectedWallets: u,
      adapter: f,
      status: g,
      connecting: g === Ce.CONNECTING,
      connected: g === Ce.CONNECTED,
      select: U,
      disconnect: x,
      on: q,
      getAccounts: k,
      account: b,
      signPersonalMessage: Te,
      signTransaction: ne,
      signAndExecuteTransaction: me,
      reportTransactionEffects: De,
      signMessage: Me,
      signTransactionBlock: je,
      signAndExecuteTransactionBlock: ue,
      verifySignedMessage: Ca,
      address: b == null ? void 0 : b.address
    },
    children: (0, import_jsx_runtime.jsx)(nu, {
      client: new Ho(),
      children: (0, import_jsx_runtime.jsx)(Ji.Provider, {
        value: v,
        children: s
      })
    })
  });
};
function Nu(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
var $i = { exports: {} };
(function(e3) {
  (function() {
    var t3 = {}.hasOwnProperty;
    function n2() {
      for (var r = [], s = 0; s < arguments.length; s++) {
        var a3 = arguments[s];
        if (a3) {
          var l = typeof a3;
          if (l === "string" || l === "number")
            r.push(a3);
          else if (Array.isArray(a3)) {
            if (a3.length) {
              var u = n2.apply(null, a3);
              u && r.push(u);
            }
          } else if (l === "object") {
            if (a3.toString !== Object.prototype.toString && !a3.toString.toString().includes("[native code]")) {
              r.push(a3.toString());
              continue;
            }
            for (var f in a3)
              t3.call(a3, f) && a3[f] && r.push(f);
          }
        }
      }
      return r.join(" ");
    }
    e3.exports ? (n2.default = n2, e3.exports = n2) : window.classNames = n2;
  })();
})($i);
var Iu = $i.exports;
var Bt = Nu(Iu);
function qe(e3, t3, { checkForDefaultPrevented: n2 = true } = {}) {
  return function(s) {
    if (e3 == null ? void 0 : e3(s), n2 === false || !s.defaultPrevented)
      return t3 == null ? void 0 : t3(s);
  };
}
function mu(e3, t3) {
  typeof e3 == "function" ? e3(t3) : e3 != null && (e3.current = t3);
}
function es(...e3) {
  return (t3) => e3.forEach(
    (n2) => mu(n2, t3)
  );
}
function Lt(...e3) {
  return (0, import_react.useCallback)(es(...e3), e3);
}
function Au(e3, t3) {
  const n2 = (0, import_react.createContext)(t3);
  function r(a3) {
    const { children: l, ...u } = a3, f = (0, import_react.useMemo)(
      () => u,
      Object.values(u)
    );
    return (0, import_react.createElement)(n2.Provider, {
      value: f
    }, l);
  }
  function s(a3) {
    const l = (0, import_react.useContext)(n2);
    if (l)
      return l;
    if (t3 !== void 0)
      return t3;
    throw new Error(`\`${a3}\` must be used within \`${e3}\``);
  }
  return r.displayName = e3 + "Provider", [
    r,
    s
  ];
}
function vu(e3, t3 = []) {
  let n2 = [];
  function r(a3, l) {
    const u = (0, import_react.createContext)(l), f = n2.length;
    n2 = [
      ...n2,
      l
    ];
    function h(p) {
      const { scope: I, children: N, ...v } = p, m = (I == null ? void 0 : I[e3][f]) || u, D = (0, import_react.useMemo)(
        () => v,
        Object.values(v)
      );
      return (0, import_react.createElement)(m.Provider, {
        value: D
      }, N);
    }
    function g(p, I) {
      const N = (I == null ? void 0 : I[e3][f]) || u, v = (0, import_react.useContext)(N);
      if (v)
        return v;
      if (l !== void 0)
        return l;
      throw new Error(`\`${p}\` must be used within \`${a3}\``);
    }
    return h.displayName = a3 + "Provider", [
      h,
      g
    ];
  }
  const s = () => {
    const a3 = n2.map((l) => (0, import_react.createContext)(l));
    return function(u) {
      const f = (u == null ? void 0 : u[e3]) || a3;
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${e3}`]: {
            ...u,
            [e3]: f
          }
        }),
        [
          u,
          f
        ]
      );
    };
  };
  return s.scopeName = e3, [
    r,
    wu(s, ...t3)
  ];
}
function wu(...e3) {
  const t3 = e3[0];
  if (e3.length === 1)
    return t3;
  const n2 = () => {
    const r = e3.map(
      (s) => ({
        useScope: s(),
        scopeName: s.scopeName
      })
    );
    return function(a3) {
      const l = r.reduce((u, { useScope: f, scopeName: h }) => {
        const p = f(a3)[`__scope${h}`];
        return {
          ...u,
          ...p
        };
      }, {});
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${t3.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n2.scopeName = t3.scopeName, n2;
}
var Mr = (globalThis == null ? void 0 : globalThis.document) ? import_react.useLayoutEffect : () => {
};
var Eu = Q.useId || (() => {
});
var bu = 0;
function Hn(e3) {
  const [t3, n2] = Q.useState(Eu());
  return Mr(() => {
    n2(
      (r) => r ?? String(bu++)
    );
  }, [
    e3
  ]), e3 || (t3 ? `radix-${t3}` : "");
}
function ot(e3) {
  const t3 = (0, import_react.useRef)(e3);
  return (0, import_react.useEffect)(() => {
    t3.current = e3;
  }), (0, import_react.useMemo)(
    () => (...n2) => {
      var r;
      return (r = t3.current) === null || r === void 0 ? void 0 : r.call(t3, ...n2);
    },
    []
  );
}
function Du({ prop: e3, defaultProp: t3, onChange: n2 = () => {
} }) {
  const [r, s] = ju({
    defaultProp: t3,
    onChange: n2
  }), a3 = e3 !== void 0, l = a3 ? e3 : r, u = ot(n2), f = (0, import_react.useCallback)((h) => {
    if (a3) {
      const p = typeof h == "function" ? h(e3) : h;
      p !== e3 && u(p);
    } else
      s(h);
  }, [
    a3,
    e3,
    s,
    u
  ]);
  return [
    l,
    f
  ];
}
function ju({ defaultProp: e3, onChange: t3 }) {
  const n2 = (0, import_react.useState)(e3), [r] = n2, s = (0, import_react.useRef)(r), a3 = ot(t3);
  return (0, import_react.useEffect)(() => {
    s.current !== r && (a3(r), s.current = r);
  }, [
    r,
    s,
    a3
  ]), n2;
}
var Rr = (0, import_react.forwardRef)((e3, t3) => {
  const { children: n2, ...r } = e3, s = import_react.Children.toArray(n2), a3 = s.find(Lu);
  if (a3) {
    const l = a3.props.children, u = s.map((f) => f === a3 ? import_react.Children.count(l) > 1 ? import_react.Children.only(null) : (0, import_react.isValidElement)(l) ? l.props.children : null : f);
    return (0, import_react.createElement)(Nr, L({}, r, {
      ref: t3
    }), (0, import_react.isValidElement)(l) ? (0, import_react.cloneElement)(l, void 0, u) : null);
  }
  return (0, import_react.createElement)(Nr, L({}, r, {
    ref: t3
  }), n2);
});
Rr.displayName = "Slot";
var Nr = (0, import_react.forwardRef)((e3, t3) => {
  const { children: n2, ...r } = e3;
  return (0, import_react.isValidElement)(n2) ? (0, import_react.cloneElement)(n2, {
    ...Su(r, n2.props),
    ref: es(t3, n2.ref)
  }) : import_react.Children.count(n2) > 1 ? import_react.Children.only(null) : null;
});
Nr.displayName = "SlotClone";
var Tu = ({ children: e3 }) => (0, import_react.createElement)(import_react.Fragment, null, e3);
function Lu(e3) {
  return (0, import_react.isValidElement)(e3) && e3.type === Tu;
}
function Su(e3, t3) {
  const n2 = {
    ...t3
  };
  for (const r in t3) {
    const s = e3[r], a3 = t3[r];
    /^on[A-Z]/.test(r) ? s && a3 ? n2[r] = (...u) => {
      a3(...u), s(...u);
    } : s && (n2[r] = s) : r === "style" ? n2[r] = {
      ...s,
      ...a3
    } : r === "className" && (n2[r] = [
      s,
      a3
    ].filter(Boolean).join(" "));
  }
  return {
    ...e3,
    ...n2
  };
}
var Cu = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var ut = Cu.reduce((e3, t3) => {
  const n2 = (0, import_react.forwardRef)((r, s) => {
    const { asChild: a3, ...l } = r, u = a3 ? Rr : t3;
    return (0, import_react.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []), (0, import_react.createElement)(u, L({}, l, {
      ref: s
    }));
  });
  return n2.displayName = `Primitive.${t3}`, {
    ...e3,
    [t3]: n2
  };
}, {});
function Ou(e3, t3) {
  e3 && (0, import_react_dom.flushSync)(
    () => e3.dispatchEvent(t3)
  );
}
function xu(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = ot(e3);
  (0, import_react.useEffect)(() => {
    const r = (s) => {
      s.key === "Escape" && n2(s);
    };
    return t3.addEventListener("keydown", r), () => t3.removeEventListener("keydown", r);
  }, [
    n2,
    t3
  ]);
}
var Ir = "dismissableLayer.update";
var zu = "dismissableLayer.pointerDownOutside";
var Ru = "dismissableLayer.focusOutside";
var ei;
var Uu = (0, import_react.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var ku = (0, import_react.forwardRef)((e3, t3) => {
  var n2;
  const { disableOutsidePointerEvents: r = false, onEscapeKeyDown: s, onPointerDownOutside: a3, onFocusOutside: l, onInteractOutside: u, onDismiss: f, ...h } = e3, g = (0, import_react.useContext)(Uu), [p, I] = (0, import_react.useState)(null), N = (n2 = p == null ? void 0 : p.ownerDocument) !== null && n2 !== void 0 ? n2 : globalThis == null ? void 0 : globalThis.document, [, v] = (0, import_react.useState)({}), m = Lt(
    t3,
    (k) => I(k)
  ), D = Array.from(g.layers), [b] = [
    ...g.layersWithOutsidePointerEventsDisabled
  ].slice(-1), C = D.indexOf(b), w = p ? D.indexOf(p) : -1, P = g.layersWithOutsidePointerEventsDisabled.size > 0, x = w >= C, U = Pu((k) => {
    const ue = k.target, ne = [
      ...g.branches
    ].some(
      (me) => me.contains(ue)
    );
    !x || ne || (a3 == null ? void 0 : a3(k), u == null ? void 0 : u(k), k.defaultPrevented || (f == null ? void 0 : f()));
  }, N), q = Qu((k) => {
    const ue = k.target;
    [
      ...g.branches
    ].some(
      (me) => me.contains(ue)
    ) || (l == null ? void 0 : l(k), u == null ? void 0 : u(k), k.defaultPrevented || (f == null ? void 0 : f()));
  }, N);
  return xu((k) => {
    w === g.layers.size - 1 && (s == null ? void 0 : s(k), !k.defaultPrevented && f && (k.preventDefault(), f()));
  }, N), (0, import_react.useEffect)(() => {
    if (p)
      return r && (g.layersWithOutsidePointerEventsDisabled.size === 0 && (ei = N.body.style.pointerEvents, N.body.style.pointerEvents = "none"), g.layersWithOutsidePointerEventsDisabled.add(p)), g.layers.add(p), ti(), () => {
        r && g.layersWithOutsidePointerEventsDisabled.size === 1 && (N.body.style.pointerEvents = ei);
      };
  }, [
    p,
    N,
    r,
    g
  ]), (0, import_react.useEffect)(() => () => {
    p && (g.layers.delete(p), g.layersWithOutsidePointerEventsDisabled.delete(p), ti());
  }, [
    p,
    g
  ]), (0, import_react.useEffect)(() => {
    const k = () => v({});
    return document.addEventListener(Ir, k), () => document.removeEventListener(Ir, k);
  }, []), (0, import_react.createElement)(ut.div, L({}, h, {
    ref: m,
    style: {
      pointerEvents: P ? x ? "auto" : "none" : void 0,
      ...e3.style
    },
    onFocusCapture: qe(e3.onFocusCapture, q.onFocusCapture),
    onBlurCapture: qe(e3.onBlurCapture, q.onBlurCapture),
    onPointerDownCapture: qe(e3.onPointerDownCapture, U.onPointerDownCapture)
  }));
});
function Pu(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = ot(e3), r = (0, import_react.useRef)(false), s = (0, import_react.useRef)(() => {
  });
  return (0, import_react.useEffect)(() => {
    const a3 = (u) => {
      if (u.target && !r.current) {
        let h = function() {
          ts(zu, n2, f, {
            discrete: true
          });
        };
        const f = {
          originalEvent: u
        };
        u.pointerType === "touch" ? (t3.removeEventListener("click", s.current), s.current = h, t3.addEventListener("click", s.current, {
          once: true
        })) : h();
      }
      r.current = false;
    }, l = window.setTimeout(() => {
      t3.addEventListener("pointerdown", a3);
    }, 0);
    return () => {
      window.clearTimeout(l), t3.removeEventListener("pointerdown", a3), t3.removeEventListener("click", s.current);
    };
  }, [
    t3,
    n2
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = true
  };
}
function Qu(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = ot(e3), r = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(() => {
    const s = (a3) => {
      a3.target && !r.current && ts(Ru, n2, {
        originalEvent: a3
      }, {
        discrete: false
      });
    };
    return t3.addEventListener("focusin", s), () => t3.removeEventListener("focusin", s);
  }, [
    t3,
    n2
  ]), {
    onFocusCapture: () => r.current = true,
    onBlurCapture: () => r.current = false
  };
}
function ti() {
  const e3 = new CustomEvent(Ir);
  document.dispatchEvent(e3);
}
function ts(e3, t3, n2, { discrete: r }) {
  const s = n2.originalEvent.target, a3 = new CustomEvent(e3, {
    bubbles: false,
    cancelable: true,
    detail: n2
  });
  t3 && s.addEventListener(e3, t3, {
    once: true
  }), r ? Ou(s, a3) : s.dispatchEvent(a3);
}
var Kn = "focusScope.autoFocusOnMount";
var Jn = "focusScope.autoFocusOnUnmount";
var ni = {
  bubbles: false,
  cancelable: true
};
var Bu = (0, import_react.forwardRef)((e3, t3) => {
  const { loop: n2 = false, trapped: r = false, onMountAutoFocus: s, onUnmountAutoFocus: a3, ...l } = e3, [u, f] = (0, import_react.useState)(null), h = ot(s), g = ot(a3), p = (0, import_react.useRef)(null), I = Lt(
    t3,
    (m) => f(m)
  ), N = (0, import_react.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react.useEffect)(() => {
    if (r) {
      let m = function(b) {
        if (N.paused || !u)
          return;
        const C = b.target;
        u.contains(C) ? p.current = C : tt(p.current, {
          select: true
        });
      }, D = function(b) {
        N.paused || !u || u.contains(b.relatedTarget) || tt(p.current, {
          select: true
        });
      };
      return document.addEventListener("focusin", m), document.addEventListener("focusout", D), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", D);
      };
    }
  }, [
    r,
    u,
    N.paused
  ]), (0, import_react.useEffect)(() => {
    if (u) {
      ii.add(N);
      const m = document.activeElement;
      if (!u.contains(m)) {
        const b = new CustomEvent(Kn, ni);
        u.addEventListener(Kn, h), u.dispatchEvent(b), b.defaultPrevented || (Wu(Zu(ns(u)), {
          select: true
        }), document.activeElement === m && tt(u));
      }
      return () => {
        u.removeEventListener(Kn, h), setTimeout(() => {
          const b = new CustomEvent(Jn, ni);
          u.addEventListener(Jn, g), u.dispatchEvent(b), b.defaultPrevented || tt(m ?? document.body, {
            select: true
          }), u.removeEventListener(Jn, g), ii.remove(N);
        }, 0);
      };
    }
  }, [
    u,
    h,
    g,
    N
  ]);
  const v = (0, import_react.useCallback)((m) => {
    if (!n2 && !r || N.paused)
      return;
    const D = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, b = document.activeElement;
    if (D && b) {
      const C = m.currentTarget, [w, P] = Fu(C);
      w && P ? !m.shiftKey && b === P ? (m.preventDefault(), n2 && tt(w, {
        select: true
      })) : m.shiftKey && b === w && (m.preventDefault(), n2 && tt(P, {
        select: true
      })) : b === C && m.preventDefault();
    }
  }, [
    n2,
    r,
    N.paused
  ]);
  return (0, import_react.createElement)(ut.div, L({
    tabIndex: -1
  }, l, {
    ref: I,
    onKeyDown: v
  }));
});
function Wu(e3, { select: t3 = false } = {}) {
  const n2 = document.activeElement;
  for (const r of e3)
    if (tt(r, {
      select: t3
    }), document.activeElement !== n2)
      return;
}
function Fu(e3) {
  const t3 = ns(e3), n2 = ri(t3, e3), r = ri(t3.reverse(), e3);
  return [
    n2,
    r
  ];
}
function ns(e3) {
  const t3 = [], n2 = document.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const s = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n2.nextNode(); )
    t3.push(n2.currentNode);
  return t3;
}
function ri(e3, t3) {
  for (const n2 of e3)
    if (!Yu(n2, {
      upTo: t3
    }))
      return n2;
}
function Yu(e3, { upTo: t3 }) {
  if (getComputedStyle(e3).visibility === "hidden")
    return true;
  for (; e3; ) {
    if (t3 !== void 0 && e3 === t3)
      return false;
    if (getComputedStyle(e3).display === "none")
      return true;
    e3 = e3.parentElement;
  }
  return false;
}
function _u(e3) {
  return e3 instanceof HTMLInputElement && "select" in e3;
}
function tt(e3, { select: t3 = false } = {}) {
  if (e3 && e3.focus) {
    const n2 = document.activeElement;
    e3.focus({
      preventScroll: true
    }), e3 !== n2 && _u(e3) && t3 && e3.select();
  }
}
var ii = Gu();
function Gu() {
  let e3 = [];
  return {
    add(t3) {
      const n2 = e3[0];
      t3 !== n2 && (n2 == null ? void 0 : n2.pause()), e3 = si(e3, t3), e3.unshift(t3);
    },
    remove(t3) {
      var n2;
      e3 = si(e3, t3), (n2 = e3[0]) === null || n2 === void 0 || n2.resume();
    }
  };
}
function si(e3, t3) {
  const n2 = [
    ...e3
  ], r = n2.indexOf(t3);
  return r !== -1 && n2.splice(r, 1), n2;
}
function Zu(e3) {
  return e3.filter(
    (t3) => t3.tagName !== "A"
  );
}
var Vu = (0, import_react.forwardRef)((e3, t3) => {
  var n2;
  const { container: r = globalThis == null || (n2 = globalThis.document) === null || n2 === void 0 ? void 0 : n2.body, ...s } = e3;
  return r ? import_react_dom.default.createPortal((0, import_react.createElement)(ut.div, L({}, s, {
    ref: t3
  })), r) : null;
});
function qu(e3, t3) {
  return (0, import_react.useReducer)((n2, r) => {
    const s = t3[n2][r];
    return s ?? n2;
  }, e3);
}
var Pn = (e3) => {
  const { present: t3, children: n2 } = e3, r = Xu(t3), s = typeof n2 == "function" ? n2({
    present: r.isPresent
  }) : import_react.Children.only(n2), a3 = Lt(r.ref, s.ref);
  return typeof n2 == "function" || r.isPresent ? (0, import_react.cloneElement)(s, {
    ref: a3
  }) : null;
};
Pn.displayName = "Presence";
function Xu(e3) {
  const [t3, n2] = (0, import_react.useState)(), r = (0, import_react.useRef)({}), s = (0, import_react.useRef)(e3), a3 = (0, import_react.useRef)("none"), l = e3 ? "mounted" : "unmounted", [u, f] = qu(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return (0, import_react.useEffect)(() => {
    const h = Kt(r.current);
    a3.current = u === "mounted" ? h : "none";
  }, [
    u
  ]), Mr(() => {
    const h = r.current, g = s.current;
    if (g !== e3) {
      const I = a3.current, N = Kt(h);
      e3 ? f("MOUNT") : N === "none" || (h == null ? void 0 : h.display) === "none" ? f("UNMOUNT") : f(g && I !== N ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e3;
    }
  }, [
    e3,
    f
  ]), Mr(() => {
    if (t3) {
      const h = (p) => {
        const N = Kt(r.current).includes(p.animationName);
        p.target === t3 && N && (0, import_react_dom.flushSync)(
          () => f("ANIMATION_END")
        );
      }, g = (p) => {
        p.target === t3 && (a3.current = Kt(r.current));
      };
      return t3.addEventListener("animationstart", g), t3.addEventListener("animationcancel", h), t3.addEventListener("animationend", h), () => {
        t3.removeEventListener("animationstart", g), t3.removeEventListener("animationcancel", h), t3.removeEventListener("animationend", h);
      };
    } else
      f("ANIMATION_END");
  }, [
    t3,
    f
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(u),
    ref: (0, import_react.useCallback)((h) => {
      h && (r.current = getComputedStyle(h)), n2(h);
    }, [])
  };
}
function Kt(e3) {
  return (e3 == null ? void 0 : e3.animationName) || "none";
}
var $n = 0;
function Hu() {
  (0, import_react.useEffect)(() => {
    var e3, t3;
    const n2 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e3 = n2[0]) !== null && e3 !== void 0 ? e3 : ai()), document.body.insertAdjacentElement("beforeend", (t3 = n2[1]) !== null && t3 !== void 0 ? t3 : ai()), $n++, () => {
      $n === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), $n--;
    };
  }, []);
}
function ai() {
  const e3 = document.createElement("span");
  return e3.setAttribute("data-radix-focus-guard", ""), e3.tabIndex = 0, e3.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e3;
}
var Qe = function() {
  return Qe = Object.assign || function(t3) {
    for (var n2, r = 1, s = arguments.length; r < s; r++) {
      n2 = arguments[r];
      for (var a3 in n2)
        Object.prototype.hasOwnProperty.call(n2, a3) && (t3[a3] = n2[a3]);
    }
    return t3;
  }, Qe.apply(this, arguments);
};
function rs(e3, t3) {
  var n2 = {};
  for (var r in e3)
    Object.prototype.hasOwnProperty.call(e3, r) && t3.indexOf(r) < 0 && (n2[r] = e3[r]);
  if (e3 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(e3); s < r.length; s++)
      t3.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, r[s]) && (n2[r[s]] = e3[r[s]]);
  return n2;
}
function Ku(e3, t3, n2) {
  if (n2 || arguments.length === 2)
    for (var r = 0, s = t3.length, a3; r < s; r++)
      (a3 || !(r in t3)) && (a3 || (a3 = Array.prototype.slice.call(t3, 0, r)), a3[r] = t3[r]);
  return e3.concat(a3 || Array.prototype.slice.call(t3));
}
var mn = "right-scroll-bar-position";
var An = "width-before-scroll-bar";
var Ju = "with-scroll-bars-hidden";
var $u = "--removed-body-scroll-bar-size";
function er(e3, t3) {
  return typeof e3 == "function" ? e3(t3) : e3 && (e3.current = t3), e3;
}
function ec(e3, t3) {
  var n2 = (0, import_react.useState)(function() {
    return {
      // value
      value: e3,
      // last callback
      callback: t3,
      // "memoized" public interface
      facade: {
        get current() {
          return n2.value;
        },
        set current(r) {
          var s = n2.value;
          s !== r && (n2.value = r, n2.callback(r, s));
        }
      }
    };
  })[0];
  return n2.callback = t3, n2.facade;
}
var tc = typeof window < "u" ? Q.useLayoutEffect : Q.useEffect;
var oi = /* @__PURE__ */ new WeakMap();
function nc(e3, t3) {
  var n2 = ec(null, function(r) {
    return e3.forEach(function(s) {
      return er(s, r);
    });
  });
  return tc(function() {
    var r = oi.get(n2);
    if (r) {
      var s = new Set(r), a3 = new Set(e3), l = n2.current;
      s.forEach(function(u) {
        a3.has(u) || er(u, null);
      }), a3.forEach(function(u) {
        s.has(u) || er(u, l);
      });
    }
    oi.set(n2, e3);
  }, [e3]), n2;
}
function rc(e3) {
  return e3;
}
function ic(e3, t3) {
  t3 === void 0 && (t3 = rc);
  var n2 = [], r = false, s = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n2.length ? n2[n2.length - 1] : e3;
    },
    useMedium: function(a3) {
      var l = t3(a3, r);
      return n2.push(l), function() {
        n2 = n2.filter(function(u) {
          return u !== l;
        });
      };
    },
    assignSyncMedium: function(a3) {
      for (r = true; n2.length; ) {
        var l = n2;
        n2 = [], l.forEach(a3);
      }
      n2 = {
        push: function(u) {
          return a3(u);
        },
        filter: function() {
          return n2;
        }
      };
    },
    assignMedium: function(a3) {
      r = true;
      var l = [];
      if (n2.length) {
        var u = n2;
        n2 = [], u.forEach(a3), l = n2;
      }
      var f = function() {
        var g = l;
        l = [], g.forEach(a3);
      }, h = function() {
        return Promise.resolve().then(f);
      };
      h(), n2 = {
        push: function(g) {
          l.push(g), h();
        },
        filter: function(g) {
          return l = l.filter(g), n2;
        }
      };
    }
  };
  return s;
}
function sc(e3) {
  e3 === void 0 && (e3 = {});
  var t3 = ic(null);
  return t3.options = Qe({ async: true, ssr: false }, e3), t3;
}
var is2 = function(e3) {
  var t3 = e3.sideCar, n2 = rs(e3, ["sideCar"]);
  if (!t3)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t3.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return (0, import_jsx_runtime.jsx)(r, {
    ...Qe({}, n2)
  });
};
is2.isSideCarExport = true;
function ac(e3, t3) {
  return e3.useMedium(t3), is2;
}
var ss = sc();
var tr = function() {
};
var Qn = Q.forwardRef(function(e3, t3) {
  var n2 = Q.useRef(null), r = Q.useState({
    onScrollCapture: tr,
    onWheelCapture: tr,
    onTouchMoveCapture: tr
  }), s = r[0], a3 = r[1], l = e3.forwardProps, u = e3.children, f = e3.className, h = e3.removeScrollBar, g = e3.enabled, p = e3.shards, I = e3.sideCar, N = e3.noIsolation, v = e3.inert, m = e3.allowPinchZoom, D = e3.as, b = D === void 0 ? "div" : D, C = rs(e3, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), w = I, P = nc([n2, t3]), x = Qe(Qe({}, C), s);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [g && (0, import_jsx_runtime.jsx)(w, {
      sideCar: ss,
      removeScrollBar: h,
      shards: p,
      noIsolation: N,
      inert: v,
      setCallbacks: a3,
      allowPinchZoom: !!m,
      lockRef: n2
    }), l ? Q.cloneElement(Q.Children.only(u), Qe(Qe({}, x), {
      ref: P
    })) : (0, import_jsx_runtime.jsx)(b, {
      ...Qe({}, x, {
        className: f,
        ref: P
      }),
      children: u
    })]
  });
});
Qn.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
Qn.classNames = {
  fullWidth: An,
  zeroRight: mn
};
var oc = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function uc() {
  if (!document)
    return null;
  var e3 = document.createElement("style");
  e3.type = "text/css";
  var t3 = oc();
  return t3 && e3.setAttribute("nonce", t3), e3;
}
function cc(e3, t3) {
  e3.styleSheet ? e3.styleSheet.cssText = t3 : e3.appendChild(document.createTextNode(t3));
}
function lc(e3) {
  var t3 = document.head || document.getElementsByTagName("head")[0];
  t3.appendChild(e3);
}
var fc = function() {
  var e3 = 0, t3 = null;
  return {
    add: function(n2) {
      e3 == 0 && (t3 = uc()) && (cc(t3, n2), lc(t3)), e3++;
    },
    remove: function() {
      e3--, !e3 && t3 && (t3.parentNode && t3.parentNode.removeChild(t3), t3 = null);
    }
  };
};
var dc = function() {
  var e3 = fc();
  return function(t3, n2) {
    Q.useEffect(function() {
      return e3.add(t3), function() {
        e3.remove();
      };
    }, [t3 && n2]);
  };
};
var as = function() {
  var e3 = dc(), t3 = function(n2) {
    var r = n2.styles, s = n2.dynamic;
    return e3(r, s), null;
  };
  return t3;
};
var hc = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var nr = function(e3) {
  return parseInt(e3 || "", 10) || 0;
};
var gc = function(e3) {
  var t3 = window.getComputedStyle(document.body), n2 = t3[e3 === "padding" ? "paddingLeft" : "marginLeft"], r = t3[e3 === "padding" ? "paddingTop" : "marginTop"], s = t3[e3 === "padding" ? "paddingRight" : "marginRight"];
  return [nr(n2), nr(r), nr(s)];
};
var yc = function(e3) {
  if (e3 === void 0 && (e3 = "margin"), typeof window > "u")
    return hc;
  var t3 = gc(e3), n2 = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t3[0],
    top: t3[1],
    right: t3[2],
    gap: Math.max(0, r - n2 + t3[2] - t3[0])
  };
};
var pc = as();
var Dt = "data-scroll-locked";
var Mc = function(e3, t3, n2, r) {
  var s = e3.left, a3 = e3.top, l = e3.right, u = e3.gap;
  return n2 === void 0 && (n2 = "margin"), `
  .`.concat(Ju, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(Dt, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t3 && "position: relative ".concat(r, ";"), n2 === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(a3, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `), n2 === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(mn, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(An, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(mn, " .").concat(mn, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(An, " .").concat(An, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Dt, `] {
    `).concat($u, ": ").concat(u, `px;
  }
`);
};
var ui = function() {
  var e3 = parseInt(document.body.getAttribute(Dt) || "0", 10);
  return isFinite(e3) ? e3 : 0;
};
var Nc = function() {
  Q.useEffect(function() {
    return document.body.setAttribute(Dt, (ui() + 1).toString()), function() {
      var e3 = ui() - 1;
      e3 <= 0 ? document.body.removeAttribute(Dt) : document.body.setAttribute(Dt, e3.toString());
    };
  }, []);
};
var Ic = function(e3) {
  var t3 = e3.noRelative, n2 = e3.noImportant, r = e3.gapMode, s = r === void 0 ? "margin" : r;
  Nc();
  var a3 = Q.useMemo(function() {
    return yc(s);
  }, [s]);
  return (0, import_jsx_runtime.jsx)(pc, {
    styles: Mc(a3, !t3, s, n2 ? "" : "!important")
  });
};
var mr = false;
if (typeof window < "u")
  try {
    Jt = Object.defineProperty({}, "passive", {
      get: function() {
        return mr = true, true;
      }
    });
    window.addEventListener("test", Jt, Jt), window.removeEventListener("test", Jt, Jt);
  } catch {
    mr = false;
  }
var Jt;
var yt = mr ? { passive: false } : false;
var mc = function(e3) {
  return e3.tagName === "TEXTAREA";
};
var os = function(e3, t3) {
  var n2 = window.getComputedStyle(e3);
  return (
    // not-not-scrollable
    n2[t3] !== "hidden" && // contains scroll inside self
    !(n2.overflowY === n2.overflowX && !mc(e3) && n2[t3] === "visible")
  );
};
var Ac = function(e3) {
  return os(e3, "overflowY");
};
var vc = function(e3) {
  return os(e3, "overflowX");
};
var ci = function(e3, t3) {
  var n2 = t3;
  do {
    typeof ShadowRoot < "u" && n2 instanceof ShadowRoot && (n2 = n2.host);
    var r = us(e3, n2);
    if (r) {
      var s = cs(e3, n2), a3 = s[1], l = s[2];
      if (a3 > l)
        return true;
    }
    n2 = n2.parentNode;
  } while (n2 && n2 !== document.body);
  return false;
};
var wc = function(e3) {
  var t3 = e3.scrollTop, n2 = e3.scrollHeight, r = e3.clientHeight;
  return [
    t3,
    n2,
    r
  ];
};
var Ec = function(e3) {
  var t3 = e3.scrollLeft, n2 = e3.scrollWidth, r = e3.clientWidth;
  return [
    t3,
    n2,
    r
  ];
};
var us = function(e3, t3) {
  return e3 === "v" ? Ac(t3) : vc(t3);
};
var cs = function(e3, t3) {
  return e3 === "v" ? wc(t3) : Ec(t3);
};
var bc = function(e3, t3) {
  return e3 === "h" && t3 === "rtl" ? -1 : 1;
};
var Dc = function(e3, t3, n2, r, s) {
  var a3 = bc(e3, window.getComputedStyle(t3).direction), l = a3 * r, u = n2.target, f = t3.contains(u), h = false, g = l > 0, p = 0, I = 0;
  do {
    var N = cs(e3, u), v = N[0], m = N[1], D = N[2], b = m - D - a3 * v;
    (v || b) && us(e3, u) && (p += b, I += v), u = u.parentNode;
  } while (
    // portaled content
    !f && u !== document.body || // self content
    f && (t3.contains(u) || t3 === u)
  );
  return (g && p === 0 || !g && I === 0) && (h = true), h;
};
var $t = function(e3) {
  return "changedTouches" in e3 ? [e3.changedTouches[0].clientX, e3.changedTouches[0].clientY] : [0, 0];
};
var li = function(e3) {
  return [e3.deltaX, e3.deltaY];
};
var fi = function(e3) {
  return e3 && "current" in e3 ? e3.current : e3;
};
var jc = function(e3, t3) {
  return e3[0] === t3[0] && e3[1] === t3[1];
};
var Tc = function(e3) {
  return `
  .block-interactivity-`.concat(e3, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e3, ` {pointer-events: all;}
`);
};
var Lc = 0;
var pt = [];
function Sc(e3) {
  var t3 = Q.useRef([]), n2 = Q.useRef([0, 0]), r = Q.useRef(), s = Q.useState(Lc++)[0], a3 = Q.useState(function() {
    return as();
  })[0], l = Q.useRef(e3);
  Q.useEffect(function() {
    l.current = e3;
  }, [e3]), Q.useEffect(function() {
    if (e3.inert) {
      document.body.classList.add("block-interactivity-".concat(s));
      var m = Ku([e3.lockRef.current], (e3.shards || []).map(fi), true).filter(Boolean);
      return m.forEach(function(D) {
        return D.classList.add("allow-interactivity-".concat(s));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(s)), m.forEach(function(D) {
          return D.classList.remove("allow-interactivity-".concat(s));
        });
      };
    }
  }, [e3.inert, e3.lockRef.current, e3.shards]);
  var u = Q.useCallback(function(m, D) {
    if ("touches" in m && m.touches.length === 2)
      return !l.current.allowPinchZoom;
    var b = $t(m), C = n2.current, w = "deltaX" in m ? m.deltaX : C[0] - b[0], P = "deltaY" in m ? m.deltaY : C[1] - b[1], x, U = m.target, q = Math.abs(w) > Math.abs(P) ? "h" : "v";
    if ("touches" in m && q === "h" && U.type === "range")
      return false;
    var k = ci(q, U);
    if (!k)
      return true;
    if (k ? x = q : (x = q === "v" ? "h" : "v", k = ci(q, U)), !k)
      return false;
    if (!r.current && "changedTouches" in m && (w || P) && (r.current = x), !x)
      return true;
    var ue = r.current || x;
    return Dc(ue, D, m, ue === "h" ? w : P);
  }, []), f = Q.useCallback(function(m) {
    var D = m;
    if (!(!pt.length || pt[pt.length - 1] !== a3)) {
      var b = "deltaY" in D ? li(D) : $t(D), C = t3.current.filter(function(x) {
        return x.name === D.type && x.target === D.target && jc(x.delta, b);
      })[0];
      if (C && C.should) {
        D.cancelable && D.preventDefault();
        return;
      }
      if (!C) {
        var w = (l.current.shards || []).map(fi).filter(Boolean).filter(function(x) {
          return x.contains(D.target);
        }), P = w.length > 0 ? u(D, w[0]) : !l.current.noIsolation;
        P && D.cancelable && D.preventDefault();
      }
    }
  }, []), h = Q.useCallback(function(m, D, b, C) {
    var w = {
      name: m,
      delta: D,
      target: b,
      should: C
    };
    t3.current.push(w), setTimeout(function() {
      t3.current = t3.current.filter(function(P) {
        return P !== w;
      });
    }, 1);
  }, []), g = Q.useCallback(function(m) {
    n2.current = $t(m), r.current = void 0;
  }, []), p = Q.useCallback(function(m) {
    h(m.type, li(m), m.target, u(m, e3.lockRef.current));
  }, []), I = Q.useCallback(function(m) {
    h(m.type, $t(m), m.target, u(m, e3.lockRef.current));
  }, []);
  Q.useEffect(function() {
    return pt.push(a3), e3.setCallbacks({
      onScrollCapture: p,
      onWheelCapture: p,
      onTouchMoveCapture: I
    }), document.addEventListener("wheel", f, yt), document.addEventListener("touchmove", f, yt), document.addEventListener("touchstart", g, yt), function() {
      pt = pt.filter(function(m) {
        return m !== a3;
      }), document.removeEventListener("wheel", f, yt), document.removeEventListener("touchmove", f, yt), document.removeEventListener("touchstart", g, yt);
    };
  }, []);
  var N = e3.removeScrollBar, v = e3.inert;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [v ? (0, import_jsx_runtime.jsx)(a3, {
      styles: Tc(s)
    }) : null, N ? (0, import_jsx_runtime.jsx)(Ic, {
      gapMode: "margin"
    }) : null]
  });
}
var Cc = ac(ss, Sc);
var ls = Q.forwardRef(function(e3, t3) {
  return (0, import_jsx_runtime.jsx)(Qn, {
    ...Qe({}, e3, {
      ref: t3,
      sideCar: Cc
    })
  });
});
ls.classNames = Qn.classNames;
var Oc = function(e3) {
  if (typeof document > "u")
    return null;
  var t3 = Array.isArray(e3) ? e3[0] : e3;
  return t3.ownerDocument.body;
};
var Mt = /* @__PURE__ */ new WeakMap();
var en = /* @__PURE__ */ new WeakMap();
var tn = {};
var rr = 0;
var fs = function(e3) {
  return e3 && (e3.host || fs(e3.parentNode));
};
var xc = function(e3, t3) {
  return t3.map(function(n2) {
    if (e3.contains(n2))
      return n2;
    var r = fs(n2);
    return r && e3.contains(r) ? r : (console.error("aria-hidden", n2, "in not contained inside", e3, ". Doing nothing"), null);
  }).filter(function(n2) {
    return !!n2;
  });
};
var zc = function(e3, t3, n2, r) {
  var s = xc(t3, Array.isArray(e3) ? e3 : [e3]);
  tn[n2] || (tn[n2] = /* @__PURE__ */ new WeakMap());
  var a3 = tn[n2], l = [], u = /* @__PURE__ */ new Set(), f = new Set(s), h = function(p) {
    !p || u.has(p) || (u.add(p), h(p.parentNode));
  };
  s.forEach(h);
  var g = function(p) {
    !p || f.has(p) || Array.prototype.forEach.call(p.children, function(I) {
      if (u.has(I))
        g(I);
      else
        try {
          var N = I.getAttribute(r), v = N !== null && N !== "false", m = (Mt.get(I) || 0) + 1, D = (a3.get(I) || 0) + 1;
          Mt.set(I, m), a3.set(I, D), l.push(I), m === 1 && v && en.set(I, true), D === 1 && I.setAttribute(n2, "true"), v || I.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", I, b);
        }
    });
  };
  return g(t3), u.clear(), rr++, function() {
    l.forEach(function(p) {
      var I = Mt.get(p) - 1, N = a3.get(p) - 1;
      Mt.set(p, I), a3.set(p, N), I || (en.has(p) || p.removeAttribute(r), en.delete(p)), N || p.removeAttribute(n2);
    }), rr--, rr || (Mt = /* @__PURE__ */ new WeakMap(), Mt = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new WeakMap(), tn = {});
  };
};
var Rc = function(e3, t3, n2) {
  n2 === void 0 && (n2 = "data-aria-hidden");
  var r = Array.from(Array.isArray(e3) ? e3 : [e3]), s = Oc(e3);
  return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), zc(r, s, n2, "aria-hidden")) : function() {
    return null;
  };
};
var ds = "Dialog";
var [hs, Dl] = vu(ds);
var [Uc, Fe] = hs(ds);
var kc = (e3) => {
  const { __scopeDialog: t3, children: n2, open: r, defaultOpen: s, onOpenChange: a3, modal: l = true } = e3, u = (0, import_react.useRef)(null), f = (0, import_react.useRef)(null), [h = false, g] = Du({
    prop: r,
    defaultProp: s,
    onChange: a3
  });
  return (0, import_react.createElement)(Uc, {
    scope: t3,
    triggerRef: u,
    contentRef: f,
    contentId: Hn(),
    titleId: Hn(),
    descriptionId: Hn(),
    open: h,
    onOpenChange: g,
    onOpenToggle: (0, import_react.useCallback)(
      () => g(
        (p) => !p
      ),
      [
        g
      ]
    ),
    modal: l
  }, n2);
};
var Pc = "DialogTrigger";
var Qc = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, s = Fe(Pc, n2), a3 = Lt(t3, s.triggerRef);
  return (0, import_react.createElement)(ut.button, L({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": s.open,
    "aria-controls": s.contentId,
    "data-state": Ur(s.open)
  }, r, {
    ref: a3,
    onClick: qe(e3.onClick, s.onOpenToggle)
  }));
});
var gs = "DialogPortal";
var [Bc, ys] = hs(gs, {
  forceMount: void 0
});
var Wc = (e3) => {
  const { __scopeDialog: t3, forceMount: n2, children: r, container: s } = e3, a3 = Fe(gs, t3);
  return (0, import_react.createElement)(Bc, {
    scope: t3,
    forceMount: n2
  }, import_react.Children.map(
    r,
    (l) => (0, import_react.createElement)(Pn, {
      present: n2 || a3.open
    }, (0, import_react.createElement)(Vu, {
      asChild: true,
      container: s
    }, l))
  ));
};
var Ar = "DialogOverlay";
var Fc = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = ys(Ar, e3.__scopeDialog), { forceMount: r = n2.forceMount, ...s } = e3, a3 = Fe(Ar, e3.__scopeDialog);
  return a3.modal ? (0, import_react.createElement)(Pn, {
    present: r || a3.open
  }, (0, import_react.createElement)(Yc, L({}, s, {
    ref: t3
  }))) : null;
});
var Yc = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, s = Fe(Ar, n2);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    (0, import_react.createElement)(ls, {
      as: Rr,
      allowPinchZoom: true,
      shards: [
        s.contentRef
      ]
    }, (0, import_react.createElement)(ut.div, L({
      "data-state": Ur(s.open)
    }, r, {
      ref: t3,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
});
var Tt = "DialogContent";
var _c = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = ys(Tt, e3.__scopeDialog), { forceMount: r = n2.forceMount, ...s } = e3, a3 = Fe(Tt, e3.__scopeDialog);
  return (0, import_react.createElement)(Pn, {
    present: r || a3.open
  }, a3.modal ? (0, import_react.createElement)(Gc, L({}, s, {
    ref: t3
  })) : (0, import_react.createElement)(Zc, L({}, s, {
    ref: t3
  })));
});
var Gc = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = Fe(Tt, e3.__scopeDialog), r = (0, import_react.useRef)(null), s = Lt(t3, n2.contentRef, r);
  return (0, import_react.useEffect)(() => {
    const a3 = r.current;
    if (a3)
      return Rc(a3);
  }, []), (0, import_react.createElement)(ps, L({}, e3, {
    ref: s,
    trapFocus: n2.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: qe(e3.onCloseAutoFocus, (a3) => {
      var l;
      a3.preventDefault(), (l = n2.triggerRef.current) === null || l === void 0 || l.focus();
    }),
    onPointerDownOutside: qe(e3.onPointerDownOutside, (a3) => {
      const l = a3.detail.originalEvent, u = l.button === 0 && l.ctrlKey === true;
      (l.button === 2 || u) && a3.preventDefault();
    }),
    onFocusOutside: qe(
      e3.onFocusOutside,
      (a3) => a3.preventDefault()
    )
  }));
});
var Zc = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = Fe(Tt, e3.__scopeDialog), r = (0, import_react.useRef)(false);
  return (0, import_react.createElement)(ps, L({}, e3, {
    ref: t3,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (s) => {
      var a3;
      if ((a3 = e3.onCloseAutoFocus) === null || a3 === void 0 || a3.call(e3, s), !s.defaultPrevented) {
        var l;
        r.current || (l = n2.triggerRef.current) === null || l === void 0 || l.focus(), s.preventDefault();
      }
      r.current = false;
    },
    onInteractOutside: (s) => {
      var a3, l;
      (a3 = e3.onInteractOutside) === null || a3 === void 0 || a3.call(e3, s), s.defaultPrevented || (r.current = true);
      const u = s.target;
      ((l = n2.triggerRef.current) === null || l === void 0 ? void 0 : l.contains(u)) && s.preventDefault();
    }
  }));
});
var ps = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: a3, ...l } = e3, u = Fe(Tt, n2), f = (0, import_react.useRef)(null), h = Lt(t3, f);
  return Hu(), (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(Bu, {
    asChild: true,
    loop: true,
    trapped: r,
    onMountAutoFocus: s,
    onUnmountAutoFocus: a3
  }, (0, import_react.createElement)(ku, L({
    role: "dialog",
    id: u.contentId,
    "aria-describedby": u.descriptionId,
    "aria-labelledby": u.titleId,
    "data-state": Ur(u.open)
  }, l, {
    ref: h,
    onDismiss: () => u.onOpenChange(false)
  }))), false);
});
var Ms = "DialogTitle";
var Vc = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, s = Fe(Ms, n2);
  return (0, import_react.createElement)(ut.h2, L({
    id: s.titleId
  }, r, {
    ref: t3
  }));
});
var qc = "DialogClose";
var Xc = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, s = Fe(qc, n2);
  return (0, import_react.createElement)(ut.button, L({
    type: "button"
  }, r, {
    ref: t3,
    onClick: qe(
      e3.onClick,
      () => s.onOpenChange(false)
    )
  }));
});
function Ur(e3) {
  return e3 ? "open" : "closed";
}
var Hc = "DialogTitleWarning";
Au(Hc, {
  contentName: Tt,
  titleName: Ms,
  docsSlug: "dialog"
});
var Kc = kc;
var Jc = Qc;
var $c = Wc;
var el = Fc;
var tl = _c;
var Wt = Vc;
var nl = Xc;
var rl = (e3) => (0, import_jsx_runtime.jsxs)(Kc, {
  open: e3.open,
  onOpenChange: e3.onOpenChange,
  children: [(0, import_jsx_runtime.jsx)(Jc, {
    asChild: true,
    children: e3.trigger
  }), (0, import_jsx_runtime.jsx)($c, {
    children: (0, import_jsx_runtime.jsx)(el, {
      className: "wkit-dialog__overlay",
      children: (0, import_jsx_runtime.jsx)(tl, {
        ...e3.contentProps,
        className: Bt("wkit-dialog__content", e3.className),
        style: e3.style,
        children: e3.children
      })
    })
  })]
});
function Ns() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.8332 10.0003H4.1665M4.1665 10.0003L9.99984 15.8337M4.1665 10.0003L9.99984 4.16699",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function il() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15 5L5 15M5 5L15 15",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function sl() {
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime.jsx)("g", {
      clipPath: "url(#clip0_1790_28273)",
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M9.99989 10.9766L14.1249 6.85156L15.3032 8.0299L9.99989 13.3332L4.69656 8.0299L5.87489 6.85156L9.99989 10.9766Z",
        fill: "currentColor"
      })
    }), (0, import_jsx_runtime.jsx)("defs", {
      children: (0, import_jsx_runtime.jsx)("clipPath", {
        id: "clip0_1790_28273",
        children: (0, import_jsx_runtime.jsx)("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(20) rotate(90)"
        })
      })
    })]
  });
}
var al = (e3) => {
  const {
    icon: t3,
    alt: n2 = "icon"
  } = e3;
  return (0, import_jsx_runtime.jsx)("div", {
    onClick: e3.onClick,
    className: e3.className,
    style: e3.style,
    children: typeof t3 == "string" ? (0, import_jsx_runtime.jsx)("img", {
      src: t3,
      alt: n2,
      className: e3.elClassName,
      style: e3.elStyle
    }) : import_react.default.cloneElement(t3)
  });
};
var ol = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-dialog__header",
  children: [(0, import_jsx_runtime.jsx)(Wt, {
    className: "wkit-dialog__title",
    children: "Connect Wallet"
  }), (0, import_jsx_runtime.jsx)(nl, {
    style: {
      position: "absolute",
      right: "16px",
      top: "16px"
    },
    className: "wkit-dialog__close",
    children: (0, import_jsx_runtime.jsx)(il, {})
  })]
});
var ul = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-new-to-sui",
  children: [(0, import_jsx_runtime.jsx)("span", {
    className: "wkit-new-to-sui__text",
    children: "New to sui? "
  }), (0, import_jsx_runtime.jsx)("a", {
    className: "wkit-new-to-sui__link",
    href: "https://suiet.app/docs/getting-started",
    target: "_blank",
    children: "Learn More Here"
  })]
});
var cl = (e3) => {
  const {
    wallet: t3
  } = e3, [n2, r] = (0, import_react.useState)("");
  return (0, import_react.useEffect)(() => {
    t3.iconUrl && r(t3.iconUrl);
  }, [t3.iconUrl]), (0, import_jsx_runtime.jsxs)("div", {
    className: "wkit-select-item",
    onClick: () => {
      var _a2;
      (_a2 = e3.onSelect) == null ? void 0 : _a2.call(e3, t3);
    },
    children: [(0, import_jsx_runtime.jsx)(al, {
      icon: n2,
      className: "wkit-select-item__icon",
      elClassName: "wkit-select-item__icon"
    }), t3.label ?? t3.name]
  }, t3.name);
};
var di = (e3) => ze(e3.wallets) ? (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-select__container",
  children: [(0, import_jsx_runtime.jsx)("div", {
    className: "wkit-select__title",
    children: e3.title
  }), ze(e3.wallets) && e3.wallets.map((t3) => (0, import_jsx_runtime.jsx)(cl, {
    wallet: t3,
    onSelect: e3.onSelect
  }, t3.name))]
}) : null;
var ll = (e3) => {
  const {
    wallet: t3
  } = e3;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(Wt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-8px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e3.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Ns, {})
        })
      }), (0, import_jsx_runtime.jsx)(Wt, {
        className: "wkit-dialog__title",
        children: "Install Wallet"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-install",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-install__logo",
        src: t3.iconUrl,
        alt: `${t3.name} logo`
      }), (0, import_jsx_runtime.jsx)("h1", {
        className: "wkit-install__title",
        children: "You havent install this wallet"
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-install__description",
        children: "Install wallet via Chrome Extension Store"
      }), (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-button wkit-install__button",
        onClick: () => {
          var _a2;
          if (!((_a2 = t3.downloadUrl) == null ? void 0 : _a2.browserExtension))
            throw new re(`no downloadUrl config on this wallet: ${t3.name}`);
          window.open(t3.downloadUrl.browserExtension, "_blank");
        },
        children: "Get Wallet"
      })]
    })]
  });
};
var fl = (e3) => {
  const {
    wallet: t3
  } = e3;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(Wt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-6px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e3.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Ns, {})
        })
      }), (0, import_jsx_runtime.jsx)(Wt, {
        className: "wkit-dialog__title",
        children: "Connecting"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-connecting",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-connecting__logo",
        src: t3.iconUrl,
        alt: `logo of ${t3.name}`
      }), (0, import_jsx_runtime.jsxs)("h1", {
        className: "wkit-connecting__title",
        children: ["Opening ", t3.name]
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-connecting__description",
        children: "Confirm connection in the extension"
      })]
    })]
  });
};
var dl = (e3) => {
  const {
    configuredWallets: t3,
    detectedWallets: n2,
    select: r,
    connecting: s
  } = _t(), {
    onConnectSuccess: a3 = () => {
    },
    onConnectError: l = (p) => {
      throw p;
    }
  } = e3, [u, f] = (0, import_react.useState)(), h = (0, import_react.useCallback)(async (p) => {
    if (f(p), p.installed) {
      try {
        await r(p.name);
      } catch (I) {
        l(I);
        return;
      }
      a3(p.name);
    }
  }, [r]);
  function g() {
    if (u) {
      if (!u.installed)
        return (0, import_jsx_runtime.jsx)(ll, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
      if (s)
        return (0, import_jsx_runtime.jsx)(fl, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
    }
    return (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(ol, {}), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-select__scroll",
        children: [(0, import_jsx_runtime.jsx)(di, {
          title: "Popular",
          wallets: t3,
          onSelect: h
        }), (0, import_jsx_runtime.jsx)(di, {
          title: "Others",
          wallets: n2,
          onSelect: h
        })]
      }), (0, import_jsx_runtime.jsx)("div", {
        style: {
          height: "41px",
          flexShrink: "0"
        }
      }), (0, import_jsx_runtime.jsx)(ul, {})]
    });
  }
  return (0, import_jsx_runtime.jsx)(rl, {
    open: e3.open,
    onOpenChange: e3.onOpenChange,
    trigger: e3.children,
    contentProps: {
      onOpenAutoFocus: (p) => {
        p.preventDefault();
      }
    },
    children: g()
  });
};
function hl(e3) {
  const {
    disconnect: t3,
    account: n2,
    chain: r,
    connected: s,
    name: a3
  } = _t(), {
    balance: l
  } = du(), [u, f] = (0, import_react.useState)(false), h = (0, import_react.useCallback)(() => !r || r.id === wt.id ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: "Unknown Chain"
  }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [Ia(l ?? 0), " SUI"]
  }), [l, r]);
  return s ? (0, import_jsx_runtime.jsxs)("div", {
    className: Bt("wkit-connected-container", e3.className),
    style: e3.style,
    children: [(0, import_jsx_runtime.jsxs)("button", {
      className: Bt("wkit-connected-button"),
      onClick: () => {
        f(!u);
      },
      children: [(0, import_jsx_runtime.jsx)("span", {
        className: "wkit-connected-button__balance",
        children: h()
      }), (0, import_jsx_runtime.jsx)("div", {
        className: "wkit-connected-button__divider"
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-address-select",
        children: [(0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__address",
          children: va(n2 == null ? void 0 : n2.address)
        }), (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__right-arrow",
          children: (0, import_jsx_runtime.jsx)(sl, {})
        })]
      })]
    }), u && (0, import_jsx_runtime.jsx)("div", {
      className: "wkit-disconnect-button__container",
      children: (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-disconnect-button",
        onClick: async () => {
          var _a2, _b;
          f(false);
          try {
            await t3();
          } catch (g) {
            (_a2 = e3 == null ? void 0 : e3.onDisconnectError) == null ? void 0 : _a2.call(e3, g);
            return;
          }
          (_b = e3 == null ? void 0 : e3.onDisconnectSuccess) == null ? void 0 : _b.call(e3, a3);
        },
        children: "Disconnect"
      })
    })]
  }) : null;
}
var jl = (e3) => {
  const {
    label: t3 = "Connect Button"
  } = e3, [n2, r] = (0, import_react.useState)(false), {
    connected: s
  } = _t();
  return (0, import_react.useEffect)(() => {
    s && r(false);
  }, [s]), (0, import_jsx_runtime.jsx)(dl, {
    open: n2,
    onOpenChange: (a3) => {
      s || r(a3);
    },
    onConnectSuccess: e3.onConnectSuccess,
    onConnectError: e3.onConnectError,
    children: (0, import_jsx_runtime.jsx)("div", {
      children: s ? (0, import_jsx_runtime.jsx)(hl, {
        className: Bt(e3.className),
        style: e3.style,
        onDisconnectSuccess: (a3) => {
          var _a2;
          r(false), (_a2 = e3 == null ? void 0 : e3.onDisconnectSuccess) == null ? void 0 : _a2.call(e3, a3);
        },
        onDisconnectError: e3.onDisconnectError
      }) : (0, import_jsx_runtime.jsx)("button", {
        className: Bt("wkit-button", e3.className),
        style: e3.style,
        children: e3.children || t3
      })
    })
  });
};
function Is(e3) {
  if (typeof e3 == "string") {
    console.warn(`[DEPRECATED] ${e3}`);
    return;
  }
  const { name: t3, message: n2, migrationDoc: r } = e3;
  console.warn(`[DEPRECATED] ${t3} is no longer supported. ` + n2 + (r ? ` | Check migration doc: ${r}` : ""));
}
function Tl() {
  return Is({
    name: "getDefaultWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
function Ll() {
  return Is({
    name: "getAllWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
export {
  Na as AccountAssetManager,
  Ma as AccountCoinManager,
  pa as AccountObjectManager,
  vo as AllDefaultWallets,
  Si as BaseError,
  Dr as CoinObject,
  jl as ConnectButton,
  dl as ConnectModal,
  Ce as ConnectionStatus,
  So as DefaultChains,
  No as ElliWallet,
  ie as ErrorCode,
  uo as EthosWallet,
  K as FeatureName,
  mo as FrontierWallet,
  fo as GlassWallet,
  re as KitError,
  co as MartianWallet,
  ho as MorphisWallet,
  Mo as NightlyWallet,
  go as OneKeyWallet,
  Ao as PhantomWallet,
  Ze as PresetWallet,
  po as SensuiWallet,
  yo as SpacecyWallet,
  Do as SuiChainId,
  jo as SuiDevnetChain,
  Lo as SuiMainnetChain,
  To as SuiTestnetChain,
  oo as SuiWallet,
  ao as SuietWallet,
  lo as SurfWallet,
  Io as TokenPocketWallet,
  mt as Uint8arrayTool,
  wt as UnknownChain,
  Oa as WalletAdapter,
  Fi as WalletContext,
  Se as WalletError,
  Ci as WalletNotImplementError,
  bl as WalletProvider,
  Wa as WalletRadar,
  Tr as WalletType,
  va as addressEllipsis,
  vl as defineStashedWallet,
  he as defineWallet,
  bi as formatCurrency,
  Ia as formatSUI,
  Ll as getAllWallets,
  Tl as getDefaultWallets,
  wo as handleConnectionError,
  En as has,
  bo as normalizeTransaction,
  so as registerStashedWallet,
  Eo as serializeTransaction,
  Al as stringBytesToString,
  Ti as stringBytesToUint8Array,
  du as useAccountBalance,
  lu as useChain,
  fu as useCoinBalance,
  El as useSuiClient,
  wl as useSuiProvider,
  _t as useWallet,
  Ca as verifySignedMessage
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@suiet/wallet-kit/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@suiet_wallet-kit.js.map
